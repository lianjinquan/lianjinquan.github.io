<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis基础 | soul</title><meta name="description" content="redis基础整理   redis简介 Remote Dictionary Server(Redis) 是一个key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值(value)可以是 字符串(String), 哈希(Hash), 列"><meta name="keywords" content="redis基础"><meta name="author" content="soul"><meta name="copyright" content="soul"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://www.lianjinquan.com/2020/03/09/redis/redis%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="redis基础"><meta property="og:url" content="https://www.lianjinquan.com/2020/03/09/redis/redis%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="soul"><meta property="og:description" content="redis基础整理   redis简介 Remote Dictionary Server(Redis) 是一个key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值(value)可以是 字符串(String), 哈希(Hash), 列"><meta property="og:image" content="https://i.erosouko.pub/2020/08/30/3529796bec160.jpg"><meta property="article:published_time" content="2020-03-09T09:56:08.000Z"><meta property="article:modified_time" content="2020-06-23T14:39:53.380Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.2',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小時前","day":"天前"},
  copyright: undefined,
  ClickShowText: {"text":"我,喜欢,你","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-06-23 22:39:53'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/less.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/tag.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">redis简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AEkey"><span class="toc-number">2.</span> <span class="toc-text">键key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">String(字符串)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E5%93%88%E5%B8%8C"><span class="toc-number">4.</span> <span class="toc-text">Hash(哈希)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E5%88%97%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">List(列表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">Set(集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">Sorted Set(有序集合)</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.erosouko.pub/2020/08/30/3529796bec160.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">soul</a></span><span class="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">redis基础</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-09T09:56:08.000Z" title="发表于 2020-03-09 17:56:08">2020-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-06-23T14:39:53.380Z" title="更新于 2020-06-23 22:39:53">2020-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/redis%E5%9F%BA%E7%A1%80/">redis基础</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>redis基础整理</p>
<a id="more"></a>

<h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><ul>
<li>Remote Dictionary Server(Redis) 是一个key-value存储系统。</li>
<li>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</li>
<li>它通常被称为数据结构服务器，因为值(value)可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</li>
<li>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</li>
</ul>
<p><strong>Redis 与其他 key - value 缓存产品有以下三个特点：</strong></p>
<ol>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
<p><strong>优势</strong></p>
<ol>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ol>
<p>默认端口 6379</p>
<p><strong>数据类型</strong><br>五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<hr>
<h3 id="键key"><a href="#键key" class="headerlink" title="键key"></a>键key</h3><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>del key </code></td>
<td>删除已存在的键。不存在的 key 会被忽略。返回被删除 key 的数量。</td>
</tr>
<tr>
<td><code>dump key</code></td>
<td>序列化给定 key ，并返回被序列化的值。如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td>检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。</td>
</tr>
<tr>
<td><code>expire key time</code></td>
<td>设置 key 的过期时间。单位秒。设置成功返回 1。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td>
</tr>
<tr>
<td><code>expireat key time</code></td>
<td>以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td>
</tr>
<tr>
<td><code>pexpire key milliseconds</code></td>
<td>设置 key 的过期时间。单位毫秒，设置成功，返回 1。key 不存在或设置失败，返回 0。</td>
</tr>
<tr>
<td><code>pexpireat key time</code></td>
<td>设置 key 的过期时间，以毫秒计。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td>
</tr>
<tr>
<td><code>keys pattern</code></td>
<td>查找所有符合给定模式 pattern 的 key。返回符合给定模式的 key 列表 (Array)。</td>
</tr>
<tr>
<td><code>move key db</code></td>
<td>将当前数据库的 key 移动到给定的数据库 db 当中。移动成功返回 1 ，失败则返回 0 。</td>
</tr>
<tr>
<td><code>persist key</code></td>
<td>移除给定 key 的过期时间，使得 key 永不过期。当过期时间移除成功时，返回 1 。 如果 key 不存在或 key 没有设置过期时间，返回 0 。</td>
</tr>
<tr>
<td><code>pttl key</code></td>
<td>返回 key 的剩余过期时间。单位毫秒。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以毫秒为单位，返回 key 的剩余生存时间。</td>
</tr>
<tr>
<td><code>ttl key </code></td>
<td>返回 key 的剩余过期时间。单位秒。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</td>
</tr>
<tr>
<td><code>randomkey</code></td>
<td>从当前数据库中随机返回一个 key 。当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil （windows 系统返回 null）。</td>
</tr>
<tr>
<td><code>rename oldkey newkey</code></td>
<td>修改 key 的名称。改名成功时提示 OK ，失败时候返回一个错误。</td>
</tr>
<tr>
<td><code>renamenx oldkey newkey</code></td>
<td>在新的 key 不存在时修改 key 的名称。修改成功，返回 1 。 如果 newkey 已经存在，返回 0 。</td>
</tr>
<tr>
<td><code>type key </code></td>
<td>返回 key 所储存的值的类型。数据类型有 none (key不存在)  string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表)</td>
</tr>
<tr>
<td><code>select 0</code></td>
<td>指定数据库0</td>
</tr>
</tbody></table>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><ol>
<li>String 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</li>
<li>String 类型是二进制安全的。意思是 redis 的 String 可以包含任何数据。比如jpg图片或者序列化的对象。</li>
<li>String 类型的值最大能存储 512MB。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>set key value</code></td>
<td>设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。总是返回 OK 。</td>
</tr>
<tr>
<td><code>get key </code></td>
<td>获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误。</td>
</tr>
<tr>
<td><code>getrange key start end</code></td>
<td>获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。返回截取得到的子字符串。</td>
</tr>
<tr>
<td><code>getset key value</code></td>
<td>设置指定 key 的值，并返回 key 的旧值。当 key 没有旧值时，即 key 不存在时，返回 nil 。当 key 存在但不是字符串类型时，返回一个错误。</td>
</tr>
<tr>
<td><code>getbit key offset</code></td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当偏移量 offset比字符串值的长度大，或者 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td><code>mget key1 key2 ... </code></td>
<td>返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。一个包含所有给定 key 的值的列表。</td>
</tr>
<tr>
<td><code>setbit key offset </code></td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。返回指定偏移量原来储存的位。</td>
</tr>
<tr>
<td><code>setex key time value </code></td>
<td>为指定的 key 设置值及其过期时间。如果 key 已经存在，setex命令将会替换旧的值。</td>
</tr>
<tr>
<td><code>setnx key value</code></td>
<td>在指定的 key 不存在时，为 key 设置指定的值。设置成功，返回 1 。 设置失败，返回 0。</td>
</tr>
<tr>
<td><code>setrange key offset value </code></td>
<td>用指定的字符串value覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。返回被修改后的字符串长度。</td>
</tr>
<tr>
<td><code>strlen key</code></td>
<td>获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。当 key 不存在时，返回 0。</td>
</tr>
<tr>
<td><code>mset key1 value1 key2 value2 ...</code></td>
<td>同时设置一个或多个 key-value 对。总是返回 OK 。</td>
</tr>
<tr>
<td><code>msetnx key1 value1 key2 value2 ...</code></td>
<td>所有给定 key 都不存在时，同时设置一个或多个key-value对。当所有 key 都成功设置，返回1。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。</td>
</tr>
<tr>
<td><code>psetex key time value</code></td>
<td>设置 key 的生存时间。单位毫秒。设置成功时返回 OK 。</td>
</tr>
<tr>
<td><code>incr key</code></td>
<td>将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td>
</tr>
<tr>
<td><code>incrby key amount</code></td>
<td>将 key 中储存的数字加上指定的增量值。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td>
</tr>
<tr>
<td><code>incrbyfloat key amount</code></td>
<td>为 key 中所储存的值加上指定的浮点数增量值。如果 key 不存在，那么 incrbyfloat会先将 key 的值设为 0 ，再执行加法操作。</td>
</tr>
<tr>
<td><code>decr key</code></td>
<td>将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td>
</tr>
<tr>
<td><code>decrby key amount</code></td>
<td>将 key 所储存的值减去指定的减量值。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td>
</tr>
<tr>
<td><code>append key value</code></td>
<td>为指定的 key 追加值。如果 key 已经存在并且是一个字符串， append命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， append就简单地将给定 key 设为 value ，就像执行 set key value 一样。返回追加指定值之后， key 中字符串的长度。</td>
</tr>
</tbody></table>
<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><ol>
<li>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</li>
<li>Redis 中每个 hash 可以存储40多亿键值对。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>hdel key field1 field2 ... </code></td>
<td>删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。返回被成功删除字段的数量，不包括被忽略的字段。</td>
</tr>
<tr>
<td><code>hexists key field</code></td>
<td>查看哈希表的指定字段是否存在。如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。</td>
</tr>
<tr>
<td><code>hget key flied </code></td>
<td>返回哈希表中指定字段的值。如果给定的字段或 key 不存在时，返回 nil 。</td>
</tr>
<tr>
<td><code>hgetall key </code></td>
<td>返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。 若 key 不存在，返回空列表。</td>
</tr>
<tr>
<td><code>hincrby key filed number</code></td>
<td>为哈希表中的字段值加上指定增量值。增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 key 不存在，一个新的哈希表被创建并执行 hincrby 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行 hincrby 命令将造成一个错误。</td>
</tr>
<tr>
<td><code>hincrbyfloat key field incrment </code></td>
<td>为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。返回哈希表中字段的值。</td>
</tr>
<tr>
<td><code>hkeys key </code></td>
<td>获取哈希表中的所有域（field）。返回包含哈希表中所有域（field）列表。 当 key 不存在时，返回一个空列表。</td>
</tr>
<tr>
<td><code>hlen key</code></td>
<td>获取哈希表中字段的数量。 当 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td><code>hmget key filed1 filed2 ... </code></td>
<td>返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。表值的排列顺序和指定字段的请求顺序一样。</td>
</tr>
<tr>
<td><code>hmset key filed1 value1 field2 value2 ...</code></td>
<td>同时将多个 field-value (字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作。如果命令执行成功，返回 OK 。</td>
</tr>
<tr>
<td><code>hset key field value</code></td>
<td>为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。</td>
</tr>
<tr>
<td><code>hsetnx key field value </code></td>
<td>为哈希表中不存在的的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。</td>
</tr>
<tr>
<td><code>hvals key field value </code></td>
<td>返回哈希表所有域(field)的值。返回一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表。</td>
</tr>
</tbody></table>
<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><p><strong>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。一个列表最多可以包含 4294967295个元素 (每个列表超过40亿个元素)。</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>blpop list1 list2 ...timeout </code></td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。单位秒。</td>
</tr>
<tr>
<td><code>brpop list1 list2 ... timeout</code></td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</td>
</tr>
<tr>
<td><code>brpoplpush</code></td>
<td>从列表中取出最后一个元素，并插入到另外一个列表的头部； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</td>
</tr>
<tr>
<td><code>lindex key index_position</code></td>
<td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。返回列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回 nil 。</td>
</tr>
<tr>
<td><code>llen key</code></td>
<td>返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。</td>
</tr>
<tr>
<td><code>lpop key</code></td>
<td>移除并返回列表的第一个元素。 当列表 key 不存在时，返回 nil 。</td>
</tr>
<tr>
<td><code>lpush key value1 value2 ... </code></td>
<td>将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 lpush 操作。 当 key 存在但不是列表类型时，返回一个错误。执行成功返回列表的长度。</td>
</tr>
<tr>
<td><code>lpushx key value1 value2 ...</code></td>
<td>将一个值插入到已存在的列表头部，列表不存在时操作无效。返回命令执行之后，列表的长度。</td>
</tr>
<tr>
<td><code>lrange key start end</code></td>
<td>返回列表中指定区间内的元素，区间以偏移量 start 和 end 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td><code>lrem key count value </code></td>
<td>根据参数 count 的值，移除列表中与参数 value 相等的元素。返回被移除元素的数量。 列表不存在时返回 0 。</td>
</tr>
<tr>
<td><code>lset key index value</code></td>
<td>通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行 lset 时，返回一个错误。操作成功返回 ok ，否则返回错误信息。</td>
</tr>
<tr>
<td><code>ltrim key start stop</code></td>
<td>对一个列表进行修剪(trim)，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 0 表示列表的第一个元素，下标 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td><code>rpop key</code></td>
<td>移除列表的最后一个元素，返回值为移除的元素。当列表不存在时，返回 nil 。</td>
</tr>
<tr>
<td><code>rpush key value1 value2</code></td>
<td>将一个或多个值插入到列表的尾部(最右边)。如果列表不存在，一个空列表会被创建并执行 rpush 操作。 当列表存在但不是列表类型时，返回一个错误。返回执行 rpush 操作后，列表的长度。</td>
</tr>
<tr>
<td><code>rpoplpush source_key destination_key</code></td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回。返回被弹出的元素。</td>
</tr>
</tbody></table>
<p> <code>linsert key before[after] pivot value </code><br> 在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。<br><code>rpushx key value1 value2 ...</code><br>将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。返回执行 rpushx 操作后，列表的长度。count 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。 count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。count = 0 : 移除表中所有与 value 相等的值。</p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><ol>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
<li>集合中最大的成员数为4294967295, 每个集合可存储40多亿个成员。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>sadd key value1 value2...</code></td>
<td>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。当集合 key 不是集合类型时，返回一个错误。返回被添加到集合中的新元素的数量，不包括被忽略的元素。</td>
</tr>
<tr>
<td><code>scard key</code></td>
<td>返回集合中元素的数量。 当集合 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td><code>sdiffstore destionation_key key1 key2 ...</code></td>
<td>将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖。返回结果集中的元素数量。</td>
</tr>
<tr>
<td><code>sinter key key1 key2 ...</code></td>
<td>返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</td>
</tr>
<tr>
<td><code>sinterstore destionation_key key key1 key2 ...</code></td>
<td>给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。返回存储交集的集合的元素数量</td>
</tr>
<tr>
<td><code>sismember key value</code></td>
<td>判断成员元素是否是集合的成员。如果成员元素是集合的成员，返回 1 。 如果成员元素不是集合的成员，或 key 不存在，返回 0 。</td>
</tr>
<tr>
<td><code>smembers key</code></td>
<td>返回集合中的所有的成员。 不存在的集合 key 被视为空集合。</td>
</tr>
<tr>
<td><code>smove source destination member</code></td>
<td>将指定成员 member 元素从 source 集合移动到 destination 集合。smove 是原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 smove 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。当 destination 集合已经包含 member 元素时， smove 命令只是简单地将 source 集合中的 member 元素删除。当 source 或 destination 不是集合类型时，返回一个错误。如果成员元素被成功移除，返回 1 。 如果成员元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</td>
</tr>
<tr>
<td><code>spop key [count]</code></td>
<td>移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素。该命令类似 srandmember 命令，但 spop 将随机元素从集合中移除并返回，而 srandmember 则仅仅返回随机元素，而不对集合进行任何改动。返回被移除的随机元素。 当集合不存在或是空集时，返回 nil 。</td>
</tr>
<tr>
<td><code>srem key member1 member2 ...</code></td>
<td>移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。当 key 不是集合类型，返回一个错误。返回被成功移除的元素的数量，不包括被忽略的元素。</td>
</tr>
<tr>
<td><code>sunion key key1 key2 ...</code></td>
<td>返回给定集合的并集。不存在的集合 key 被视为空集。返回并集成员的列表。</td>
</tr>
<tr>
<td><code>sunionstore destination key key1 key2 ...</code></td>
<td>将给定集合的并集存储在指定的集合 destination 中。如果 destination 已经存在，则将其覆盖。返回结果集中的元素数量。</td>
</tr>
<tr>
<td><code>sscan key cursor [match pattern] [count count]</code></td>
<td>迭代集合中键的元素。返回数组列表</td>
</tr>
<tr>
<td><code>srandmember key [count]</code></td>
<td>返回集合中的一个随机元素。从 Redis 2.6 版本开始， srandmember 命令接受可选的 count 参数：如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。该操作和 spop 相似，但 spop 将随机元素从集合中移除并返回，而 srandmember 则仅仅返回随机元素，而不对集合进行任何改动。</td>
</tr>
<tr>
<td><code>sdiff first_key other_key1 other_key2 ...</code></td>
<td>返回给定集合之间的差集。不存在的集合 key 将视为空集。返回包含差集成员的列表。差集的结果来自前面的 first_key ,而不是后面的 other_key1，也不是整个 first_key other_key1..other_keyn 的差集。实例:key1 = {a,b,c,d}；key2 = {c}；key3 = {a,c,e}；sdiff key1 key2 key3 = {b,d}</td>
</tr>
</tbody></table>
<ul>
<li></li>
</ul>
<h3 id="Sorted-Set-有序集合"><a href="#Sorted-Set-有序集合" class="headerlink" title="Sorted Set(有序集合)"></a>Sorted Set(有序集合)</h3><ol>
<li>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</li>
<li>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li>有序集合的成员是唯一的,但分数(score)却可以重复。</li>
<li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>zadd key score1 value1 score2 value2 ...</code></td>
<td>将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 key 不存在，则创建一个空的有序集并执行 zadd 操作。当 key 存在但不是有序集类型时，返回一个错误。返回被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</td>
</tr>
<tr>
<td><code>zcard key</code></td>
<td>计算集合中元素的数量。当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td><code>zcount key min max</code></td>
<td>计算有序集合中指定分数区间的成员数量。返回分数值在 min 和 max 之间的成员的数量。</td>
</tr>
<tr>
<td><code>zincrby key increment member</code></td>
<td>对有序集合中指定成员的分数加上增量 increment。可以通过传递一个负数值 increment ，让分数减去相应的值，比如 zincrby key -5 member ，就是让 member 的 score 值减去 5 。当 key 不存在，或分数不是 key 的成员时， zincrby key increment member 等同于 zadd key increment member 。当 key 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。返回member 成员的新分数值，以字符串形式表示。</td>
</tr>
<tr>
<td><code>zlexcount key min max</code></td>
<td>计算有序集合中指定字典区间内成员数量。</td>
</tr>
<tr>
<td><code>zrange key start stop [withscores]</code></td>
<td>返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用zrevrange命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。返回指定区间内，带有分数值(可选)的有序集成员的列表。</td>
</tr>
<tr>
<td><code>zrangebylex key min max [limit offset count]</code></td>
<td>通过字典区间返回有序集合的成员。返回指定区间内的元素列表。</td>
</tr>
<tr>
<td><code>zrank key member</code></td>
<td>返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。如果成员是有序集 key 的成员，返回 member 的排名。 如果成员不是有序集 key 的成员，返回 nil 。</td>
</tr>
<tr>
<td><code>zrem key member [member ...]</code></td>
<td>移除有序集中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。返回被成功移除的成员的数量，不包括被忽略的成员。</td>
</tr>
<tr>
<td><code>zremrangebylex key min max</code></td>
<td>移除有序集合中给定的字典区间的所有成员。返回被成功移除的成员的数量，不包括被忽略的成员。</td>
</tr>
<tr>
<td><code>zremrangebyrank key start stop</code></td>
<td>移除有序集中，指定排名(rank)区间内的所有成员。返回被移除成员的数量。</td>
</tr>
<tr>
<td><code>zrevrange key start stop [withscores]</code></td>
<td>返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按分数值递减的次序排列这一点外， zrevrange 命令的其他方面和 zrange命令一样。返回指定区间内，带有分数值(可选)的有序集成员的列表。</td>
</tr>
<tr>
<td><code>zrevrank key member</code></td>
<td>返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。排名以 0 为底，也就是说， 分数值最大的成员排名为 0 。使用 zrank 命令可以获得成员按分数值递增(从小到大)排列的排名。如果成员是有序集 key 的成员，返回成员的排名。 如果成员不是有序集 key 的成员，返回 nil 。</td>
</tr>
<tr>
<td><code>zscore key member</code></td>
<td>返回有序集中，成员的分数值，以字符串形式表示。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</td>
</tr>
</tbody></table>
<ul>
<li><code>zscan key cursor [match pattern] [count count]</code><br>用于迭代有序集合中的元素（包括元素成员和元素分值）。返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</li>
<li><code>zinterstore  destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><br>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。返回保存到目标结果集的的成员数量。</li>
<li><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><br>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。返回保存到 destination 的结果集的成员数量。</li>
<li><code>zrevrangebyscore key max min [withscores] [limit offset count]</code><br>返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。除了成员按分数值递减的次序排列这一点外， zrevrangebyscore 命令的其他方面和 zrangebyscore 命令一样。返回指定区间内，带有分数值(可选)的有序集成员的列表。</li>
<li><code>zrangebyscore key min max [withscores] [limit offset count]</code><br>返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。举个例子：zrangebyscore zset (1 5   返回所有符合条件 1 &lt; score &lt;= 5 的成员，而 zrangebyscore  zset (5 (10  则返回所有符合条件 5 &lt; score &lt; 10 的成员。返回指定区间内，带有分数值(可选)的有序集成员的列表。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">soul</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.lianjinquan.com/2020/03/09/redis/redis%E5%9F%BA%E7%A1%80/">https://www.lianjinquan.com/2020/03/09/redis/redis%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lianjinquan.com" target="_blank">soul</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis%E5%9F%BA%E7%A1%80/">redis基础</a></div><div class="post_share"><div class="social-share" data-image="https://i.erosouko.pub/2020/08/30/3529796bec160.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/03/09/java/%E9%9D%A2%E8%AF%95/"><img class="prev-cover" data-lazy-src="https://i.erosouko.pub/2020/08/30/3529796bec160.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试</div></div></a></div><div class="next-post pull-right"><a href="/2020/03/07/java/%E5%BC%82%E5%B8%B8/"><img class="next-cover" data-lazy-src="https://i.erosouko.pub/2020/08/30/3529796bec160.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">异常</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 <i style="color:#FF6A6A;animation: announ_animation 0.8s linear infinite;" class="fa fa-heartbeat"></i> soul</div><div class="timeDate"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div><div class="github-badge"><a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动"><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a><a style="color: #fff" rel="license" href="https://gitee.com/" target="_blank" title="静态网页托管于 Gitee Pages"><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">码云</span></a><a style="color: #fff" rel="license" href="https://account.aliyun.com/" target="_blank" title="阿里云 提供 CDN 加速服务"><span class="badge-subject">CDN</span><span class="badge-value bg-orange">阿里云</span></a><a style="color: #fff" rel="license" href="https://jerryc.me" target="_blank" title="站点使用 Butterfly主题"><span class="badge-subject">Theme</span><span class="badge-value bg-blue">Butterfly</span></a><a style="color: #fff" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"><span class="badge-subject"><i class="fa fa-copyright"></i></span><span class="badge-value bg-lightgrey">BY-NC-SA 4.0</span></a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/icp.png"/><span>豫ICP备17024771号</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '4mmf5rP5CM4lLiR0xbH9fTl0-gzGzoHsz',
      appKey: 'f5uVeDfz1xfnN0cLwY92AUUt',
      placeholder: '留下你的足迹吧',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="/js/less.js"></script><script data-pjax src="/js/botui.js"></script><script data-pjax src="/js/timeDate.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script src="/js/ip_content.js"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>