<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运行时数据区概述及线程</title>
      <link href="/2020/10/11/jvm/jvm03/"/>
      <url>/2020/10/11/jvm/jvm03/</url>
      
        <content type="html"><![CDATA[<p>运行时数据区概述及线程</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运行时数据区，也就是下图这部分，它是类加载完成后的阶段<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/03/jvm01.png"><br>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/03/jvm02.png"><br>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/03/jvm03.png"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p><p>运行时数据区的完整图<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/03/jvm04.png"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/03/jvm05.png"></li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。<br>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。<br>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h1 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h1><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。</p><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/10/11/jvm/jvm04/"/>
      <url>/2020/10/11/jvm/jvm04/</url>
      
        <content type="html"><![CDATA[<p>虚拟机栈</p><a id="more"></a><h1 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h1><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。<br>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？<br>首先栈是运行时的单位，而堆是存储的单位。</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/04/jvm01.png"></li></ul><h1 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h1><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><p>是线程私有的<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/04/jvm02.png"></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/09/20/jvm/jvm02/"/>
      <url>/2020/09/20/jvm/jvm02/</url>
      
        <content type="html"><![CDATA[<p>类加载子系统</p><a id="more"></a><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/虚拟机类加载机制.pdf"   title="虚拟机类加载机制"><i class="far fa-hand-point-right fa-fw"></i><span>虚拟机类加载机制</span></a><h1 id="类加载子系统概述"><a href="#类加载子系统概述" class="headerlink" title="类加载子系统概述"></a>类加载子系统概述</h1><p><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm01.png"><br>完整图如下<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm02.png"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h1 id="类加载器子系统作用"><a href="#类加载器子系统作用" class="headerlink" title="类加载器子系统作用"></a>类加载器子系统作用</h1><ul><li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm03.png"></p></li><li><p>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</p></li><li><p>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</p></li><li><p>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm04.png"></p></li></ul><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p>例如下面的一段简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloLoader &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;我已经被加载啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm05.png"><br>完整的流程图如下所示<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm06.png"></p><h1 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/类的加载过程-加载.pdf"   title="加载"><i class="far fa-hand-point-right fa-fw"></i><span>加载</span></a><ul><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul><h2 id="加载class文件的方式"><a href="#加载class文件的方式" class="headerlink" title="加载class文件的方式"></a>加载class文件的方式</h2><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h1 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h1><h2 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h2><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/类的加载过程-验证.pdf"   title="验证"><i class="far fa-hand-point-right fa-fw"></i><span>验证</span></a><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。<br>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm07.png"></p><p>如果出现不合法的字节码文件，那么将会验证不通过。<br>同时我们可以通过安装IDEA的插件，来查看我们的Class文件。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm08.png"><br>安装完成后，我们编译完一个class文件后，点击 View-Show Bytecode With Jclasslib 即可显示我们安装的插件来查看字节码方法了<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm09.png"></p><h2 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h2><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/类的加载过程-准备.pdf"   title="准备"><i class="far fa-hand-point-right fa-fw"></i><span>准备</span></a><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloApp &#123;</span><br><span class="line">    private static int a &#x3D; 1;  &#x2F;&#x2F; 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><h2 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h2><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/类的加载过程-解析.pdf"   title="解析"><i class="far fa-hand-point-right fa-fw"></i><span>解析</span></a><p>将常量池内的符号引用转换为直接引用的过程。事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。<br>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h1 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/类的加载过程-初始化.pdf"   title="初始化"><i class="far fa-hand-point-right fa-fw"></i><span>初始化</span></a><ul><li>初始化阶段就是执行类构造器法<code>&lt;clinit&gt;（）</code>的过程。</li><li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。 </li><li><code>&lt;clinit&gt;（）</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;（）</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;（）</code>执行前，父类的<code>&lt;clinit&gt;（）</code>已经执行完毕。</li></ul><p>任何一个类在声明后，内部至少存在一个类的构造器，默认是空参构造器（init）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ClassInitTest &#123;</span><br><span class="line">    private static int num &#x3D; 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        num &#x3D; 2;</span><br><span class="line">        number &#x3D; 20;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        &#x2F;&#x2F;System.out.println(number);  &#x2F;&#x2F;报错，非法的前向引用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int number &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); &#x2F;&#x2F; 2</span><br><span class="line">        System.out.println(ClassInitTest.number); &#x2F;&#x2F; 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于涉及到父类时候的变量赋值过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ClinitTest1 &#123;</span><br><span class="line">    static class Father &#123;</span><br><span class="line">        public static int A &#x3D; 1;</span><br><span class="line">        static &#123;</span><br><span class="line">            A &#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Son extends Father &#123;</span><br><span class="line">        public static int b &#x3D; A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被赋值成2，最后返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">putstatic #2 &lt;com&#x2F;atguigu&#x2F;java&#x2F;chapter02&#x2F;ClinitTest1$Father.A&gt;</span><br><span class="line">iconst_2</span><br><span class="line">putstatic #2 &lt;com&#x2F;atguigu&#x2F;java&#x2F;chapter02&#x2F;ClinitTest1$Father.A&gt;</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;（）</code>方法在多线程下被同步加锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DeadThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 线程t1开始&quot;);</span><br><span class="line">            new DeadThread();</span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 线程t2开始&quot;);</span><br><span class="line">            new DeadThread();</span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class DeadThread &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 初始化当前类&quot;);</span><br><span class="line">            while(true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程t1开始</span><br><span class="line">线程t2开始</span><br><span class="line">线程t2 初始化当前类</span><br></pre></td></tr></table></figure><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h1 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/类加载器.pdf"   title="虚拟机类加载机制"><i class="far fa-hand-point-right fa-fw"></i><span>虚拟机类加载机制</span></a><ul><li>JVM支持两种类型的类加载器,分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。 Bootstrap ClassLoader由C/C++实现的，User-Defined ClassLoader由java语言实现。<br>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<br>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm10.png"><br>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</li></ul><p>我们通过一个类，获取它不同的加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统类加载器</span><br><span class="line">        ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);&#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取其上层的：扩展类加载器</span><br><span class="line">        ClassLoader extClassLoader &#x3D; systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);&#x2F;&#x2F;sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 试图获取 根加载器,获取其上层获取不到引导类加载器 </span><br><span class="line">        ClassLoader bootstrapClassLoader &#x3D; extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);&#x2F;&#x2F;null</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取自定义加载器,对于用户自定义类来说,默认使用系统类加载器进行加载</span><br><span class="line">        ClassLoader classLoader &#x3D; ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);&#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取String类型的加载器，String是使用引导类加载器来加载的  --&gt; java的核心类库都是使用引导类加载器来加载的</span><br><span class="line">        ClassLoader classLoader1 &#x3D; String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);&#x2F;&#x2F;null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h1><h2 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h2><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h2 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h2><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h2 id="查看根加载器所能加载的目录"><a href="#查看根加载器所能加载的目录" class="headerlink" title="查看根加载器所能加载的目录"></a>查看根加载器所能加载的目录</h2><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p><p>启动类加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.security.Provider;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;*********启动类加载器************&quot;);</span><br><span class="line">        &#x2F;&#x2F; 获取BootstrapClassLoader 能够加载的API的路径</span><br><span class="line">        URL[] urls &#x3D; sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        for (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是(引导类加载器)根加载器</span><br><span class="line">        ClassLoader classLoader &#x3D; Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*********启动类加载器************</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;E:&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre&#x2F;classes</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>扩展类加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;*********扩展类加载器************&quot;);</span><br><span class="line">        String extDirs &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">        for (String path : extDirs.split(&quot;;&quot;))&#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*********扩展类加载器************</span><br><span class="line">E:\Java\jdk1.8.0_251\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure><h1 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h1><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）<br>sun.misc.Launcher 它是一个java虚拟机的入口应用<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm11.png"></p><p>获取ClassLoader的途径</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ClassLoader classLoader&#x3D; Class.forName(&quot;java.lang.String&quot;).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);&#x2F;&#x2F;null</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       ClassLoader classLoader&#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">       System.out.println(classLoader);&#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       ClassLoader classLoader&#x3D; ClassLoader.getSystemClassLoader();</span><br><span class="line">       System.out.println(classLoader);&#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/双亲委派模型.pdf"   title="双亲委派模型"><i class="far fa-hand-point-right fa-fw"></i><span>双亲委派模型</span></a><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/深入理解java虚拟机/第七章/破坏双亲委派模型.pdf"   title="破坏双亲委派模型"><i class="far fa-hand-point-right fa-fw"></i><span>破坏双亲委派模型</span></a><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm12.png"></li></ul><h2 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h2><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/02/jvm13.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h2 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h2><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ol><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h2><p>Java程序对类的使用方式分为：主动使用和被动使用。<br>主动使用，又分为七种情况：</p><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法I</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM与Java体系结构</title>
      <link href="/2020/09/19/jvm/jvm01/"/>
      <url>/2020/09/19/jvm/jvm01/</url>
      
        <content type="html"><![CDATA[<p>JVM与Java体系结构</p><a id="more"></a><h1 id="JVM内存与垃圾回收篇概述"><a href="#JVM内存与垃圾回收篇概述" class="headerlink" title="JVM内存与垃圾回收篇概述"></a>JVM内存与垃圾回收篇概述</h1><p><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-01.png"><br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-02.png"><br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-03.png"><br>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-04.png"></p><h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><ol><li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</li><li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li></ol><h1 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h1><ol><li>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li><li>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</li><li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</li></ol><h1 id="Java发展的重大事件"><a href="#Java发展的重大事件" class="headerlink" title="Java发展的重大事件"></a>Java发展的重大事件</h1><ol><li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</li><li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li><li>1996年1月23日sun Microsystems发布了JDK 1.0。</li><li>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li><li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li><li>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li><li>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li><li>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li><li>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</li><li>2007年，Java平台迎来了新伙伴Clojure。</li><li>2008年，oracle收购了BEA，得到了JRockit虚拟机。</li><li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</li><li>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</li><li>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li><li>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</li><li>同年，IBM的J9开源，形成了现在的open J9社区</li><li>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</li><li>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li><li>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</li><li>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-05.png"><br>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</li></ol><h1 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><ul><li>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</li><li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li><li>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</li></ul><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><ul><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li><li>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-06.png"></p><p>Java的体系结构<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-07.png"></p><h1 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h1><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。<br><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-08.png"><br>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</li></ul><h1 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h1><p><img src="https://cdn.lianjinquan.com/img/posts/jvm/01/jvm-09.png"><br>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p><h1 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h1><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p><h2 id="基于栈式架构的特点"><a href="#基于栈式架构的特点" class="headerlink" title="基于栈式架构的特点"></a>基于栈式架构的特点</h2><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><h2 id="基于寄存器架构的特点"><a href="#基于寄存器架构的特点" class="headerlink" title="基于寄存器架构的特点"></a>基于寄存器架构的特点</h2><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>同样执行2+3这种逻辑操作，其指令分别如下</p><ul><li>基于栈的计算流程（以Java虚拟机为例）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 &#x2F;&#x2F;常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3 &#x2F;&#x2F; 常量3入栈</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd &#x2F;&#x2F;常量2&#x2F;3出栈，执行相加</span><br><span class="line">istore_0 &#x2F;&#x2F; 结果5入栈</span><br></pre></td></tr></table></figure><ul><li>而基于寄存器的计算流程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2 &#x2F;&#x2F;将eax寄存器的值设为1</span><br><span class="line">add eax,3 &#x2F;&#x2F;使eax寄存器的值加3</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><h1 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h1><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class StackStruTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 2 + 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v StackStruTest.class</span><br></pre></td></tr></table></figure><p>得到的文件为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">   descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack&#x3D;2, locals&#x3D;4, args_size&#x3D;1</span><br><span class="line">        0: iconst_2</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: iconst_3</span><br><span class="line">        3: istore_2</span><br><span class="line">        4: iload_1</span><br><span class="line">        5: iload_2</span><br><span class="line">        6: iadd</span><br><span class="line">        7: istore_3</span><br><span class="line">        8: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 9: 0</span><br><span class="line">       line 10: 2</span><br><span class="line">       line 11: 4</span><br><span class="line">       line 12: 8</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">           2       7     1     i   I</span><br><span class="line">           4       5     2     j   I</span><br><span class="line">           8       1     3     k   I</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li>跨平台性</li><li>指令集小</li><li>指令多</li><li>执行性能比寄存器差</li></ul><h1 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h1><h2 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h2 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h2><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h2 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h2><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ul><h1 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h1><h2 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h2><ul><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在hotspot内置了此虚拟机。</li></ul><h2 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h2><ul><li>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理</li><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li><li>具备现代高性能虚拟机的维形</li><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li><li>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</li></ul><h2 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h2><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li><li>目前Hotspot占有绝对的市场地位，称霸武林。</li><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的HotSpot指的就是它的热点代码探测技术。</li><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul><h2 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h2><ul><li>专注于服务器端应用</li><li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li><li>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</li><li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li><li>优势：全面的Java运行时解决方案组合</li><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li><li>2008年，JRockit被oracle收购。</li><li>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</li></ul><h2 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h2><ul><li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li><li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</li><li>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</li><li>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</li></ul><h2 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC / CLDC Hotspot"></a>KVM和CDC / CLDC Hotspot</h2><ul><li>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</li><li>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</li><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li><li>所有的虚拟机的原则：一次编译，到处运行。</li></ul><h2 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h2><ul><li>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机</li><li>高性能Java虚拟机中的战斗机。</li><li>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</li><li>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li><li>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li></ul><h2 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h2><ul><li>高性能Java虚拟机中的战斗机。</li><li>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</li><li>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li><li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li></ul><h2 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h2><ul><li>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</li><li>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</li><li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</li></ul><h2 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h2><ul><li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</li><li>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</li><li>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</li></ul><h2 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h2><ul><li>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</li><li>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</li><li>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</li><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGc</li><li>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能，目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</li></ul><h2 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h2><ul><li>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</li><li>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</li><li>不能直接执行Java的Class文件</li><li>基于寄存器架构，不是jvm的栈架构。</li><li>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</li><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li><li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li></ul><h2 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h2><ul><li>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</li><li>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA创建第一个Spring Boot项目</title>
      <link href="/2020/09/17/springboot/springboot01/"/>
      <url>/2020/09/17/springboot/springboot01/</url>
      
        <content type="html"><![CDATA[<p>IntelliJ IDEA创建第一个Spring Boot项目</p><a id="more"></a><h3 id="IDEA创建项目"><a href="#IDEA创建项目" class="headerlink" title="IDEA创建项目"></a>IDEA创建项目</h3><p><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot01.png"><br><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot02.png"><br><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot03.png"><br><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot04.png"><br>配置maven<br><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot05.png"><br>启动项目<br><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot07.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="https://cdn.lianjinquan.com/img/posts/springboot/01/springboot08.png"></p><h3 id="启动类-DemoApplication"><a href="#启动类-DemoApplication" class="headerlink" title="启动类 DemoApplication"></a>启动类 DemoApplication</h3><p>一个带有main()方法的类，用于启动应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.quan.demo;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>Maven构建说明文件</p><ol><li>springboot父级依赖,spring-boot-starter-parent是一个特殊的starter,它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>打开 <code>E:\apache-maven-3.6.3\repository\org\springframework\boot\spring-boot-dependencies\2.3.3.RELEASE\spring-boot-dependencies-2.3.3.RELEASE.pom</code><br>可以看到springboot提供的jar包依赖，<br><a href="https://cdn.lianjinquan.com/img/posts/springboot/01/test.txt">https://cdn.lianjinquan.com/img/posts/springboot/01/test.txt</a><br>如果你不想使用某个依赖默认的版本，您还可以通过覆盖自己的项目中的属性来覆盖各个依赖项,如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;activemq.version&gt;5.7.0&lt;&#x2F;activemq.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>pom.xml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.quan&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;demo&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>一个空的properties文件，你可以根据需要添加配置属性。</p><ol><li><p>application.properties</p></li><li><p>application.yml</p></li></ol><h3 id="测试类DemoApplicationTests"><a href="#测试类DemoApplicationTests" class="headerlink" title="测试类DemoApplicationTests"></a>测试类DemoApplicationTests</h3><p>一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.quan.demo;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat的安装与配置</title>
      <link href="/2020/09/15/tomcat/TomcatInstallationAndConfiguration/"/>
      <url>/2020/09/15/tomcat/TomcatInstallationAndConfiguration/</url>
      
        <content type="html"><![CDATA[<p>Tomcat的下载，安装，配置，部署，优化</p><a id="more"></a><h3 id="jdk的环境变量配置"><a href="#jdk的环境变量配置" class="headerlink" title="jdk的环境变量配置"></a>jdk的环境变量配置</h3><p>在’系统变量’中, 新建JAVA_HOME<br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/java-home.png"><br>在PATH中添加 <code>%JAVA_HOME%\bin</code><br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/java-path.png"><br>在’系统变量’中, 新建CLASSPATH,变量值为 <code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code><br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/classpath.png"><br>测试java是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version &quot;1.8.0_261&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_261-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="Tomcat下载"><a href="#Tomcat下载" class="headerlink" title="Tomcat下载"></a>Tomcat下载</h3><p>进入tomcat官网，选择<a href="https://tomcat.apache.org/download-90.cgi">tomcat9</a>点击64-bit Windows zip (pgp, sha512)下载<br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/tomcat-download.png"><br>下载到E盘，解压<br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/tomcat9.png"></p><h3 id="Tomcat配置环境变量"><a href="#Tomcat配置环境变量" class="headerlink" title="Tomcat配置环境变量"></a>Tomcat配置环境变量</h3><p>在’系统变量’中, 新建变量名：CATALINA_HOME，变量值：E:\apache-tomcat-9.0.37<br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/tomcat-home.png"><br>在PATH中添加 <code>%CATALINA_HOME%\bin</code><br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/tomcat-path.png"></p><h3 id="启动Tomcat的2中方法"><a href="#启动Tomcat的2中方法" class="headerlink" title="启动Tomcat的2中方法"></a>启动Tomcat的2中方法</h3><ol><li>打开cmd,输入startup启动tomcat<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;startup</span><br><span class="line">Using CATALINA_BASE:   &quot;E:\apache-tomcat-9.0.37&quot;</span><br><span class="line">Using CATALINA_HOME:   &quot;E:\apache-tomcat-9.0.37&quot;</span><br><span class="line">Using CATALINA_TMPDIR: &quot;E:\apache-tomcat-9.0.37\temp&quot;</span><br><span class="line">Using JRE_HOME:        &quot;E:\java\jdk1.8.0_251&quot;</span><br><span class="line">Using CLASSPATH:       &quot;E:\apache-tomcat-9.0.37\bin\bootstrap.jar;E:\apache-tomcat-9.0.37\bin\tomcat-juli.jar&quot;</span><br></pre></td></tr></table></figure></li><li>进入E:\apache-tomcat-9.0.37\bin，双击startup.bat启动,双击shutdown.bat关闭<br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/start-tomcat.png"></li></ol><h3 id="验证是否启动成功"><a href="#验证是否启动成功" class="headerlink" title="验证是否启动成功"></a>验证是否启动成功</h3><p>在浏览器输入<a href="http://localhost:8080/">http://localhost:8080</a>  看到如下页面则启动成功<br><img src="https://cdn.lianjinquan.com/img/posts/tomcat/tomcat-startup.png"></p><h3 id="tomcat的目录结构"><a href="#tomcat的目录结构" class="headerlink" title="tomcat的目录结构"></a>tomcat的目录结构</h3><p><img src="https://cdn.lianjinquan.com/img/posts/tomcat/tomcattree.png"></p><h3 id="Tomcat部署项目的三种方法"><a href="#Tomcat部署项目的三种方法" class="headerlink" title="Tomcat部署项目的三种方法"></a>Tomcat部署项目的三种方法</h3><h3 id="启动Tomcat后乱码"><a href="#启动Tomcat后乱码" class="headerlink" title="启动Tomcat后乱码"></a>启动Tomcat后乱码</h3><p>找到打开 <code>E:\apache-tomcat-9.0.37\conf\logging.properties</code> 文件<br>把 <code>java.util.logging.ConsoleHandler.encoding = UTF-8</code> 设置为 <code>java.util.logging.ConsoleHandler.encoding = GBK</code></p><h3 id="Tomcat的默认Connector配置"><a href="#Tomcat的默认Connector配置" class="headerlink" title="Tomcat的默认Connector配置"></a>Tomcat的默认Connector配置</h3><p>打开 <code>E:\apache-tomcat-9.0.37\conf\server.xml</code> 可以看到tomcat默认端口port是8080，协议类型protocol是HTTP/1.1，连接超时时间connectionTimeout是20000毫秒，安全通信（https）转发端口redirectPort是8443</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">          connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">          redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="tomcat并发优化"><a href="#tomcat并发优化" class="headerlink" title="tomcat并发优化"></a>tomcat并发优化</h3><h3 id="tomcat内存优化"><a href="#tomcat内存优化" class="headerlink" title="tomcat内存优化"></a>tomcat内存优化</h3>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超实用的下载视频工具</title>
      <link href="/2020/09/13/python/SuperUsefulDownloadVideoTool/"/>
      <url>/2020/09/13/python/SuperUsefulDownloadVideoTool/</url>
      
        <content type="html"><![CDATA[<p>You-Get是python的一个开源库，使用you-get你只需要取得视频所在网页链接地址就可以很轻松的下载下来，目前you-get所支持的网站包含国内外几十个网站(youtube、twitter、腾讯、爱奇艺、优酷、bilibili等)，基本上可以满足你的需求。</p><a id="more"></a><h3 id="Windows安装Python"><a href="#Windows安装Python" class="headerlink" title="Windows安装Python"></a>Windows安装Python</h3><ol><li><p>进入python官网，选择<a href="https://www.python.org/downloads/">dowload</a>然后选择windows如下图<br><img src="https://cdn.lianjinquan.com/img/python/youget/download-python.png" alt="下载python"></p></li><li><p>安装Python<br><img src="https://cdn.lianjinquan.com/img/python/youget/python-1.png" alt="安装python-1"><br>请务必要勾选Add Python 3.8 to PATH，这样可以将 Python 命令工具所在目录添加到系统 Path 环境变量中，以后开发程序或者运行 Python 命令会非常方便。<br><img src="https://cdn.lianjinquan.com/img/python/youget/python-2.png" alt="安装python-2"><br>点击“Next”继续，选择安装目录。<br><img src="https://cdn.lianjinquan.com/img/python/youget/python-3.png" alt="安装python-3"><br>选择好你常用的安装目录，点击“Install”，等待几分钟就可以完成安装。</p></li><li><p>安装成功后。使用python -version检测一下，是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 3.8.5</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装You-Get"><a href="#安装You-Get" class="headerlink" title="安装You-Get"></a>安装You-Get</h3><p>打开Windows的命令提示符（win+r 输入cmd）输入一下命令安装you-get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure><h3 id="升级You-Get"><a href="#升级You-Get" class="headerlink" title="升级You-Get"></a>升级You-Get</h3><p>根据您选择安装的选项you-get，可以通过以下方式进行升级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure><h3 id="查看下载视频详情"><a href="#查看下载视频详情" class="headerlink" title="查看下载视频详情"></a>查看下载视频详情</h3><p>收到感兴趣的视频后，您可能需要使用–info/ -i选项查看所有可用的质量和格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ you-get -i https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br><span class="line">site:                Bilibili</span><br><span class="line">title:               “吔屎啦，梁非凡”非凡哥原版片段</span><br><span class="line">streams:             # Available quality and codecs</span><br><span class="line">    [ DASH ] ____________________________________</span><br><span class="line">    - format:        dash-flv480</span><br><span class="line">      container:     mp4</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          9.0 MiB (9428834 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;dash-flv480 [URL]</span><br><span class="line"></span><br><span class="line">    - format:        dash-flv360</span><br><span class="line">      container:     mp4</span><br><span class="line">      quality:       流畅 360P</span><br><span class="line">      size:          6.0 MiB (6242812 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;dash-flv360 [URL]</span><br><span class="line"></span><br><span class="line">    [ DEFAULT ] _________________________________</span><br><span class="line">    - format:        flv480</span><br><span class="line">      container:     flv</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          11.6 MiB (12194537 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;flv480 [URL]</span><br><span class="line"></span><br><span class="line">    - format:        flv360</span><br><span class="line">      container:     flv</span><br><span class="line">      quality:       流畅 360P</span><br><span class="line">      size:          7.9 MiB (8259558 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;flv360 [URL]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h3><p>标记的格式DEFAULT是您将默认获得的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ you-get https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br><span class="line">site:                Bilibili</span><br><span class="line">title:               “吔屎啦，梁非凡”非凡哥原版片段</span><br><span class="line">stream:</span><br><span class="line">    - format:        flv480</span><br><span class="line">      container:     flv</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          11.6 MiB (12194537 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;flv480 [URL]</span><br><span class="line"></span><br><span class="line">you-get: Skipping .\“吔屎啦，梁非凡”非凡哥原版片段.flv: file already exists</span><br><span class="line"></span><br><span class="line">Downloading “吔屎啦，梁非凡”非凡哥原版片段.cmt.xml ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者，如果您喜欢其他格式（mp4），则只需使用you-get显示的选项即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ you-get --format&#x3D;dash-flv480 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br><span class="line">site:                Bilibili</span><br><span class="line">title:               “吔屎啦，梁非凡”非凡哥原版片段</span><br><span class="line">stream:</span><br><span class="line">    - format:        dash-flv480</span><br><span class="line">      container:     mp4</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          9.0 MiB (9428834 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;dash-flv480 [URL]</span><br><span class="line"></span><br><span class="line">Downloading “吔屎啦，梁非凡”非凡哥原版片段.mp4 ...</span><br><span class="line"> 100% (  9.0&#x2F;  9.0MB) ├████████████████████████████████████████┤[2&#x2F;2]   12 MB&#x2F;s</span><br><span class="line"></span><br><span class="line">Downloading “吔屎啦，梁非凡”非凡哥原版片段.cmt.xml ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><ul><li>目前，我们大多数受支持的网站尚未实现格式选择；在这种情况下，默认的下载格式是质量最高的格式。</li><li>ffmpeg 是必需的依赖项，用于下载和加入分多个部分（例如，在优酷等某些网站上）流式传输的视频，以及用于1080p或高分辨率的YouTube视频。</li><li>如果您不想you-get在下载后加入视频部分，请使用–no-merge/ -n选项。</li></ul><h3 id="下载其他内容"><a href="#下载其他内容" class="headerlink" title="下载其他内容"></a>下载其他内容</h3><p>如果您已经有了想要的确切资源的URL，则可以使用以下方法直接下载它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ you-get https:&#x2F;&#x2F;cdn.lianjinquan.com&#x2F;img&#x2F;background&#x2F;2029675.jpg</span><br><span class="line">Site:       lianjinquan.com</span><br><span class="line">Title:      2029675</span><br><span class="line">Type:       JPEG Image (image&#x2F;jpeg)</span><br><span class="line">Size:       1.25 MiB (1308244 Bytes)</span><br><span class="line"></span><br><span class="line">Downloading 2029675.jpg ...</span><br><span class="line"> 100% (  1.2&#x2F;  1.2MB) ├████████████████████████████████████████┤[1&#x2F;1]   11 MB&#x2F;s</span><br></pre></td></tr></table></figure><h3 id="暂停并继续下载"><a href="#暂停并继续下载" class="headerlink" title="暂停并继续下载"></a>暂停并继续下载</h3><p>您可以使用Ctrl+C中断下载</p><h3 id="下载路径"><a href="#下载路径" class="headerlink" title="下载路径"></a>下载路径</h3><p>使用–output-dir/ -o选项设置路径，并使用–output-filename/ -O设置下载文件的名称：</p><p>下载到E盘video目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ you-get -o E:&#x2F;video https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库设计规范</title>
      <link href="/2020/09/12/mysql/MysqlDatabaseDesignSpecification/"/>
      <url>/2020/09/12/mysql/MysqlDatabaseDesignSpecification/</url>
      
        <content type="html"><![CDATA[<p>在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导开发、测试、数据库操作人员等做出适合线上业务的数据库设计和规范化操作。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范。</p><a id="more"></a><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><ol><li>【强制】数据库表结构字符集统一使用UTF8mb4。</li><li>【强制】新建表，必须显式指定主键。</li><li>【强制】不在数据库中存储图片、大文件等大数据。</li><li>【强制】所有表名、表字段必须添加注释。</li><li>【强制】无特殊需求，必须统一使用INNODB存储引擎。</li></ol><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li>【强制】数据库名、表名、字段名必须统一使用小写字母，采用26个英文字母和0-9的自然数组合，命名不能只含数字，加上下划线“_”组成，不建议加数字。</li><li>【强制】特殊情况下，需要数字与字母组合一起命名时，名称必须用英文字母开头，采用可体现业务模块含义的单词或缩写，单词中间用“_”分割，单词只能由英文字母、数字组成，不能只含数字。正例: service_level2</li><li>【强制】禁止使用大小写字母混合方式命名数据库名、表名、字段名。</li><li>【强制】数据库名、表名、字段名禁止使用拼音或夹带拼音。</li><li>【强制】数据库名、表名、字段名禁止使用MySQL保留字、关键字。</li><li>【强制】数据库名、表名、字段名的命名，英文单词组合个数不超过5个，字符数不超过32个字符，须见名知意，允许使用英文缩写。</li><li>【强制】数据库名，必须能体现业务方向或业务系统，其名称含义能达到见名知意效果。正例: vehicle_center（库名）。</li><li>【强制】 数据库表名，必须能体现业务方向或业务系统，最好是加上“业务名称_表的作用”，其名称含义简单易懂，能达到见名知意效果。正例: user_login（表名）</li><li>【强制】表字段命名应能体现被设计对象的属性含义或作用，并且需要有完整的注释说明；</li><li>【强制】数据库索引命名标准,pk主键、uk_xx唯一键、idx_xx普通索引(xx代表字段名)；idx_xx_xx复合索引(xx代表字段名);</li><li>【强制】数据库视图命名标准,v_xx(xx代表业务主体内容)；</li></ol><h3 id="表结构设计规范"><a href="#表结构设计规范" class="headerlink" title="表结构设计规范"></a>表结构设计规范</h3><ol><li>【强制】新建表时必须显式指定主键，类型为int或bigint，且为auto_increment。</li><li>【强制】创建表时必须显式指定字符集为utf8mb4。</li><li>【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律使用InnoDB。</li><li>【强制】新建表时，表里每个字段必须要有comment注释。</li><li>【强制】对已有表做表字段追加，所追加字段必须有注释说明。</li><li>【强制】表设计过程中，单表不应有过多热点字段。</li><li>【建议】核心表（如用户表，金钱相关的表）须有行数据的创建时间字段create_time和最后更新时间字段update_time。</li><li>【建议】表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值。</li><li>【建议】不建议使用text/blob，如在满足长度的情况下，建议用varchar代替text，如无法避免text、blob，应独立出来一张表。</li><li>【强制】禁止存储图片。</li><li>【强制】禁止使用外键。</li></ol><h3 id="字段类型选择与优化"><a href="#字段类型选择与优化" class="headerlink" title="字段类型选择与优化"></a>字段类型选择与优化</h3><ol><li>【强制】表中的自增列auto_increment属性，推荐使用int、bigint类型。</li><li>【强制】涉及金额、费率等字段,应统一使用decimal。</li><li>【强制】业务字段中存在状态status判断的、类型type等字段推荐使用tinytint。</li><li>【建议】业务中IP地址字段推荐使用int类型。</li><li>【建议】文本数据尽量用varchar存储,字符数不要超过2000。</li><li>【建议】时间类型尽量选取timestamp。</li><li>【强制】涉及地理位置信息,应统一使用geoetry。</li></ol><p>详细存储大小参加下图：<br> <img src="/images/mysql%E5%AD%98%E5%82%A8%E5%A4%A7%E5%B0%8F.png" alt="baidu"></p><h3 id="索引规范与设计"><a href="#索引规范与设计" class="headerlink" title="索引规范与设计"></a>索引规范与设计</h3><ol><li>【强制】InnoDB存储引擎表，索引类型必须为BTREE。</li><li>【强制】主键的名称以“pk_”开头，唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，idx_xx(普通索引),idx_xx_xx(复合索引),xx代表后缀，以字段的名称或缩写作为后缀, 命名一律使用小写格式。</li><li>【强制】索引建立的规则表应遵循列数据随机率要高于%70以上，count(distinct (column))/count(*)值越接近于1，越适合建索引，索引越高效。</li><li>【建议】在建立索引时，应多考虑建立联合索引，并把区分度最高的字段放在最前面。</li><li>【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</li><li>【强制】业务表含有唯一约束列，必须为其创建唯一键或者复合唯一键。</li><li>【建议】不要在更新频繁的列上建索引。</li><li>【建议】建表或加索引时，保证表里互相不存在重复、冗余索引。</li><li>【强制】单表不宜建过多索引，索引个数不能超过7个。</li></ol><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><ol><li>【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列。</li><li>【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</li><li>【强制】访问分区表的SQL必须包含分区键。</li><li>【强制】对于分区表执行alter table操作，必须在业务低峰期执行。</li></ol><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ol><li>【强制】数据库本身库、表、列所有字符集必须保持一致，为utf8mb4</li><li>【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为utf8或utf8mb4。</li></ol><h3 id="规范建表语句示例"><a href="#规范建表语句示例" class="headerlink" title="规范建表语句示例"></a>规范建表语句示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER (</span><br><span class="line">    &#96;id&#96; BIGINT ( 11 ) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;user_id&#96; BIGINT ( 11 ) NOT NULL COMMENT &#39;用户 id&#39;,</span><br><span class="line">    &#96;username&#96; VARCHAR ( 45 ) NOT NULL COMMENT &#39;真实姓名&#39;,</span><br><span class="line">    &#96;email&#96; VARCHAR ( 30 ) NOT NULL COMMENT &#39;用户邮箱&#39;,</span><br><span class="line">    &#96;nickname&#96; VARCHAR ( 45 ) NOT NULL COMMENT &#39;昵称&#39;,</span><br><span class="line">    &#96;avatar&#96; INT ( 11 ) NOT NULL COMMENT &#39;头像&#39;,</span><br><span class="line">    &#96;birthday&#96; date NOT NULL COMMENT &#39;生日&#39;,</span><br><span class="line">    &#96;sex&#96; TINYINT ( 4 ) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,</span><br><span class="line">    &#96;short_introduce&#96; VARCHAR ( 150 ) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,</span><br><span class="line">    &#96;user_resume&#96; VARCHAR ( 300 ) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,</span><br><span class="line">    &#96;user_register_ip&#96; INT NOT NULL COMMENT &#39;用户注册时的源 ip&#39;,</span><br><span class="line">    &#96;create_time&#96; TIMESTAMP NOT NULL COMMENT &#39;用户记录创建的时间&#39;,</span><br><span class="line">    &#96;update_time&#96; TIMESTAMP NOT NULL COMMENT &#39;用户资料修改的时间&#39;,</span><br><span class="line">    &#96;user_review_status&#96; TINYINT NOT NULL COMMENT &#39;用户资料审核状态， 1为通过，2为审核中，3为未通过，4为还未提交审核&#39;,</span><br><span class="line">    PRIMARY KEY ( &#96;id&#96; ),</span><br><span class="line">    UNIQUE KEY &#96;idx_user_id&#96; ( &#96;user_id&#96; ),</span><br><span class="line">    KEY &#96;idx_username&#96; ( &#96;username&#96; ),</span><br><span class="line">   KEY &#96;idx_create_time&#96; ( &#96;create_time&#96;, &#96;user_review_status&#96; ) </span><br><span class="line">) ENGINE &#x3D; INNODB DEFAULT CHARSET &#x3D; utf8mb4 COMMENT &#x3D; &#39;网站用户基本信息&#39;;</span><br></pre></td></tr></table></figure><h3 id="SQL使用规范"><a href="#SQL使用规范" class="headerlink" title="SQL使用规范"></a>SQL使用规范</h3><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><ol><li>【强制】SELECT语句必须指定具体字段名称，禁止写成“*”。</li><li>【强制】SELECT语句表名前必须加上库名。正例：select vin,status,manufacture_time from vcd.tm_vehicle;  vcd为库名</li><li>【强制】SELECT语句查询数据输出行数比较多的情况下，需要加limit 限制输出的行数。</li><li>【建议】SELECT语句尽量避免嵌套多个语句。</li><li>【强制】禁止在生产数据库做复杂运算。</li><li>【建议】SELECT语句避免在索引列上使用函数或计算。</li><li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</li><li>【建议】in值列表限制在500以内。正例：select… where userid in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</li><li>【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</li><li>【建议】SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找。</li><li>【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</li><li>【建议】索引列不要使用函数或表达式，否则无法利用索引。正例：where length(name)=’Admin’或where user_id+2=10023。</li><li>【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)</li><li>【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。正例：select a,b,c from t1 limit 10000,20;   优化为:Select a,b,c from t1 where id&gt;10000 limit 20;</li></ol><h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><ol><li>【建议】不建议跨db的join语句查询。</li><li>【强制】禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…</li><li>【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</li><li>【建议】线上环境，多表join不要超过5个表。</li><li>【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如“select a from db1.table1 alias1 where …”</li><li>【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</li></ol><h3 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h3><ol><li>【建议】减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b)。</li><li>【建议】包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li><li>【强制】禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK</li><li>【强制】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下。</li><li>【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库集群可扩展性。推荐都在程序端实现。</li><li>【强制】禁用insert into …on duplicate key update… 在高并发环境下，会造成主从不一致。</li><li>【强制】禁止联表更新语句，如update t1,t2 where t1.id=t2.id…</li><li>【强制】insert语句指定具体字段名称，不要写成insert into t1 values(…)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的文件权限与目录配置</title>
      <link href="/2020/08/30/linux/linux02/"/>
      <url>/2020/08/30/linux/linux02/</url>
      
        <content type="html"><![CDATA[<p>Linux最优秀的地方之一就在于他的多用户多任务环境。而为了让各个使用者具有较保密的文件数据，因此文件的权限管理就变的很重要了。<br>Linux一般将文件可存取的身份分为三个类别，分别是 owner/group/others，且三种身份各有 read/write/execute 等权限。</p><a id="more"></a><h3 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h3><ol><li>文件拥有者user  </li><li>用户组group</li><li>其他人others</li></ol><h3 id="linux文件属性"><a href="#linux文件属性" class="headerlink" title="linux文件属性"></a>linux文件属性</h3><p>若有几个文件的类型与权限如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# ls -al  </span><br><span class="line">total 48</span><br><span class="line">dr-xr-x---.  5 root root 4096 Aug 23 16:50 .</span><br><span class="line">dr-xr-xr-x. 18 root root 4096 Aug 25 21:46 ..</span><br><span class="line">-rw-------   1 root root  454 Aug 25 21:36 .bash_history</span><br><span class="line">drwx------   2 root root 4096 Aug 23 16:34 .ssh</span><br><span class="line">-rwxrwxrwx   1 root root 1864 Dec 13  2018 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><ol><li>第一栏代表这个文件的类型与权限：</li></ol><ul><li><code>d</code> 目录</li><li><code>-</code> 文件</li><li><code>l</code> 链接文件（相当于windows中的快捷键）</li><li><code>b</code> 设备文件里面的可供储存的周边设备（可随机存取设备）</li><li><code>c</code> 设备文件里面的串行端口设备设备，例如键盘、鼠标（一次性读取设备）</li></ul><p>接下来的字符中，以三个为一组，且均为“rwx” 的三个参数的组合，其中，<code>r</code>代表可读（read）、<code>w</code>代表可写（write）、<code>x</code>代表可执行（execute）,且位置不会改变，如果没有权限，就会出现减号<code>-</code> </p><ul><li>第一组为“文件拥有者可具备的权限”</li><li>第二组为“加入此群组之帐号的权限”</li><li>第三组为“非本人且没有加入本群组之其他帐号的权限”。</li></ul><ol start="2"><li>第二栏表示有多少文件名链接到此节点（i-node）</li><li>第三栏表示这个文件（或目录）的“拥有者帐号”</li><li>第四栏表示这个文件的所属群组</li><li>第五栏为这个文件的容量大小，默认单位为Bytes</li><li>第六栏为这个文件的创建日期或者是最近的修改日期</li><li>第七栏为这个文件的文件名，如果文件名之前多一个点<code>.</code>，则代表这个文件为“隐藏文件”</li></ol><h3 id="如何修改文件属性与权限"><a href="#如何修改文件属性与权限" class="headerlink" title="如何修改文件属性与权限"></a>如何修改文件属性与权限</h3><ol><li>chgrp ：改变文件所属群组</li></ol><ul><li>修改所属用户组，chgrp,这个指令就是change group的缩写,被改变的群组名称必须要在/etc/group文件内存在才行，否则就会显示错误！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[email protected] ~]# chgrp [-R] dirname&#x2F;filename ...</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。</span><br><span class="line">范例：</span><br><span class="line">[[email protected] ~]# chgrp users initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# ls -l</span><br><span class="line">-rw-r--r--. 1 root users 1864 May  4 18:01 initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# chgrp testing initial-setup-ks.cfg</span><br><span class="line">chgrp: invalid group:  &#96;testing&#39; &lt;&#x3D;&#x3D; 发生错误讯息啰～找不到这个群组名～</span><br></pre></td></tr></table></figure><ol start="2"><li>chown ：改变文件拥有者</li></ol><ul><li>修改拥有者，chown,这个指令就是change owner的缩写,使用者必须是已经存在系统中的帐号，也就是在/etc/passwd 这个文件中有纪录的使用者名称才能改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[email protected] ~]# chown [-R] 帐号名称 文件或目录</span><br><span class="line">[[email protected] ~]# chown [-R] 帐号名称:群组名称 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更</span><br><span class="line"></span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：</span><br><span class="line">[[email protected] ~]# chown bin initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# ls -l</span><br><span class="line">-rw-r--r--. 1 bin  users 1864 May  4 18:01 initial-setup-ks.cfg</span><br><span class="line"></span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者与群组改回为root：</span><br><span class="line">[[email protected] ~]# chown root:root initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# ls -l</span><br><span class="line">-rw-r--r--. 1 root root 1864 May  4 18:01 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>chmod ：改变文件的权限</li></ol><ul><li><p>数字类型，数字累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r:4</span><br><span class="line">w:2</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">语法：chomd [-R] xyz文件或目录</span><br><span class="line">-R 进行递归修改，即连同子目录下的所有文件都会被修改</span><br><span class="line"></span><br><span class="line">chmod 777 test.txt    &#x3D;&#x3D;&gt;[-rwxrwxrwx]  owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 , group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7, other &#x3D; 4+2+1 &#x3D; 7</span><br><span class="line">chmod 770 test.txt    &#x3D;&#x3D;&gt;[-rwxrwx---]  owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 , group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7, other &#x3D; 0+0+0 &#x3D; 0</span><br><span class="line">chmod 664 test.txt    &#x3D;&#x3D;&gt;[-rw-rw-r--]  owner &#x3D; rwx &#x3D; 4+2+0 &#x3D; 6 , group &#x3D; rwx &#x3D; 4+2+0 &#x3D; 6, other &#x3D; 4+0+0 &#x3D; 4</span><br><span class="line">chmod 644 test.txt    &#x3D;&#x3D;&gt;[-rw-r--r--]  owner &#x3D; rwx &#x3D; 4+2+0 &#x3D; 6 , group &#x3D; rwx &#x3D; 4+0+0 &#x3D; 4, other &#x3D; 0+0+0 &#x3D; 0</span><br><span class="line">chmod 754 test.txt    &#x3D;&#x3D;&gt;[-rwxr-xr--]  owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 , group &#x3D; rwx &#x3D; 4+0+1 &#x3D; 5, other &#x3D; 4+0+0 &#x3D; 4</span><br></pre></td></tr></table></figure></li><li><p>符号类型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u &#x3D; user 拥有者</span><br><span class="line">g &#x3D; group 用户组</span><br><span class="line">o &#x3D; other 其他人</span><br><span class="line">a &#x3D; all 全部</span><br><span class="line">+ 加入</span><br><span class="line">- 移除</span><br><span class="line">&#x3D; 设置</span><br><span class="line"></span><br><span class="line">chmod u&#x3D;rwx,go&#x3D;rx     test.txt   &#x3D;&#x3D;&gt;[-rwxr-xr-x]</span><br><span class="line">chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r  text.txt   &#x3D;&#x3D;&gt;[-rwxr-xr--]</span><br><span class="line">chmod a+w             text.txt   &#x3D;&#x3D;&gt;则[-rwxr-xr-x] 变为 [-rwxrwxrwx]</span><br><span class="line">chmod a-x             text.txt   &#x3D;&#x3D;&gt;则[-rwxr-xr-x] 变为 [-rw-rw-rw-]</span><br></pre></td></tr></table></figure><h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><p>权限对文件的重要性</p><ul><li>r(reader): 可以读取文件内容</li><li>w(writer): 可以编辑，修改，新增文件内容，但是不能删除文件</li><li>x(execute): 使该文件用于被系统执行的权限，与文件名无关（与windows的扩展名例如 .exe  .bat等根据扩展名被执行无关，只有要x权限就可以被执行）</li></ul><p>权限对目录的重要性</p><ul><li>r(reader): 读取目录列表</li><li>w(writer): 创建新的文件与目录，删除文件与目录，对文件与目录改名，移动文件与目录的位置</li><li>x(execute): 能否进入该目录</li></ul><h3 id="linux文件种类与扩展名"><a href="#linux文件种类与扩展名" class="headerlink" title="linux文件种类与扩展名"></a>linux文件种类与扩展名</h3><h3 id="linux目录配置的依据-FHS"><a href="#linux目录配置的依据-FHS" class="headerlink" title="linux目录配置的依据-FHS"></a>linux目录配置的依据-FHS</h3><h3 id="目录树（directory-tree）"><a href="#目录树（directory-tree）" class="headerlink" title="目录树（directory tree）"></a>目录树（directory tree）</h3><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令的操作</title>
      <link href="/2020/08/23/linux/linux01/"/>
      <url>/2020/08/23/linux/linux01/</url>
      
        <content type="html"><![CDATA[<p>linux基础命令的操作</p><a id="more"></a><h1 id="基础操作的指令"><a href="#基础操作的指令" class="headerlink" title="基础操作的指令"></a>基础操作的指令</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/鸟哥的linux私房菜/第四章/基础指令的操作.pdf"   title="基础指令的操作"><i class="far fa-hand-point-right fa-fw"></i><span>基础指令的操作</span></a><p>显示日期与时间的指令： date<br>显示日历的指令： cal<br>简单好用的计算机： bc</p><h1 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/鸟哥的linux私房菜/第四章/重要的几个热键.pdf"   title="重要的几个热键"><i class="far fa-hand-point-right fa-fw"></i><span>重要的几个热键</span></a><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>tab</td><td>tab接在一串命令的第一个字段后面，则为【命令补全】，tab接在一串命令的第二个字段后面，则为【文件补全】</td></tr><tr><td>ctrl+c</td><td>中断目前程序</td></tr><tr><td>ctrl+d</td><td>键盘输入结束，相当于exit</td></tr><tr><td>shift + page up</td><td>向上翻页</td></tr><tr><td>shift + page down</td><td>向下翻页</td></tr></tbody></table><h1 id="在线求助"><a href="#在线求助" class="headerlink" title="在线求助"></a>在线求助</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/鸟哥的linux私房菜/第四章/线上求助.pdf"   title="线上求助"><i class="far fa-hand-point-right fa-fw"></i><span>线上求助</span></a><p>命令的 –help 求助说明 【命令的基本用法和选项参数，例如 date –help】<br>man page 操作说明 【例如 man date】</p><p>在man page中的一些常用的按键：</p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键页</td><td>向下翻一页</td></tr><tr><td>page down</td><td>向下翻一页</td></tr><tr><td>page up</td><td>向上翻一页</td></tr><tr><td>home</td><td>去到第一页</td></tr><tr><td>end</td><td>去到最后一页</td></tr><tr><td>/string</td><td>向下查找string这个字符串，如果要查找vbird的话，就输入 /vbird</td></tr><tr><td>?string</td><td>向上查找string这个字符串</td></tr><tr><td>n,N</td><td>利用n,N来查找字符串时，可以用 n 来继续下一个查找（不论是  / 或 ?），可以用 N 来进行反向查找</td></tr><tr><td>q</td><td>结束这次man page</td></tr></tbody></table><h1 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/鸟哥的linux私房菜/第四章/正确的关机方法.pdf"   title="正确的关机方法"><i class="far fa-hand-point-right fa-fw"></i><span>正确的关机方法</span></a><p>立刻关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br></pre></td></tr></table></figure><p>系统在今天的 21:30 分会关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h 21:30</span><br></pre></td></tr></table></figure><p>系统再过十分钟后自动关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h +10</span><br></pre></td></tr></table></figure><p>系统立刻重新开机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>取消关机指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -c</span><br></pre></td></tr></table></figure><p>重新开机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>系统关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><h1 id="Linux-文件属性"><a href="#Linux-文件属性" class="headerlink" title="Linux 文件属性"></a>Linux 文件属性</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/鸟哥的linux私房菜/第四章/linux文件属性.pdf"   title="linux文件属性"><i class="far fa-hand-point-right fa-fw"></i><span>linux文件属性</span></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 238 Jun 18 17:22 test.txt</span><br></pre></td></tr></table></figure><p>文件test.txt的拥有者为root，所属群组为root。至于权限方面则只有root这个帐号可以存取此文件，其他人则仅能读此文件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-- 1 test1 testgroup 5238 Jun 19 10:25 ping_tsai</span><br></pre></td></tr></table></figure><p>文件ping_tsai的拥有者为test1，而所属群组为testgroup。其中：test1 可以针对此文件具有可读可写可执行的权力；而同群组的test2, test3两个人与test1同样是testgroup的群组帐号，则仅可读可执行但不能写（亦即不能修改）；至于没有加入testgroup这一个群组的其他人则仅可以读，不能写也不能执行！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-- 1 test1 testgroup 5238 Jun 19 10:25 groups&#x2F;</span><br></pre></td></tr></table></figure><p>文件拥有者test1[rwx]可以在本目录中进行任何工作；而testgroup这个群组[r-x]的帐号，例如test2, test3亦可以进入本目录进行工作，但是不能在本目录下进行写入的动作；至于other的权限中[r–]虽然有r ，但是由于没有x的权限，因此others的使用者，并不能进入此目录！</p><h1 id="如何改变文件属性与权限"><a href="#如何改变文件属性与权限" class="headerlink" title="如何改变文件属性与权限"></a>如何改变文件属性与权限</h1><a class="btn-beautify button--animated outline pink larger" href="https://cdn.lianjinquan.com/pdf/鸟哥的linux私房菜/第四章/如何改变文件属性与权限.pdf"   title="如何改变文件属性与权限"><i class="far fa-hand-point-right fa-fw"></i><span>如何改变文件属性与权限</span></a><p>改变文件initial-setup-ks.cfg 所属群组为users</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp users initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><p>改变文件 initial-setup-ks.cfg 的拥有者为bin用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown bin initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><p>改变文件 initial-setup-ks.cfg 的拥有者与所属群组为root<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown root:root initial-setup-ks.cfg</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
