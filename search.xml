<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>超实用的下载视频工具</title>
      <link href="/2020/09/13/python/%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84you-get%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/09/13/python/%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84you-get%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>You-Get是python的一个开源库，使用you-get你只需要取得视频所在网页链接地址就可以很轻松的下载下来，目前you-get所支持的网站包含国内外几十个网站(youtube、twitter、腾讯、爱奇艺、优酷、bilibili等)，基本上可以满足你的需求。</p><a id="more"></a><h3 id="Windows安装Python"><a href="#Windows安装Python" class="headerlink" title="Windows安装Python"></a>Windows安装Python</h3><ol><li><p>进入python官网，选择<a href="https://www.python.org/downloads/">dowload</a>然后选择windows如下图<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/%E4%B8%8B%E8%BD%BDpython.png" alt="下载python"></p></li><li><p>安装Python<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/python-1.png" alt="安装python-1"><br>请务必要勾选Add Python 3.8 to PATH，这样可以将 Python 命令工具所在目录添加到系统 Path 环境变量中，以后开发程序或者运行 Python 命令会非常方便。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/python-2.png" alt="安装python-2"><br>点击“Next”继续，选择安装目录。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/python-3.png" alt="安装python-3"><br>选择好你常用的安装目录，点击“Install”，等待几分钟就可以完成安装。</p></li><li><p>安装成功后。使用python -version检测一下，是否安装成功。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/%E6%9F%A5%E7%9C%8Bpython%E7%89%88%E6%9C%AC.png" alt="检查python版本"></p></li></ol><h3 id="安装You-Get"><a href="#安装You-Get" class="headerlink" title="安装You-Get"></a>安装You-Get</h3><p>打开Windows的命令提示符（win+r 输入cmd）输入一下命令安装you-get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/%E5%AE%89%E8%A3%85you-get.png" alt="安装you-get"></p><h3 id="升级You-Get"><a href="#升级You-Get" class="headerlink" title="升级You-Get"></a>升级You-Get</h3><p>根据您选择安装的选项you-get，可以通过以下方式进行升级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure><h3 id="查看下载视频详情"><a href="#查看下载视频详情" class="headerlink" title="查看下载视频详情"></a>查看下载视频详情</h3><p>收到感兴趣的视频后，您可能需要使用–info/ -i选项查看所有可用的质量和格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91.png" alt="下载链接"><br>查看下载视频详情<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/download2.png" alt="下载链接"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;you-get -i https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br><span class="line">site:                Bilibili</span><br><span class="line">title:               “吔屎啦，梁非凡”非凡哥原版片段</span><br><span class="line">streams:             # Available quality and codecs</span><br><span class="line">    [ DASH ] ____________________________________</span><br><span class="line">    - format:        dash-flv480</span><br><span class="line">      container:     mp4</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          9.0 MiB (9428834 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;dash-flv480 [URL]</span><br><span class="line"></span><br><span class="line">    - format:        dash-flv360</span><br><span class="line">      container:     mp4</span><br><span class="line">      quality:       流畅 360P</span><br><span class="line">      size:          6.0 MiB (6242812 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;dash-flv360 [URL]</span><br><span class="line"></span><br><span class="line">    [ DEFAULT ] _________________________________</span><br><span class="line">    - format:        flv480</span><br><span class="line">      container:     flv</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          11.6 MiB (12194537 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;flv480 [URL]</span><br><span class="line"></span><br><span class="line">    - format:        flv360</span><br><span class="line">      container:     flv</span><br><span class="line">      quality:       流畅 360P</span><br><span class="line">      size:          7.9 MiB (8259558 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;flv360 [URL]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h3><p>标记的格式DEFAULT是您将默认获得的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br></pre></td></tr></table></figure><p>或者，如果您喜欢其他格式（mp4），则只需使用you-get显示的选项即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;you-get --format&#x3D;dash-flv480 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1ix411c7mk&#x2F;?spm_id_from&#x3D;333.788.videocard.1</span><br><span class="line">site:                Bilibili</span><br><span class="line">title:               “吔屎啦，梁非凡”非凡哥原版片段</span><br><span class="line">stream:</span><br><span class="line">    - format:        dash-flv480</span><br><span class="line">      container:     mp4</span><br><span class="line">      quality:       清晰 480P</span><br><span class="line">      size:          9.0 MiB (9428834 bytes)</span><br><span class="line">    # download-with: you-get --format&#x3D;dash-flv480 [URL]</span><br><span class="line"></span><br><span class="line">Downloading “吔屎啦，梁非凡”非凡哥原版片段.mp4 ...</span><br><span class="line"> 100% (  9.0&#x2F;  9.0MB) ├████████████████████████████████████████┤[2&#x2F;2]   12 MB&#x2F;s</span><br><span class="line"></span><br><span class="line">Downloading “吔屎啦，梁非凡”非凡哥原版片段.cmt.xml ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><ul><li>目前，我们大多数受支持的网站尚未实现格式选择；在这种情况下，默认的下载格式是质量最高的格式。</li><li>ffmpeg 是必需的依赖项，用于下载和加入分多个部分（例如，在优酷等某些网站上）流式传输的视频，以及用于1080p或高分辨率的YouTube视频。</li><li>如果您不想you-get在下载后加入视频部分，请使用–no-merge/ -n选项。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="https://cdn.lianjinquan.com/img/python/youget/download3.png" alt="下载链接"></li></ul><h3 id="下载其他内容"><a href="#下载其他内容" class="headerlink" title="下载其他内容"></a>下载其他内容</h3><p>如果您已经有了想要的确切资源的URL，则可以使用以下方法直接下载它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;you-get https:&#x2F;&#x2F;cdn.lianjinquan.com&#x2F;img&#x2F;background&#x2F;2029675.jpg</span><br><span class="line">Site:       lianjinquan.com</span><br><span class="line">Title:      2029675</span><br><span class="line">Type:       JPEG Image (image&#x2F;jpeg)</span><br><span class="line">Size:       1.25 MiB (1308244 Bytes)</span><br><span class="line"></span><br><span class="line">Downloading 2029675.jpg ...</span><br><span class="line"> 100% (  1.2&#x2F;  1.2MB) ├████████████████████████████████████████┤[1&#x2F;1]   11 MB&#x2F;s</span><br></pre></td></tr></table></figure><h3 id="暂停并继续下载"><a href="#暂停并继续下载" class="headerlink" title="暂停并继续下载"></a>暂停并继续下载</h3><p>您可以使用Ctrl+C中断下载</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的文件权限与目录配置</title>
      <link href="/2020/08/30/linux/linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/08/30/linux/linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Linux最优秀的地方之一就在于他的多用户多任务环境。而为了让各个使用者具有较保密的文件数据，因此文件的权限管理就变的很重要了。<br>Linux一般将文件可存取的身份分为三个类别，分别是 owner/group/others，且三种身份各有 read/write/execute 等权限。</p><a id="more"></a><h3 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h3><ol><li><span class='p red'>文件拥有者user</span>  </li><li><span class='p yellow'>用户组group</span> </li><li><span class='p green'>其他人others</span> </li></ol><h3 id="linux文件属性"><a href="#linux文件属性" class="headerlink" title="linux文件属性"></a>linux文件属性</h3><p>若有几个文件的类型与权限如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# ls -al  </span><br><span class="line">total 48</span><br><span class="line">dr-xr-x---.  5 root root 4096 Aug 23 16:50 .</span><br><span class="line">dr-xr-xr-x. 18 root root 4096 Aug 25 21:46 ..</span><br><span class="line">-rw-------   1 root root  454 Aug 25 21:36 .bash_history</span><br><span class="line">drwx------   2 root root 4096 Aug 23 16:34 .ssh</span><br><span class="line">-rwxrwxrwx   1 root root 1864 Dec 13  2018 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><ol><li>第一栏代表这个文件的类型与权限：</li></ol><ul><li><code>d</code> 目录</li><li><code>-</code> 文件</li><li><code>l</code> 链接文件（相当于windows中的快捷键）</li><li><code>b</code> 设备文件里面的可供储存的周边设备（可随机存取设备）</li><li><code>c</code> 设备文件里面的串行端口设备设备，例如键盘、鼠标（一次性读取设备）</li></ul><p>接下来的字符中，以三个为一组，且均为“rwx” 的三个参数的组合，其中，<code>r</code>代表可读（read）、<code>w</code>代表可写（write）、<code>x</code>代表可执行（execute）,且位置不会改变，如果没有权限，就会出现减号<code>-</code> </p><ul><li>第一组为“文件拥有者可具备的权限”</li><li>第二组为“加入此群组之帐号的权限”</li><li>第三组为“非本人且没有加入本群组之其他帐号的权限”。</li></ul><ol start="2"><li>第二栏表示有多少文件名链接到此节点（i-node）</li><li>第三栏表示这个文件（或目录）的“拥有者帐号”</li><li>第四栏表示这个文件的所属群组</li><li>第五栏为这个文件的容量大小，默认单位为Bytes</li><li>第六栏为这个文件的创建日期或者是最近的修改日期</li><li>第七栏为这个文件的文件名，如果文件名之前多一个点<code>.</code>，则代表这个文件为“隐藏文件”</li></ol><h3 id="如何修改文件属性与权限"><a href="#如何修改文件属性与权限" class="headerlink" title="如何修改文件属性与权限"></a>如何修改文件属性与权限</h3><ol><li>chgrp ：改变文件所属群组</li></ol><ul><li>修改所属用户组，chgrp,这个指令就是change group的缩写,被改变的群组名称必须要在/etc/group文件内存在才行，否则就会显示错误！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[email protected] ~]# chgrp [-R] dirname&#x2F;filename ...</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。</span><br><span class="line">范例：</span><br><span class="line">[[email protected] ~]# chgrp users initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# ls -l</span><br><span class="line">-rw-r--r--. 1 root users 1864 May  4 18:01 initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# chgrp testing initial-setup-ks.cfg</span><br><span class="line">chgrp: invalid group:  &#96;testing&#39; &lt;&#x3D;&#x3D; 发生错误讯息啰～找不到这个群组名～</span><br></pre></td></tr></table></figure><ol start="2"><li>chown ：改变文件拥有者</li></ol><ul><li>修改拥有者，chown,这个指令就是change owner的缩写,使用者必须是已经存在系统中的帐号，也就是在/etc/passwd 这个文件中有纪录的使用者名称才能改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[email protected] ~]# chown [-R] 帐号名称 文件或目录</span><br><span class="line">[[email protected] ~]# chown [-R] 帐号名称:群组名称 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更</span><br><span class="line"></span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：</span><br><span class="line">[[email protected] ~]# chown bin initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# ls -l</span><br><span class="line">-rw-r--r--. 1 bin  users 1864 May  4 18:01 initial-setup-ks.cfg</span><br><span class="line"></span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者与群组改回为root：</span><br><span class="line">[[email protected] ~]# chown root:root initial-setup-ks.cfg</span><br><span class="line">[[email protected] ~]# ls -l</span><br><span class="line">-rw-r--r--. 1 root root 1864 May  4 18:01 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>chmod ：改变文件的权限</li></ol><ul><li><span class='p cyan'>数字类型</span>，数字累加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r:4</span><br><span class="line">w:2</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">语法：chomd [-R] xyz文件或目录</span><br><span class="line">-R 进行递归修改，即连同子目录下的所有文件都会被修改</span><br><span class="line"></span><br><span class="line">chmod 777 test.txt    &#x3D;&#x3D;&gt;[-rwxrwxrwx]  owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 , group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7, other &#x3D; 4+2+1 &#x3D; 7</span><br><span class="line">chmod 770 test.txt    &#x3D;&#x3D;&gt;[-rwxrwx---]  owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 , group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7, other &#x3D; 0+0+0 &#x3D; 0</span><br><span class="line">chmod 664 test.txt    &#x3D;&#x3D;&gt;[-rw-rw-r--]  owner &#x3D; rwx &#x3D; 4+2+0 &#x3D; 6 , group &#x3D; rwx &#x3D; 4+2+0 &#x3D; 6, other &#x3D; 4+0+0 &#x3D; 4</span><br><span class="line">chmod 644 test.txt    &#x3D;&#x3D;&gt;[-rw-r--r--]  owner &#x3D; rwx &#x3D; 4+2+0 &#x3D; 6 , group &#x3D; rwx &#x3D; 4+0+0 &#x3D; 4, other &#x3D; 0+0+0 &#x3D; 0</span><br><span class="line">chmod 754 test.txt    &#x3D;&#x3D;&gt;[-rwxr-xr--]  owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 , group &#x3D; rwx &#x3D; 4+0+1 &#x3D; 5, other &#x3D; 4+0+0 &#x3D; 4</span><br></pre></td></tr></table></figure></li><li><span class='p cyan'>符号类型</span></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u &#x3D; user 拥有者</span><br><span class="line">g &#x3D; group 用户组</span><br><span class="line">o &#x3D; other 其他人</span><br><span class="line">a &#x3D; all 全部</span><br><span class="line">+ 加入</span><br><span class="line">- 移除</span><br><span class="line">&#x3D; 设置</span><br><span class="line"></span><br><span class="line">chmod u&#x3D;rwx,go&#x3D;rx     test.txt   &#x3D;&#x3D;&gt;[-rwxr-xr-x]</span><br><span class="line">chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r  text.txt   &#x3D;&#x3D;&gt;[-rwxr-xr--]</span><br><span class="line">chmod a+w             text.txt   &#x3D;&#x3D;&gt;则[-rwxr-xr-x] 变为 [-rwxrwxrwx]</span><br><span class="line">chmod a-x             text.txt   &#x3D;&#x3D;&gt;则[-rwxr-xr-x] 变为 [-rw-rw-rw-]</span><br></pre></td></tr></table></figure><h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>权限对文件的重要性</p>            </div><ul><li>r(reader): 可以读取文件内容</li><li>w(writer): 可以编辑，修改，新增文件内容，但是不能删除文件</li><li>x(execute): 使该文件用于被系统执行的权限，与文件名无关（与windows的扩展名例如 .exe  .bat等根据扩展名被执行无关，只有要x权限就可以被执行）</li></ul><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>权限对目录的重要性</p>            </div><ul><li>r(reader): 读取目录列表</li><li>w(writer): 创建新的文件与目录，删除文件与目录，对文件与目录改名，移动文件与目录的位置</li><li>x(execute): 能否进入该目录</li></ul><h3 id="linux文件种类与扩展名"><a href="#linux文件种类与扩展名" class="headerlink" title="linux文件种类与扩展名"></a>linux文件种类与扩展名</h3><h3 id="linux目录配置的依据-FHS"><a href="#linux目录配置的依据-FHS" class="headerlink" title="linux目录配置的依据-FHS"></a>linux目录配置的依据-FHS</h3><h3 id="目录树（directory-tree）"><a href="#目录树（directory-tree）" class="headerlink" title="目录树（directory tree）"></a>目录树（directory tree）</h3><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2020/08/23/linux/linux/"/>
      <url>/2020/08/23/linux/linux/</url>
      
        <content type="html"><![CDATA[<p>linux基础命令的操作</p><a id="more"></a><h3 id="显示日期与时间的命令：date"><a href="#显示日期与时间的命令：date" class="headerlink" title="显示日期与时间的命令：date"></a>显示日期与时间的命令：date</h3><p>当前linux的系统时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# date</span><br><span class="line">Sun Aug 23 17:01:04 CST 2020</span><br></pre></td></tr></table></figure><p>格式化输出当前系统时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# date +%Y&#x2F;%m&#x2F;%d</span><br><span class="line">2020&#x2F;08&#x2F;23</span><br><span class="line">[root@i ~]# date +%H:%M</span><br><span class="line">17:07</span><br></pre></td></tr></table></figure><h3 id="显示日历的命令：cal"><a href="#显示日历的命令：cal" class="headerlink" title="显示日历的命令：cal"></a>显示日历的命令：cal</h3><p>语法：cal [month] [year]</p><p>显示当前月份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# cal</span><br><span class="line">     August 2020    </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">                   1</span><br><span class="line"> 2  3  4  5  6  7  8</span><br><span class="line"> 9 10 11 12 13 14 15</span><br><span class="line">16 17 18 19 20 21 22</span><br><span class="line">23 24 25 26 27 28 29</span><br><span class="line">30 31</span><br></pre></td></tr></table></figure><p>显示整年的日历2020</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# cal 2020</span><br><span class="line">                               2020                               </span><br><span class="line"></span><br><span class="line">       January               February                 March       </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">          1  2  3  4                      1    1  2  3  4  5  6  7</span><br><span class="line"> 5  6  7  8  9 10 11    2  3  4  5  6  7  8    8  9 10 11 12 13 14</span><br><span class="line">12 13 14 15 16 17 18    9 10 11 12 13 14 15   15 16 17 18 19 20 21</span><br><span class="line">19 20 21 22 23 24 25   16 17 18 19 20 21 22   22 23 24 25 26 27 28</span><br><span class="line">26 27 28 29 30 31      23 24 25 26 27 28 29   29 30 31</span><br><span class="line"></span><br><span class="line">        April                   May                   June        </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">          1  2  3  4                   1  2       1  2  3  4  5  6</span><br><span class="line"> 5  6  7  8  9 10 11    3  4  5  6  7  8  9    7  8  9 10 11 12 13</span><br><span class="line">12 13 14 15 16 17 18   10 11 12 13 14 15 16   14 15 16 17 18 19 20</span><br><span class="line">19 20 21 22 23 24 25   17 18 19 20 21 22 23   21 22 23 24 25 26 27</span><br><span class="line">26 27 28 29 30         24 25 26 27 28 29 30   28 29 30</span><br><span class="line">                       31</span><br><span class="line">        July                  August                September     </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">          1  2  3  4                      1          1  2  3  4  5</span><br><span class="line"> 5  6  7  8  9 10 11    2  3  4  5  6  7  8    6  7  8  9 10 11 12</span><br><span class="line">12 13 14 15 16 17 18    9 10 11 12 13 14 15   13 14 15 16 17 18 19</span><br><span class="line">19 20 21 22 23 24 25   16 17 18 19 20 21 22   20 21 22 23 24 25 26</span><br><span class="line">26 27 28 29 30 31      23 24 25 26 27 28 29   27 28 29 30</span><br><span class="line">                       30 31</span><br><span class="line">       October               November               December      </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">             1  2  3    1  2  3  4  5  6  7          1  2  3  4  5</span><br><span class="line"> 4  5  6  7  8  9 10    8  9 10 11 12 13 14    6  7  8  9 10 11 12</span><br><span class="line">11 12 13 14 15 16 17   15 16 17 18 19 20 21   13 14 15 16 17 18 19</span><br><span class="line">18 19 20 21 22 23 24   22 23 24 25 26 27 28   20 21 22 23 24 25 26</span><br><span class="line">25 26 27 28 29 30 31   29 30                  27 28 29 30 31</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示2020年8月的日历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# cal 8 2020</span><br><span class="line">     August 2020    </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">                   1</span><br><span class="line"> 2  3  4  5  6  7  8</span><br><span class="line"> 9 10 11 12 13 14 15</span><br><span class="line">16 17 18 19 20 21 22</span><br><span class="line">23 24 25 26 27 28 29</span><br><span class="line">30 31</span><br></pre></td></tr></table></figure><h3 id="简单好用的计算器：bc"><a href="#简单好用的计算器：bc" class="headerlink" title="简单好用的计算器：bc"></a>简单好用的计算器：bc</h3><p>在最后输入 quit 离开<br>运算符 <code>+ 加法 - 减法 * 乘法 / 除法 ^ 指数 % 余数</code><br>bc默认仅输出整数，如果要输入小数位数，则使用scale=number，number就是小数点位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type &#96;warranty&#39;. </span><br><span class="line">1+2+3+4    &lt;&#x3D;&#x3D;加法</span><br><span class="line">10</span><br><span class="line">7-8+3      </span><br><span class="line">2</span><br><span class="line">10*5</span><br><span class="line">50</span><br><span class="line">10%3      &lt;&#x3D;&#x3D;计算【余数】</span><br><span class="line">1</span><br><span class="line">10^2</span><br><span class="line">100</span><br><span class="line">10&#x2F;100    &lt;&#x3D;&#x3D;这里不是0.1吗？</span><br><span class="line">0</span><br><span class="line">scale&#x3D;3   &lt;&#x3D;&#x3D;小数点位数是3位</span><br><span class="line">1&#x2F;3</span><br><span class="line">.333</span><br><span class="line">340&#x2F;2349</span><br><span class="line">.144</span><br><span class="line">quit      &lt;&#x3D;&#x3D;离开计算器</span><br></pre></td></tr></table></figure><h3 id="几个重要的热键-tab、ctrl-c-、ctrl-d"><a href="#几个重要的热键-tab、ctrl-c-、ctrl-d" class="headerlink" title="几个重要的热键 tab、ctrl+c 、ctrl+d"></a>几个重要的热键 tab、ctrl+c 、ctrl+d</h3><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>tab</td><td>tab接在一串命令的第一个字段后面，则为【命令补全】，tab接在一串命令的第二个字段后面，则为【文件补全】</td></tr><tr><td>ctrl+c</td><td>中断目前程序</td></tr><tr><td>ctrl+d</td><td>键盘输入结束，相当于exit</td></tr><tr><td>shift + page up</td><td>向上翻页</td></tr><tr><td>shift + page down</td><td>向下翻页</td></tr></tbody></table><h3 id="linux系统的在线求助-man-page-与-info-page"><a href="#linux系统的在线求助-man-page-与-info-page" class="headerlink" title="linux系统的在线求助 man page 与 info page"></a>linux系统的在线求助 man page 与 info page</h3><p>命令的 –help 求助说明 【命令的基本用法和选项参数，例如 date –help】<br>man page 操作说明 【例如 man date】</p><p>在man page中的一些常用的按键：</p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键页</td><td>向下翻一页</td></tr><tr><td>page down</td><td>向下翻一页</td></tr><tr><td>page up</td><td>向上翻一页</td></tr><tr><td>home</td><td>去到第一页</td></tr><tr><td>end</td><td>去到最后一页</td></tr><tr><td>/string</td><td>向下查找string这个字符串，如果要查找vbird的话，就输入 /vbird</td></tr><tr><td>?string</td><td>向上查找string这个字符串</td></tr><tr><td>n,N</td><td>利用n,N来查找字符串时，可以用 n 来继续下一个查找（不论是  / 或 ?），可以用 N 来进行反向查找</td></tr><tr><td>q</td><td>结束这次man page</td></tr></tbody></table><h3 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h3><p>将数据同步写入硬盘中的指令： sync<br>惯用的关机指令： shutdown (只有root有权力)<br>重新开机，关机： reboot, halt, poweroff</p><p>shutdown [-krhc] [时间] [警告讯息]<br>选项与参数：<br>-k     ： 不要真的关机，只是发送警告讯息出去！<br>-r     ： 在将系统的服务停掉之后就重新开机（常用）<br>-h     ： 将系统的服务停掉后，立即关机。 （常用）<br>-c     ： 取消已经在进行的 shutdown 指令内容。<br>时间   ： 指定系统关机的时间！时间的范例下面会说明。若没有这个项目，则默认 1 分钟后自动进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# shutdown -h now # 立刻关机，其中 now 相当于时间为 0 的状态</span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br><span class="line"></span><br><span class="line">Disconnected from remote host(XXX.XXX.XXX.XXX) at 21:06:37.</span><br><span class="line"></span><br><span class="line">Type &#96;help&#39; to learn how to use Xshell prompt.</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -h 21:30  #系统在今天的 21:30 分会关机</span><br><span class="line">Shutdown scheduled for Tue 2020-08-25 21:30:00 CST, use &#39;shutdown -c&#39; to cancel.</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -h 21:10 #当前时间为2020-08-25 21:20 ，隔天才关机</span><br><span class="line">Shutdown scheduled for Wed 2020-08-26 21:10:00 CST, use &#39;shutdown -c&#39; to cancel.</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -h +10 #系统再过十分钟后自动关机</span><br><span class="line">Shutdown scheduled for Tue 2020-08-25 21:30:07 CST, use &#39;shutdown -c&#39; to cancel.</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -r now # 系统立刻重新开机</span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br><span class="line"></span><br><span class="line">Disconnected from remote host(XXX.XXX.XXX.XXX) at 21:24:55.</span><br><span class="line"></span><br><span class="line">Type &#96;help&#39; to learn how to use Xshell prompt.</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -r +30 &#39;The System will reboot&#39;  #再过三十分钟系统会重新开机，并显示后面的讯息给所有在线上的使用者</span><br><span class="line">Shutdown scheduled for Tue 2020-08-25 21:56:37 CST, use &#39;shutdown -c&#39; to cancel.</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -k now &#39;This system will reboot&#39; # 仅发出警告信件的参数！系统并不会关机啦！吓唬人！</span><br><span class="line"></span><br><span class="line">[root@i ~]# shutdown -c 取消关机指令</span><br><span class="line"></span><br><span class="line">Broadcast message from root@iZuf61h0akjvi2v5eh3narZ (Tue 2020-08-25 21:13:48 CST):</span><br><span class="line"></span><br><span class="line">The system shutdown has been cancelled at Tue 2020-08-25 21:14:48 CST!</span><br><span class="line"></span><br><span class="line">[root@i ~]# sync; sync; sync; reboot  # 重新开机</span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br><span class="line"></span><br><span class="line">Disconnected from remote host(XXX.XXX.XXX.XXX) at 21:34:31.</span><br><span class="line"></span><br><span class="line">Type &#96;help&#39; to learn how to use Xshell prompt.</span><br><span class="line"></span><br><span class="line">[root@i ~]# halt #系统停止～屏幕可能会保留系统已经停止的讯息！</span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br><span class="line"></span><br><span class="line">Disconnected from remote host(XXX.XXX.XXX.XXX) at 21:35:58.</span><br><span class="line"></span><br><span class="line">Type &#96;help&#39; to learn how to use Xshell prompt.</span><br><span class="line"></span><br><span class="line">[root@i ~]# poweroff  # 系统关机，所以没有提供额外的电力，屏幕空白！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux-文件属性"><a href="#Linux-文件属性" class="headerlink" title="Linux 文件属性"></a>Linux 文件属性</h3><p>在Linux系统当中， 默认的情况下， 所有的系统上的帐号与一般身份使用者， 还有那个root的相关信息， 都是记录在/etc/passwd这个文件内的。<br>个人的密码则是记录在/etc/shadow这个文件下。<br>Linux所有的群组名称都纪录在/etc/group内！</p><p>ls是“list”的意思，显示文件的文件名与相关属性。而选项“-al”则表示列出所有的文件详细的权限与属性 （包含隐藏文件，就是文件名第一个字符为“ . ”的文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@i ~]# su -  #切换root身份</span><br><span class="line">Last login: Thu Aug 27 21:36:53 CST 2020 from 58.247.180.117 on pts&#x2F;0</span><br><span class="line">[root@i ~]# ls -al  </span><br><span class="line">total 48</span><br><span class="line">dr-xr-x---.  5 root root 4096 Aug 23 16:50 .</span><br><span class="line">dr-xr-xr-x. 18 root root 4096 Aug 25 21:46 ..</span><br><span class="line">-rw-------   1 root root  454 Aug 25 21:36 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root   18 Dec 29  2013 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root  176 Dec 29  2013 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root  176 Dec 29  2013 .bashrc</span><br><span class="line">drwxr-xr-x   3 root root 4096 Nov 29  2018 .cache</span><br><span class="line">-rw-r--r--.  1 root root  100 Dec 29  2013 .cshrc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Dec 13  2018 .pip</span><br><span class="line">-rw-r--r--   1 root root  205 Aug 23 16:34 .pydistutils.cfg</span><br><span class="line">drwx------   2 root root 4096 Aug 23 16:34 .ssh</span><br><span class="line">-rw-r--r--.  1 root root  129 Dec 29  2013 .tcshrc</span><br><span class="line">-rw-------   1 root root    0 Dec 14  2018 .viminfo</span><br></pre></td></tr></table></figure><ol><li><p>第一栏代表这个文件的类型与权限（permission）<br>其中<code>-rwxrw-r--</code>共有10个字符<br>第一个字符代表这个文件是“目录、文件或链接文件等等”：<br>[ d ]是目录<br>[ - ]则是文件<br>[ l ]则表示为链接文件（link file）<br>[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）<br>[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）<br>接下来的字符中，以三个为一组，且均为“rwx” 的三个参数的组合。其中，[ r ]代表可读（read）、[ w ]代表可写（write）、[ x ]代表可执行（execute）。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>第一组为“文件拥有者可具备的权限”，<br>第二组为“加入此群组之帐号的权限”；<br>第三组为“非本人且没有加入本群组之其他帐号的权限-其他人”。</p></li><li><p>第二栏表示有多少文件名链接到此节点（i-node）</p></li><li><p>第三栏表示这个文件（或目录）的“拥有者帐号”</p></li><li><p>第四栏表示这个文件的所属群组</p></li><li><p>第五栏为这个文件的容量大小，默认单位为Bytes；</p></li><li><p>第六栏为这个文件的创建日期或者是最近的修改日期</p></li><li><p>第七栏为这个文件的文件名</p></li></ol><h3 id="如何改变文件属性与权限"><a href="#如何改变文件属性与权限" class="headerlink" title="如何改变文件属性与权限"></a>如何改变文件属性与权限</h3><p>chgrp ：改变文件所属群组<br>chown ：改变文件拥有者<br>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性</p><p>chgrp这个指令就是change group的缩写，要被改变的群组名称必须要在/etc/group文件内存在才行，否则就会显示错误！</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2020/08/22/java/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/22/java/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>java基础整理</p><a id="more"></a><h3 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h3><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p><strong>继承</strong>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p><p><strong>封装</strong>：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</p><p><strong>多态性</strong>：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。</p><ul><li>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</li></ul><ol><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ol><h3 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p><h3 id="String是最基本的数据类型吗？"><a href="#String是最基本的数据类型吗？" class="headerlink" title="String是最基本的数据类型吗？"></a>String是最基本的数据类型吗？</h3><p>不是。Java中的基本数据类型只有8个：<code>byte、short、int、long、float、double、char、boolean</code> 除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p><h3 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f=3.4;是否正确？"></a>float f=3.4;是否正确？</h3><p>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 <code>float f =(float)3.4;</code> 或者写成<code>float f =3.4F;</code>。</p><h3 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h3><p>对于<code>short s1 = 1; s1 = s1 + 1;</code>由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。<br>而<code>short s1 = 1; s1 += 1;</code>可以正确编译，因为<code>s1+= 1;</code>相当于<code>s1 = (short)(s1 + 1);</code>其中有隐含的强制类型转换。<br>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">前者有错，s1会自动提升为int类型，结果赋值给short类型，所以报错。</span><br><span class="line">后者无错，+&#x3D;这种赋值运算符隐含了强制类型转换。其实变量s1的值未被使用。</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Math.round(11.5));    &#x2F;&#x2F; 12</span><br><span class="line">        System.out.println(Math.round(-11.5));   &#x2F;&#x2F; -11</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; short s1 &#x3D; 1; </span><br><span class="line">        &#x2F;&#x2F; s1 &#x3D; s1 + 1; &#x2F;&#x2F; Type mismatch: cannot convert from int to short 类型不匹配：不能从int转换为short</span><br><span class="line"> </span><br><span class="line">        short s1 &#x3D; 1; &#x2F;&#x2F; The value of the local variable s1 is not used 局部变量s1的值未被使用 出现了警告</span><br><span class="line">        s1 +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java有没有goto？"><a href="#Java有没有goto？" class="headerlink" title="Java有没有goto？"></a>Java有没有goto？</h3><p>goto 是Java中的保留字，在目前版本的Java中没有使用。</p><h3 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h3><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始类型：boolean，char，byte，short，int，long，float，double</span><br><span class="line">包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AutoUnboxingTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a &#x3D; new Integer(3);</span><br><span class="line">        Integer b &#x3D; 3;                  &#x2F;&#x2F; 将3自动装箱成Integer类型</span><br><span class="line">        int c &#x3D; 3;</span><br><span class="line">        System.out.println(a &#x3D;&#x3D; b);     &#x2F;&#x2F; false 两个引用没有引用同一对象</span><br><span class="line">        System.out.println(a &#x3D;&#x3D; c);     &#x2F;&#x2F; true  a自动拆箱成int类型再和c比较</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer f1 &#x3D; 100, f2 &#x3D; 100, f3 &#x3D; 150, f4 &#x3D; 150;</span><br><span class="line"> </span><br><span class="line">        System.out.println(f1 &#x3D;&#x3D; f2);</span><br><span class="line">        System.out.println(f3 &#x3D;&#x3D; f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">IntegerCache是Integer的内部类，其代码如下所示：</span><br><span class="line">&#x2F;**</span><br><span class="line">     * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line">     * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line">     *</span><br><span class="line">     * The cache is initialized on first usage.  The size of the cache</span><br><span class="line">     * may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.</span><br><span class="line">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line">     * may be set and saved in the private system properties in the</span><br><span class="line">     * sun.misc.VM class.</span><br><span class="line">     *&#x2F;</span><br><span class="line"> </span><br><span class="line">    private static class IntegerCache &#123;</span><br><span class="line">        static final int low &#x3D; -128;</span><br><span class="line">        static final int high;</span><br><span class="line">        static final Integer cache[];</span><br><span class="line"> </span><br><span class="line">        static &#123;</span><br><span class="line">            &#x2F;&#x2F; high value may be configured by property</span><br><span class="line">            int h &#x3D; 127;</span><br><span class="line">            String integerCacheHighPropValue &#x3D;</span><br><span class="line">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">            if (integerCacheHighPropValue !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i &#x3D; parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i &#x3D; Math.max(i, 127);</span><br><span class="line">                    &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                    h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high &#x3D; h;</span><br><span class="line"> </span><br><span class="line">            cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">            int j &#x3D; low;</span><br><span class="line">            for(int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] &#x3D; new Integer(j++);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">            assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        private IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。</p><h3 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h3><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。<br>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。<br>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：<code>username != null &amp;&amp; !username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，<br>根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><ul><li>&amp;  只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true </li><li>&amp;&amp; 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true</li></ul><h3 id="解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h3><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p><ul><li>堆存放由new创建的对象和数组。栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等<h3 id="a-a-b与a-b有什么区别"><a href="#a-a-b与a-b有什么区别" class="headerlink" title="a=a+b与a+=b有什么区别"></a>a=a+b与a+=b有什么区别</h3></li></ul><p>+=  操作符会进行隐式自动类型转换，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte a &#x3D; 127; </span><br><span class="line">byte b &#x3D; 127; </span><br><span class="line">b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte </span><br><span class="line">b +&#x3D; a; &#x2F;&#x2F; ok</span><br></pre></td></tr></table></figure><h3 id="a-b与a-equals-b-有什么区别"><a href="#a-b与a-equals-b-有什么区别" class="headerlink" title="a==b与a.equals(b)有什么区别"></a>a==b与a.equals(b)有什么区别</h3><p>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true。<br>a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p><h3 id="3-0-1-0-3返回值是什么"><a href="#3-0-1-0-3返回值是什么" class="headerlink" title="3*0.1==0.3返回值是什么?"></a>3*0.1==0.3返回值是什么?</h3><p>false，因为有些浮点数不能完全精确的表示出来。</p><h3 id="switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？"><a href="#switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？" class="headerlink" title="switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？"></a>switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？</h3><ul><li>switch可作用于char,byte,short,int</li><li>switch可作用于char,byte,short,int对应的包装类</li><li>switch不可作用于long,double,float,boolean,包括他们的包装类</li><li>switch中可以是字符串类型，string(jdk1.7之后)</li><li>switch中可以是枚举类型(jdk1.5之后)</li></ul><h3 id="数组有没有length-方法？String有没有length-方法？"><a href="#数组有没有length-方法？String有没有length-方法？" class="headerlink" title="数组有没有length()方法？String有没有length()方法？"></a>数组有没有length()方法？String有没有length()方法？</h3><p>数组有length属性。String有length()方法。</p><h3 id="在Java中，如何跳出当前的多重嵌套循环？"><a href="#在Java中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java中，如何跳出当前的多重嵌套循环？"></a>在Java中，如何跳出当前的多重嵌套循环？</h3><p>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。</p><h3 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h3><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><p>不对，如果两个对象x和y满足<code>x.equals(y) == true</code>，它们的哈希码（hash code）相同。Java对于eqauls方法和hashCode方法是这样规定的：</p><ol><li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</li><li>如果两个对象的hashCode相同，它们并不一定相同。</li></ol><h3 id="是否可以继承String类？"><a href="#是否可以继承String类？" class="headerlink" title="是否可以继承String类？"></a>是否可以继承String类？</h3><p>String 类是final类，不可以被继承。</p><h3 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h3><p>是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用（地址值）。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p><h3 id="Object-类包含哪些方法"><a href="#Object-类包含哪些方法" class="headerlink" title="Object 类包含哪些方法"></a>Object 类包含哪些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">protected Object clone() throws CloneNotSupportedException 创建并返回此对象的副本。</span><br><span class="line">public boolean equals(Object obj)判断另一对象与此对象是否「相等」。</span><br><span class="line">protected void finalize() throws Throwable当垃圾回收机制确定该对象不再被调用时，垃圾回收器会调用此方法。</span><br><span class="line">public final Class getClass()返回此对象的运行时类。</span><br><span class="line">public int hashCode()返回此对象的散列码值。</span><br><span class="line">public String toString()返回此对象的字符串表示形式。</span><br><span class="line">public final void notify()</span><br><span class="line">public final void notifyAll()</span><br><span class="line">public final void wait()</span><br><span class="line">public final void wait(long timeout)</span><br><span class="line">public final void wait(long timeout, int nanos)</span><br></pre></td></tr></table></figure><h3 id="String和StringBuilder、StringBuffer的区别？"><a href="#String和StringBuilder、StringBuffer的区别？" class="headerlink" title="String和StringBuilder、StringBuffer的区别？"></a>String和StringBuilder、StringBuffer的区别？</h3><ul><li>String是只读字符串，所引用的字符串不能被改变，一经定义，无法再增删改。String 是字符串常量，final修饰。</li><li>String 定义的字符串保存在常量池里面，进行+操作时不能直接在原有基础上拼接。每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。</li><li>String是只读字符串，所引用的字符串不能被改变，Stringbuffer和Stringbuilder定义的可以通过各种方法来达到简单的增删改；</li><li>String和Stringbuilder在单线程环境下使用；</li><li>StringBuffer在多线程环境下使用，可以保证线程同步；</li><li>Stringbuilder 和StringBuffer 实现方法类似，均表示可变字符序列，不过StringBuffer 用synchronized关键字修饰（保证线程同步）</li><li>当需要对某一字符串大量重复+操作时：Stringbuilder 最快，不需要考虑线程同步；StringBuffer次之；String最慢，因为每次都要重新开辟内存，产生很多匿名对象，影响系统性能。</li></ul><h3 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><h3 id="char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字，为什么？"></a>char 型变量中能不能存贮一个中文汉字，为什么？</h3><p>char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p><h3 id="抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同？"></a>抽象类（abstract class）和接口（interface）有什么异同？</h3><p>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p><h3 id="静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？"><a href="#静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？"></a>静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？</h3><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的。</p><ul><li>面试题：下面的代码哪些地方会产生编译错误？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    class Inner &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    public static void foo() &#123; </span><br><span class="line">        new Inner(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void bar() &#123; </span><br><span class="line">        new Inner(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：new Outer().new Inner();</p><h3 id="Java中会存在内存泄漏吗？请简单描述。"><a href="#Java中会存在内存泄漏吗？请简单描述。" class="headerlink" title="Java中会存在内存泄漏吗？请简单描述。"></a>Java中会存在内存泄漏吗？请简单描述。</h3><p>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。</p><h3 id="抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？</h3><p>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p><h3 id="阐述静态变量和实例变量的区别。"><a href="#阐述静态变量和实例变量的区别。" class="headerlink" title="阐述静态变量和实例变量的区别。"></a>阐述静态变量和实例变量的区别。</h3><p>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><h3 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p><h3 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h3><p>有两种方式：</p><ol><li>实现Cloneable接口并重写Object类中的clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ol><h3 id="String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象？"></a>String s = new String(“xyz”);创建了几个字符串对象？</h3><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><h3 id="接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？"><a href="#接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？" class="headerlink" title="接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？"></a>接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？</h3><p>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p><h3 id="一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><p>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p><h3 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。</p><h3 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p><h3 id="Java-中的final关键字有哪些用法？"><a href="#Java-中的final关键字有哪些用法？" class="headerlink" title="Java 中的final关键字有哪些用法？"></a>Java 中的final关键字有哪些用法？</h3><ol><li>修饰类：表示该类不能被继承；</li><li>修饰方法：表示方法不能被重写；</li><li>修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</li></ol><h3 id="指出下面程序的运行结果。"><a href="#指出下面程序的运行结果。" class="headerlink" title="指出下面程序的运行结果。"></a>指出下面程序的运行结果。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.print(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B extends A &#123;</span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.print(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Hello &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A ab &#x3D; new B();</span><br><span class="line">        ab &#x3D; new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p><h3 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h3><ul><li>如何将字符串转换为基本数据类型？</li></ul><ol><li>调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本数据类型。</li></ol><ul><li>如何将基本数据类型转换为字符串？</li></ul><ol><li>  一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串。  </li></ol><h3 id="如何实现字符串的反转及替换？"><a href="#如何实现字符串的反转及替换？" class="headerlink" title="如何实现字符串的反转及替换？"></a>如何实现字符串的反转及替换？</h3><p>方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String originStr) &#123;</span><br><span class="line">        if (originStr &#x3D;&#x3D; null || originStr.length() &lt;&#x3D; 1)</span><br><span class="line">            return originStr;</span><br><span class="line">        return reverse(originStr.substring(1)) + originStr.charAt(0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;你好&quot;;</span><br><span class="line">String s2 &#x3D; new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);</span><br></pre></td></tr></table></figure><h3 id="比较一下Java和JavaSciprt。"><a href="#比较一下Java和JavaSciprt。" class="headerlink" title="比较一下Java和JavaSciprt。"></a>比较一下Java和JavaSciprt。</h3><p>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。<br>下面对两种语言间的异同作如下比较：<br>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。<br>解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）<br>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。<br>代码格式不一样。</p><h3 id="什么时候用断言（assert）？"><a href="#什么时候用断言（assert）？" class="headerlink" title="什么时候用断言（assert）？"></a>什么时候用断言（assert）？</h3><p>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。</p><h4 id="阐述final、finally、finalize的区别。"><a href="#阐述final、finally、finalize的区别。" class="headerlink" title="阐述final、finally、finalize的区别。"></a>阐述final、finally、finalize的区别。</h4><ul><li>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。</li><li>finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</li><li>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</li></ul><h3 id="类ExampleA继承Exception，类ExampleB继承ExampleA。"><a href="#类ExampleA继承Exception，类ExampleB继承ExampleA。" class="headerlink" title="类ExampleA继承Exception，类ExampleB继承ExampleA。"></a>类ExampleA继承Exception，类ExampleB继承ExampleA。</h3><p>有如下代码片断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new ExampleB(&quot;b&quot;)</span><br><span class="line">&#125; catch（ExampleA e）&#123;</span><br><span class="line">    System.out.println(&quot;ExampleA&quot;);</span><br><span class="line">&#125; catch（Exception e）&#123;</span><br><span class="line">    System.out.println(&quot;Exception&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问执行此段代码的输出是什么？  </p><p>  答：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</p><ul><li>面试题：说出下面代码的运行结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A extends Exception &#123;&#125;</span><br><span class="line">class B extends A &#123;&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                throw new B();</span><br><span class="line">            &#125; </span><br><span class="line">            catch (A a) &#123;</span><br><span class="line">                System.out.println(&quot;Caught A&quot;);</span><br><span class="line">                throw a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        catch (B b) &#123;</span><br><span class="line">            System.out.println(&quot;Caught B&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caught A</span><br><span class="line">Caught B</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h3><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</p><p>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p><h3 id="在进行数据库编程时，连接池有什么作用？"><a href="#在进行数据库编程时，连接池有什么作用？" class="headerlink" title="在进行数据库编程时，连接池有什么作用？"></a>在进行数据库编程时，连接池有什么作用？</h3><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。</p><p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。e</p><h3 id="如何保证接口的安全性"><a href="#如何保证接口的安全性" class="headerlink" title="如何保证接口的安全性"></a>如何保证接口的安全性</h3><ol><li><strong>签名</strong><br>根据用户名或者用户id或者设备号，生成一个token。在请求后台，后台获取http的head中的token，校验是否合法</li><li><strong>Token授权机制</strong><br>用户使用用户名密码登录后服务器给客户端返回一个Token（通常是UUID），并将Token-UserId以键值对的形式存放在缓存服务器中。服务端接收到请求后进行Token验证，如果Token不存在，说明请求无效。Token是客户端访问服务端的凭证。</li><li><strong>时间戳超时机制</strong><br>用户每次请求都带上当前时间的时间戳timestamp，服务端接收到timestamp后跟当前时间进行比对，如果时间差大于一定时间（比如5分钟），则认为该请求失效。时间戳超时机制是防御DOS攻击的有效手段。</li><li><strong>签名机制</strong><br>将 Token 和 时间戳 加上其他请求参数再用MD5或SHA-1算法（可根据情况加点盐）加密，加密后的数据就是本次请求的签名sign，服务端接收到请求后以同样的算法得到签名，并跟当前的签名进行比对，如果不一样，说明参数被更改过，直接返回错误标识。签名机制保证了数据不会被篡改。</li><li><strong>加密</strong><br>加密 MD5 AES 对用户与帐号密码进行加密作为一个authcode。每次请求必须携带。  </li></ol><p><strong>客户端</strong>：<br>   1、设置一个key（和服务器端相同）<br>   2、根据上述key对请求进行某种加密（加密必须是可逆的，以便服务器端解密）<br>   3、发送请求给服务器<br><strong>服务器端</strong>：<br>    1、设置一个key<br>    2、根据上述的key对请求进行解密（校验成功就是「信任」的客户端发来的数据，否则拒绝响应）<br>    3、处理业务逻辑并产生结果<br>    4、将结果反馈给客户端<br>6.    <strong>第三方支持</strong><br>   spring security－oauth</p><h3 id="简述正则表达式及其用途。"><a href="#简述正则表达式及其用途。" class="headerlink" title="简述正则表达式及其用途。"></a>简述正则表达式及其用途。</h3><p>答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><p>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。</p><h3 id="Java中是如何支持正则表达式操作的？"><a href="#Java中是如何支持正则表达式操作的？" class="headerlink" title="Java中是如何支持正则表达式操作的？"></a>Java中是如何支持正则表达式操作的？</h3><p>答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。</p><p>面试题：如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p><p>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;</p><p>class RegExpTest {</p><pre><code>public static void main(String[] args) &#123;    String str = &quot;北京市(朝阳区)(西城区)(海淀区)&quot;;    Pattern p = Pattern.compile(&quot;.*?(?=\\()&quot;);    Matcher m = p.matcher(str);    if(m.find()) &#123;        System.out.println(m.group());    &#125;&#125;</code></pre><p>}<br>说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式30分钟入门教程》。</p><h3 id="获得一个类的类对象有哪些方式？"><a href="#获得一个类的类对象有哪些方式？" class="headerlink" title="获得一个类的类对象有哪些方式？"></a>获得一个类的类对象有哪些方式？</h3><p>答：</p><p>方法1：类型.class，例如：String.class<br>方法2：对象.getClass()，例如：”hello”.getClass()<br>方法3：Class.forName()，例如：Class.forName(“java.lang.String”)<br>86、如何通过反射创建对象？<br>答：</p><p>方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()<br>方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</p><h3 id="如何通过反射调用对象的方法？"><a href="#如何通过反射调用对象的方法？" class="headerlink" title="如何通过反射调用对象的方法？"></a>如何通过反射调用对象的方法？</h3><p>答：请看下面的代码：</p><p>import java.lang.reflect.Method;</p><p>class MethodInvokeTest {</p><pre><code>public static void main(String[] args) throws Exception &#123;    String str = &quot;hello&quot;;    Method m = str.getClass().getMethod(&quot;toUpperCase&quot;);    System.out.println(m.invoke(str));  // HELLO&#125;</code></pre><p>}</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import com.jiajia.ArrayUtil.*;  &#x2F;&#x2F; 按包名导入</span><br><span class="line"></span><br><span class="line">public class BubbleSortMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;2,5,1,3,8,5,7,4,3&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line"></span><br><span class="line">        ArrayUtil.print(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - i -1; j++) &#123;   &#x2F;&#x2F; 这里说明为什么需要-1</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h3><p>系统A对系统B的接口进行多次调用所产生的结果和调用一次所产生的结果是一致的。<br>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。</p><ol><li><strong>可能出现的情况</strong><br>在增删改查4个操作中，尤为注意就是增加或者修改  </li></ol><p><strong>查询操作</strong><br>查询对于结果是不会有改变的，查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作<br><strong>删除操作</strong><br>删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个,在不考虑返回结果的情况下,删除操作也是具有幂等性的)<br><strong>更新操作</strong><br>修改在大多场景下结果一样,但是如果是增量修改是需要保证幂等性的,如下例子:<br>把表中id为XXX的记录的A字段值设置为1,这种操作不管执行多少次都是幂等的<br>把表中id为XXX的记录的A字段值增加1,这种操作就不是幂等的<br><strong>新增操作</strong><br>增加在重复提交的场景下会出现幂等性问题,如以上的支付问题<br>2. <strong>如何设计？使用token机制</strong><br>token机制实现步骤:<br>（1）生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token<br>（2）提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,页面再次提交携带的token是已删除的token后台验证会失败不让提交。<br><strong>token特点</strong>：要申请，一次有效性，可以限流。<br>注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/2020/08/21/java/%E9%9B%86%E5%90%88/"/>
      <url>/2020/08/21/java/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>java集合整理</p><a id="more"></a><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E9%9B%86%E5%90%88%E5%88%86%E7%B1%BB.png" alt="集合分类"><br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E9%9B%86%E5%90%88.png" alt="集合分类"><br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E9%9B%86%E5%90%882.png" alt="集合分类"></p><p>java 有哪些常用容器(集合)？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line"></span><br><span class="line">|　　├AbstractCollection  对Collection接口的最小化抽象实现</span><br><span class="line"></span><br><span class="line">|　　│ </span><br><span class="line"></span><br><span class="line">|　　├List  有序集合</span><br><span class="line"></span><br><span class="line">|　　│-├AbstractList  有序集合的最小化抽象实现 </span><br><span class="line"></span><br><span class="line">|　　│-├ArrayList  基于数组实现的有序集合</span><br><span class="line"></span><br><span class="line">|　　│-├LinkedList  基于链表实现的有序集合</span><br><span class="line"></span><br><span class="line">|　　│-└Vector  矢量队列</span><br><span class="line"></span><br><span class="line">|　　│　└Stack  栈，先进后出</span><br><span class="line"></span><br><span class="line">|　　│</span><br><span class="line"></span><br><span class="line">|　　├Set  不重复集合</span><br><span class="line"></span><br><span class="line">|　　│├AbstractSet  不重复集合的最小化抽象实现</span><br><span class="line"></span><br><span class="line">|　　│├HashSet  基于hash实现的不重复集合，无序</span><br><span class="line"></span><br><span class="line">|　　│├LinkedHashSet  基于hash实现的不重复集合，有序</span><br><span class="line"></span><br><span class="line">|　　│└SortedSet  可排序不重复集合</span><br><span class="line"></span><br><span class="line">|　　│   └NavigableSet  可导航搜索的不重复集合</span><br><span class="line"></span><br><span class="line">|　　│     └TreeSet  基于红黑树实现的可排序不重复集合</span><br><span class="line"></span><br><span class="line">|　　│</span><br><span class="line"></span><br><span class="line">|　　├Queue  队列</span><br><span class="line"></span><br><span class="line">|　　│├AbstractQueue  队列的核心实现</span><br><span class="line"></span><br><span class="line">|　　│├BlockingQueue  阻塞队列</span><br><span class="line"></span><br><span class="line">|　　│└Deque  可两端操作线性集合</span><br><span class="line"></span><br><span class="line">| </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Map  键值映射集合</span><br><span class="line"></span><br><span class="line">|　　├AbstractMap  键值映射集合最小化抽象实现</span><br><span class="line"></span><br><span class="line">|　　├Hashtable  基于哈希表实现的键值映射集合，key、value均不可为null</span><br><span class="line"></span><br><span class="line">|　　├HashMap  类似Hashtable，但方法不同步，key、value可为null</span><br><span class="line"></span><br><span class="line">|　　   └LinkedHashMap  根据插入顺序实现的键值映射集合</span><br><span class="line"></span><br><span class="line">|　　├IdentityHashMap  基于哈希表实现的键值映射集合，两个key引用相等&#x3D;&#x3D;，认为是同一个key</span><br><span class="line"></span><br><span class="line">|　　├SortedMap   可排序键值映射集合</span><br><span class="line"></span><br><span class="line">|　　   └NavigableMap  可导航搜索的键值映射集合</span><br><span class="line"></span><br><span class="line">|　   └WeakHashMap  弱引用建，不阻塞被垃圾回收器回收，key回收后自动移除键值对</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E9%9B%86%E5%90%883.jpg" alt="集合分类"></p><p>可以比较的点：</p><ul><li>有序、无序</li><li>可重复、不可重复</li><li>键、值是否可为null</li><li>底层实现的数据结构（数组、链表、哈希…）</li><li>线程安全性</li></ul><h3 id="ArrayList和Vector的联系和区别"><a href="#ArrayList和Vector的联系和区别" class="headerlink" title="ArrayList和Vector的联系和区别"></a>ArrayList和Vector的联系和区别</h3><p><strong>相同点：</strong></p><ul><li>底层都使用数组实现</li><li>功能相同，实现增删改查等操作的方法相似</li><li>长度可变的数组结构</li></ul><p><strong>不同点：</strong></p><ul><li>Vector是早期JDK版本提供，ArrayList是新版本替代Vector的</li><li>Vector 的方法都是同步的，线程安全；ArrayList 非线程安全，但性能比Vector好</li><li>默认初始化容量都是10，Vector 扩容默认会翻倍，可指定扩容的大小；ArrayList只增加 50%</li></ul><h3 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h3><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><h3 id="阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性。</h3><ul><li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。</li><li>LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</li><li>Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</li></ul><h3 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h3><ul><li>Collection是一个接口，它是Set、List等容器的父接口；Collection是JDK中集合层次结构中的最根本的接口。定义了集合类的基本方法。</li><li>Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。Collections是一个包装类。它包含有各种有关集合操作的静态多态方法,不能实例化，像一个Collection集合框架中的工具类。</li></ul><h3 id="List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set三个接口存取元素时，各有什么特点？"></a>List、Map、Set三个接口存取元素时，各有什么特点？</h3><ul><li>List以特定索引来存取元素，可以有重复元素。</li><li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</li><li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</li><li>Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li></ul><h3 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h3><ul><li>List：有序集合，元素可重复</li><li>Set：不重复集合，LinkedHashSet按照插入排序，SortedSet可排序，HashSet无序</li><li>Map：键值对集合，存储键、值和之间的映射；Key无序，唯一；value 不要求有序，允许重复</li></ul><h3 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h3><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li><li>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。</li></ul><h3 id="HashMap和Hashtable-有什么区别？"><a href="#HashMap和Hashtable-有什么区别？" class="headerlink" title="HashMap和Hashtable 有什么区别？"></a>HashMap和Hashtable 有什么区别？</h3><p>HashMap和Hashtable都实现了Map接口，二者保存key-value对。HashSet实现了Set接口。  </p><ol><li><strong>继承的父类不同</strong><br>Hashtable继承Dictionary类，HashMap继承AbstractMap类。但二者都实现了Map接口。</li><li><strong>线程安全性不同</strong><br>Hashtable 是线程安全的，而HashMap是线程不安全的。</li><li><strong>是否提供contains方法</strong><br>HashMap有containsValue和containsKey两个方法。<br>Hashtable有contains，containsValue，containsKey三个方法，其中contains和containsValue功能相同。</li><li><strong>key和value是否允许null值</strong><br>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br>Hashtable中，key和value都不允许出现null值。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能是该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</li><li><strong>两个遍历方式的内部实现上不同</strong><br>Hashtable、HashMap都使用了 Iterator，Hashtable还使用了Enumeration的方式 。<br>hash值不同：哈希值的使用不同，HashTable直接使用对象的hashCode。HashMap重新计算hash值。</li><li><strong>内部实现使用的数组初始化和扩容方式不同</strong><br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。<br>HashTable中hash数组默认大小是11，增加的方式是 <code>old*2+1</code>。<br>HashMap中hash数组的默认大小是16，而且一定是2的指数。</li></ol><h3 id="如何决定使用HashMap还是TreeMap？"><a href="#如何决定使用HashMap还是TreeMap？" class="headerlink" title="如何决定使用HashMap还是TreeMap？"></a>如何决定使用HashMap还是TreeMap？</h3><ul><li>HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。</li><li>HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。</li><li>HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。</li></ul><p>都是非线程安全。</p><h3 id="ArrayList和LinkedList的区别是什么？"><a href="#ArrayList和LinkedList的区别是什么？" class="headerlink" title="ArrayList和LinkedList的区别是什么？"></a>ArrayList和LinkedList的区别是什么？</h3><ul><li>ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。</li><li>对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。</li><li>新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li><li>LinkedList集合不支持 高效的随机随机访问（RandomAccess）</li><li>ArrayList的空间浪费主要体现在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</li></ul><h3 id="Array和ArrayList有何区别？"><a href="#Array和ArrayList有何区别？" class="headerlink" title="Array和ArrayList有何区别？"></a>Array和ArrayList有何区别？</h3><p> Array 即数组，声明方式可以如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] array &#x3D; new int[3];</span><br><span class="line">int array [] &#x3D; new int[3];</span><br><span class="line">int[] array &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">int[] array &#x3D; new int[]&#123;1, 2, 3&#125;;</span><br></pre></td></tr></table></figure><p> 定义一个 Array 时，必须指定数组的数据类型及数组长度，即数组中存放的元素个数固定并且类型相同。</p><p> ArrayList 是动态数组，长度动态可变，会自动扩容。不使用泛型的时候，可以添加不同类型元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list &#x3D; new ArrayList(3);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(&quot;1&quot;);</span><br><span class="line">list.add(new Double(&quot;1.1&quot;));</span><br><span class="line">list.add(&quot;第四个元素,已经超过初始长度&quot;);</span><br><span class="line">for (Object o : list) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何实现数组和List之间的转换？"><a href="#如何实现数组和List之间的转换？" class="headerlink" title="如何实现数组和List之间的转换？"></a>如何实现数组和List之间的转换？</h3><p>数组转 List ，使用 JDK 中 java.util.Arrays 工具类的 asList 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void testArray2List() &#123;</span><br><span class="line">    String[] strs &#x3D; new String[] &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(strs);</span><br><span class="line">    for (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 转数组，使用 List 的toArray方法。无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void testList2Array() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;);</span><br><span class="line">    String[] array &#x3D; list.toArray(new String[list.size()]);</span><br><span class="line">    for (String s : array) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h3><ul><li>Vector</li><li>Stack</li><li>Hashtable</li><li>java.util.concurrent 包下所有的集合类 ArrayBlockingQueue、ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque…</li></ul><h3 id="迭代器Iterator是什么？"><a href="#迭代器Iterator是什么？" class="headerlink" title="迭代器Iterator是什么？"></a>迭代器Iterator是什么？</h3><ul><li>首先说一下迭代器模式，它是 Java 中常用的设计模式之一。用于顺序访问集合对象的元素，无需知道集合对象的底层实现。</li><li>Iterator 是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。</li><li>缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加。</li></ul><h3 id="Iterator怎么使用？有什么特点？"><a href="#Iterator怎么使用？有什么特点？" class="headerlink" title="Iterator怎么使用？有什么特点？"></a>Iterator怎么使用？有什么特点？</h3><p>Iterator 接口源码中的方法</p><ul><li>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</li><li>next() 方法获得集合中的下一个元素</li><li>hasNext() 检查集合中是否还有元素</li><li>remove() 方法将迭代器新返回的元素删除</li><li>forEachRemaining(Consumer&lt;? super E&gt; action) 方法，遍历所有元素</li></ul><p>JDK 1.8 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;是否有下一个元素</span><br><span class="line">boolean hasNext();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;下一个元素</span><br><span class="line">E next();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;从迭代器指向的集合中删除迭代器返回的最后一个元素</span><br><span class="line">default void remove() &#123;</span><br><span class="line">    throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;遍历所有元素</span><br><span class="line">default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    while (hasNext())</span><br><span class="line">        action.accept(next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><p>使用 JDK中java.util.Collections 类，unmodifiable*** 方法赋值原集合。</p><p>当再修改集合时，会报错 java.lang.UnsupportedOperationException。从而确保自己定义的集合不被其他人修改。</p><h3 id="为什么基本类型不能做为HashMap的键值？"><a href="#为什么基本类型不能做为HashMap的键值？" class="headerlink" title="为什么基本类型不能做为HashMap的键值？"></a>为什么基本类型不能做为HashMap的键值？</h3><ul><li>Java中是使用泛型来约束 HashMap 中的key和value的类型的，HashMap&lt;K, V&gt;</li><li>泛型在Java的规定中必须是对象Object类型的，基本数据类型不是Object类型，不能作为键值</li><li>map.put(0, “ConstXiong”)中编译器已将 key 值 0 进行了自动装箱，变为了 Integer 类型</li></ul><h3 id="HashMap的键值需要注意什么？"><a href="#HashMap的键值需要注意什么？" class="headerlink" title="HashMap的键值需要注意什么？"></a>HashMap的键值需要注意什么？</h3><p>HashMap 的 key 相等的条件是，条件 1 必须满足，条件2和3必须满足一个。</p><ol><li>key 的 hash 值相等</li><li>内存中是同一个对象，即使用 == 判断 key 相等</li><li>key 不为 null， 且使用 equals 判断 key 相等</li></ol><p>所以自定义类作为 HashMap 的 key，需要注意按照自己的设计逻辑，重写自定义类的 hashCode() 方法和 equals() 方法。</p><h3 id="Java中已经数组类型，为什么还要提供集合？"><a href="#Java中已经数组类型，为什么还要提供集合？" class="headerlink" title="Java中已经数组类型，为什么还要提供集合？"></a>Java中已经数组类型，为什么还要提供集合？</h3><p><strong>数组的优点：</strong></p><ul><li>数组的效率高于集合类</li><li>数组能存放基本数据类型和对象；集合中只能放对象</li></ul><p><strong>数组的缺点：</strong></p><ul><li>不是面向对象的，存在明显的缺陷</li><li>数组长度固定且无法动态改变；集合类容量动态改变</li><li>数组无法判断其中实际存了多少元素，只能通过length属性获取数组的申明的长度</li><li>数组存储的特点是顺序的连续内存；集合的数据结构更丰富</li></ul><p><strong>JDK 提供集合的意义：</strong></p><ul><li>集合以类的形式存在，符合面向对象，通过简单的方法和属性调用可实现各种复杂操作</li><li>集合有多种数据结构，不同类型的集合可适用于不同场合</li><li>弥补了数组的一些缺点，比数组更灵活、实用，可开发效率.</li></ul><h3 id="TreeSet的原理是什么？使用需要注意什么？"><a href="#TreeSet的原理是什么？使用需要注意什么？" class="headerlink" title="TreeSet的原理是什么？使用需要注意什么？"></a>TreeSet的原理是什么？使用需要注意什么？</h3><p>TreeSet 基于 TreeMap 实现，TreeMap 基于红黑树实现</p><p><strong>特点：</strong></p><ul><li>有序</li><li>无重复</li><li>添加、删除元素、判断元素是否存在，效率比较高，时间复杂度为 O(log(N))</li></ul><p><strong>使用方式：</strong></p><ul><li>TreeSet 默认构造方法，调用 add() 方法时会调用对象类实现的 Comparable 接口的 compareTo() 方法和集合中的对象比较，根据方法返回的结果有序存储</li><li>TreeSet 默认构造方法，存入对象的类未实现 Comparable 接口，抛出 ClassCastException</li><li>TreeSet 支持构造方法指定 Comparator 接口，按照 Comparator 实现类的比较逻辑进行有序存储</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计规范</title>
      <link href="/2020/03/11/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2020/03/11/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>数据库设计规范</p><a id="more"></a><h3 id="规范背景与目的"><a href="#规范背景与目的" class="headerlink" title="规范背景与目的"></a>规范背景与目的</h3><p>在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导开发、测试、数据库操作人员等做出适合线上业务的数据库设计和规范化操作。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司生产业务系统的稳定、健康运行提供保障。</p><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><ol><li>【强制】数据库表结构字符集统一使用UTF8mb4。</li><li>【强制】新建表，必须显式指定主键。</li><li>【强制】不在数据库中存储图片、大文件等大数据。</li><li>【强制】所有表名、表字段必须添加注释。</li><li>【强制】无特殊需求，必须统一使用INNODB存储引擎。</li></ol><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li>【强制】数据库名、表名、字段名必须统一使用小写字母，采用26个英文字母和0-9的自然数组合，命名不能只含数字，加上下划线“_”组成，不建议加数字。</li><li>【强制】特殊情况下，需要数字与字母组合一起命名时，名称必须用英文字母开头，采用可体现业务模块含义的单词或缩写，单词中间用“_”分割，单词只能由英文字母、数字组成，不能只含数字。<br>正例: service_level2</li><li>【强制】禁止使用大小写字母混合方式命名数据库名、表名、字段名。</li><li>【强制】数据库名、表名、字段名禁止使用拼音或夹带拼音。</li><li>【强制】数据库名、表名、字段名禁止使用MySQL保留字、关键字。</li><li>【强制】数据库名、表名、字段名的命名，英文单词组合个数不超过5个，字符数不超过32个字符，须见名知意，允许使用英文缩写。</li><li>【强制】数据库名，必须能体现业务方向或业务系统，其名称含义能达到见名知意效果。<br>   正例: vehicle_center（库名）。</li><li>【强制】 数据库表名，必须能体现业务方向或业务系统，最好是加上“业务名称_表的作用”，其名称含义简单易懂，能达到见名知意效果。<br>   正例: user_login（表名）</li><li>【强制】表字段命名应能体现被设计对象的属性含义或作用，并且需要有完整的注释说明；</li><li>【强制】数据库索引命名标准,pk主键、uk_xx唯一键、idx_xx普通索引(xx代表字段名)；<pre><code>     idx_xx_xx复合索引(xx代表字段名);</code></pre></li><li>【强制】数据库视图命名标准,v_xx(xx代表业务主体内容)；</li></ol><h3 id="表结构设计规范"><a href="#表结构设计规范" class="headerlink" title="表结构设计规范"></a>表结构设计规范</h3><ol><li>【强制】新建表时必须显式指定主键，类型为int或bigint，且为auto_increment。</li><li>【强制】创建表时必须显式指定字符集为utf8mb4。</li><li>【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律使用InnoDB。</li><li>【强制】新建表时，表里每个字段必须要有comment注释。</li><li>【强制】对已有表做表字段追加，所追加字段必须有注释说明。</li><li>【强制】表设计过程中，单表不应有过多热点字段。</li><li>【建议】核心表（如用户表，金钱相关的表）须有行数据的创建时间字段create_time和最后更新时间字段update_time。</li><li>【建议】表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值。</li><li>【建议】不建议使用text/blob，如在满足长度的情况下，建议用varchar代替text，如无法避免text、blob，应独立出来一张表。</li><li>【强制】禁止存储图片。</li><li>【强制】禁止使用外键。</li></ol><h3 id="字段类型选择与优化"><a href="#字段类型选择与优化" class="headerlink" title="字段类型选择与优化"></a>字段类型选择与优化</h3><ol><li>【强制】表中的自增列auto_increment属性，推荐使用int、bigint类型。</li><li>【强制】涉及金额、费率等字段,应统一使用decimal。</li><li>【强制】业务字段中存在状态status判断的、类型type等字段推荐使用tinytint。</li><li>【建议】业务中IP地址字段推荐使用int类型。</li><li>【建议】文本数据尽量用varchar存储,字符数不要超过2000。</li><li>【建议】时间类型尽量选取timestamp。</li><li>【强制】涉及地理位置信息,应统一使用geoetry。</li></ol><p>详细存储大小参加下图：<br> <img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/mysql%E5%AD%98%E5%82%A8%E5%A4%A7%E5%B0%8F.png" alt="baidu"></p><h3 id="索引规范与设计"><a href="#索引规范与设计" class="headerlink" title="索引规范与设计"></a>索引规范与设计</h3><ol><li>【强制】InnoDB存储引擎表，索引类型必须为BTREE。</li><li>【强制】主键的名称以“pk_”开头，唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，idx_xx(普通索引),idx_xx_xx(复合索引),xx代表后缀，以字段的名称或缩写作为后缀, 命名一律使用小写格式。</li><li>【强制】索引建立的规则表应遵循列数据随机率要高于%70以上，count(distinct (column))/count(*)值越接近于1，越适合建索引，索引越高效。</li><li>【建议】在建立索引时，应多考虑建立联合索引，并把区分度最高的字段放在最前面。</li><li>【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</li><li>【强制】业务表含有唯一约束列，必须为其创建唯一键或者复合唯一键。</li><li>【建议】不要在更新频繁的列上建索引。</li><li>【建议】建表或加索引时，保证表里互相不存在重复、冗余索引。</li><li>【强制】单表不宜建过多索引，索引个数不能超过7个。<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3></li><li>【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列。</li><li>【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</li><li>【强制】访问分区表的SQL必须包含分区键。</li><li>【强制】对于分区表执行alter table操作，必须在业务低峰期执行。<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3></li><li>【强制】数据库本身库、表、列所有字符集必须保持一致，为utf8mb4</li><li>【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为utf8或utf8mb4。</li></ol><h3 id="规范建表语句示例"><a href="#规范建表语句示例" class="headerlink" title="规范建表语句示例"></a>规范建表语句示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER (</span><br><span class="line">    &#96;id&#96; BIGINT ( 11 ) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;user_id&#96; BIGINT ( 11 ) NOT NULL COMMENT &#39;用户 id&#39;,</span><br><span class="line">    &#96;username&#96; VARCHAR ( 45 ) NOT NULL COMMENT &#39;真实姓名&#39;,</span><br><span class="line">    &#96;email&#96; VARCHAR ( 30 ) NOT NULL COMMENT &#39;用户邮箱&#39;,</span><br><span class="line">    &#96;nickname&#96; VARCHAR ( 45 ) NOT NULL COMMENT &#39;昵称&#39;,</span><br><span class="line">    &#96;avatar&#96; INT ( 11 ) NOT NULL COMMENT &#39;头像&#39;,</span><br><span class="line">    &#96;birthday&#96; date NOT NULL COMMENT &#39;生日&#39;,</span><br><span class="line">    &#96;sex&#96; TINYINT ( 4 ) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,</span><br><span class="line">    &#96;short_introduce&#96; VARCHAR ( 150 ) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,</span><br><span class="line">    &#96;user_resume&#96; VARCHAR ( 300 ) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,</span><br><span class="line">    &#96;user_register_ip&#96; INT NOT NULL COMMENT &#39;用户注册时的源 ip&#39;,</span><br><span class="line">    &#96;create_time&#96; TIMESTAMP NOT NULL COMMENT &#39;用户记录创建的时间&#39;,</span><br><span class="line">    &#96;update_time&#96; TIMESTAMP NOT NULL COMMENT &#39;用户资料修改的时间&#39;,</span><br><span class="line">    &#96;user_review_status&#96; TINYINT NOT NULL COMMENT &#39;用户资料审核状态， 1为通过，2为审核中，3为未通过，4为还未提交审核&#39;,</span><br><span class="line">    PRIMARY KEY ( &#96;id&#96; ),</span><br><span class="line">    UNIQUE KEY &#96;idx_user_id&#96; ( &#96;user_id&#96; ),</span><br><span class="line">    KEY &#96;idx_username&#96; ( &#96;username&#96; ),</span><br><span class="line">   KEY &#96;idx_create_time&#96; ( &#96;create_time&#96;, &#96;user_review_status&#96; ) </span><br><span class="line">) ENGINE &#x3D; INNODB DEFAULT CHARSET &#x3D; utf8mb4 COMMENT &#x3D; &#39;网站用户基本信息&#39;;</span><br></pre></td></tr></table></figure><h3 id="SQL使用规范"><a href="#SQL使用规范" class="headerlink" title="SQL使用规范"></a>SQL使用规范</h3><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><ol><li>【强制】SELECT语句必须指定具体字段名称，禁止写成“*”。</li><li>【强制】SELECT语句表名前必须加上库名。<pre><code>  正例：select vin,status,manufacture_time from vcd.tm_vehicle;  vcd为库名</code></pre></li><li>【强制】SELECT语句查询数据输出行数比较多的情况下，需要加limit 限制输出的行数。</li><li>【建议】SELECT语句尽量避免嵌套多个语句。</li><li>【强制】禁止在生产数据库做复杂运算。</li><li>【建议】SELECT语句避免在索引列上使用函数或计算。</li><li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</li><li>【建议】in值列表限制在500以内。<pre><code>  正例：select… where userid in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</code></pre></li><li>【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</li><li>【建议】SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找。</li><li>【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</li><li>【建议】索引列不要使用函数或表达式，否则无法利用索引。<pre><code> 正例：where length(name)=’Admin’或where user_id+2=10023。</code></pre></li><li>【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)</li><li>【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。<pre><code> 正例：select a,b,c from t1 limit 10000,20;   优化为:Select a,b,c from t1 where id&gt;10000 limit 20;</code></pre></li></ol><h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><ol><li>【建议】不建议跨db的join语句查询。</li><li>【强制】禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…</li><li>【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</li><li>【建议】线上环境，多表join不要超过5个表。</li><li>【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如“select a from db1.table1 alias1 where …”</li><li>【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。<h3 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h3></li><li>【建议】减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b)。</li><li>【建议】包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li><li>2.4 线上禁止使用的SQL语句</li><li>【强制】禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。<br>因为会导致主从不一致，导致数据错乱。建议加上order by PK</li><li>【强制】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下。</li><li>【强制】禁用procedure、function、trigger、views、event、外键约束。<br>因为他们消耗数据库资源，降低数据库集群可扩展性。推荐都在程序端实现。</li><li>【强制】禁用insert into …on duplicate key update…<br>在高并发环境下，会造成主从不一致。</li><li>【强制】禁止联表更新语句，如update t1,t2 where t1.id=t2.id…</li><li>【强制】insert语句指定具体字段名称，不要写成insert into t1 values(…)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库设计规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2020/03/11/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/03/11/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>事务</p><a id="more"></a><h3 id="事物的4大特性-ACID"><a href="#事物的4大特性-ACID" class="headerlink" title="事物的4大特性(ACID)"></a>事物的4大特性(ACID)</h3><ol><li><strong>原子性</strong>  事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库产生影响；</li><li><strong>一致性</strong> 事务执行前和执行后必须处于一致性状态  </li></ol><p>例：用户A和用户B的钱加起来一共是5000; 无论AB用户之间是如何相互转换的，事务结束后两个用户的钱加起来还是5000,这就是事务的一致性。<br>3. <strong>隔离性</strong> 当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离；当多个线程都开启事务来操作数据库中的数据时，数据库系统要进行隔离操作，以保证各个线程获取数据的准确性。<br>4. <strong>持久性</strong> 一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。</p><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><ul><li>是指一个事务处理过程里读取了另一个未提交的事务中的数据，然后使用了这个数据；</li><li>一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li><li>一个事务A读取了被另一个事务B修改，但是还未提交 的数据。假如B回退，则事务A读取的是无效的数据</li><li>当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6。</li></ul><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><ul><li>不可重复读是指在一个事务内，多次读取同一个数据，在这个事务还没有结束 ，另一个事务也访问该同一数据，但是由于第二个事务的修改，那么第一个事务两次读取的数据可能不一样，因此称为不可重复读；即同一个事务中原始数据读取不可重复。这样就发生了在一个事务内两次读到的数据是不一样的 </li><li>一个事务范围内两个相同的查询却返回了不同数据</li></ul><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行修改，这种数据涉及到表中的全部数据行，同时，第二个事务也对这个表数据进行修改，这个修改是对表中新增/删除一条数据，那么操作第一个事务的用户发现表中的数据还没有修改的数据行，就好像发生了幻觉一样，这就是发生了幻读。</p><p>注:幻读和不可重复读都读取另一条已经提交的事务，所不同的是不可重复读查询的都是同一数据项，而幻读针对的是一批数据整体。</p><h5 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h5><p>一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户A把值从6改为2，用户B把值从2改为6，则用户A丢失了他的更新。</p><h3 id="事物的四种隔离级别"><a href="#事物的四种隔离级别" class="headerlink" title="事物的四种隔离级别"></a>事物的四种隔离级别</h3><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/01.png" alt="事物的四种隔离级别"><br> 由低到高分别为<code>Read uncommitted 、Read committed 、Repeatable read 、Serializable</code> 。在事务的并发操作中可能会出现脏读，不可重复读，幻读</p><ul><li><code>Read uncommitted(读未提交)</code>：最低级别，任何情况都会发生。</li><li><code>Read Committed(读已提交)</code>：可避免脏读的发生。</li><li><code>Repeatable read(可重复读)</code>：可避免脏读、不可重复读的发生。</li><li><code>Serializable(串行化)</code>：避免脏读、不可重复读，幻读的发生。<br>注： 四种隔离级别最高：Seralizable级别，最低的是Read uncommitted级别; 级别越高，执行效率就越低; 隔离级别的设置只对当前链接有效，对JDBC操作数据库来说，一个Connection对象相当于一个链接，只对该Connection对象设置的隔离级别只对该connection对象有效，与其它链接connection对象无关。</li></ul><h5 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h5><p>一个事务可以读取另一个未提交事务的数据。<br>事务A和事务B，事务A未提交的数据，事务B可以读取到，这里读到的数据可以被称为“脏读”，最低的隔离级别，这种级别一般是理论存在，数据库默认的隔离级别一般都是高于该级别的。</p><h5 id="Read-committed-读已提交"><a href="#Read-committed-读已提交" class="headerlink" title="Read committed 读已提交"></a>Read committed 读已提交</h5><p>一个事务要等另一个事务提交后才能读取数据。<br>事务A和事务B，事务A提交的数据，事务B才能读取到。这种隔离级别高于上面的读未提交，意思是：对方事务提交之后的数据，我当前事务才能够读取到。这种隔离级别可以避免脏数据，但是会导致“不可重复读”。</p><p>假设事务1读取了一条记录<code>select user_name from user where user_id = 1</code>,得到<code>user_name = &#39;456&#39;</code>,事务1暂时没提交。事务2更新了一条记录<code>update user set user_name = &#39;123&#39; where user_id = 1</code>,事务2提交。此时事务1再次<code>select user_name from user where user_id = 1</code>得到了<code>user_name = &#39;123&#39;</code>,这样就导致事务1在读取同一行数据却得到不同的user_name。这就是所谓的不可以重复读。<br>若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。</p><h5 id="Repeatable-read-可重复读"><a href="#Repeatable-read-可重复读" class="headerlink" title="Repeatable read 可重复读"></a>Repeatable read 可重复读</h5><p>在开始读取数据（事务开启）时，不再允许修改操作。</p><p>事务A和事务B，事务A提交之后的数据，事务B读取不到。事务B是可重复读取数据的，这种隔离级别高于读已提交，意思是：对方提交之后的数据我还是读取不到。这种隔离级别可以避免“不可重复读取”，达到可重复读取，但是会导致“幻读”。<br>这个跟不可重复读相反,当事务1查询到user_name=’456’时，事务2将user_name更新成’123’并提交，事务1再次查询还是会发现user_name=’456’,这样保证了可重复读。幻读的话就是当事务2插入一条新的数据id为2并提交，事务1由于可重复读的性质，只能在表中查到id为1的数据，如果此时事务1插入id为2的数据则会产生错误，因为此时表中已经有了id为2的数据,但是事务1只看到了id为1的数据。<br>重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。 </p><h5 id="Serializabale-串行化"><a href="#Serializabale-串行化" class="headerlink" title="Serializabale 串行化"></a>Serializabale 串行化</h5><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><h5 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h5><p>mysql的默认隔离级别是repeatable read。<br>oracle只支持seralizable(串行化)级别和Read committed();<br>oracle的默认隔离级别是read committed。</p><h3 id="事物的7种传播行为"><a href="#事物的7种传播行为" class="headerlink" title="事物的7种传播行为"></a>事物的7种传播行为</h3><h5 id="propagation-required"><a href="#propagation-required" class="headerlink" title="propagation_required"></a>propagation_required</h5><p>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><h5 id="propagation-supports"><a href="#propagation-supports" class="headerlink" title="propagation_supports"></a>propagation_supports</h5><p>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><h5 id="propagation-mandatory"><a href="#propagation-mandatory" class="headerlink" title="propagation_mandatory"></a>propagation_mandatory</h5><p>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><h5 id="propagation-requires-new"><a href="#propagation-requires-new" class="headerlink" title="propagation_requires_new"></a>propagation_requires_new</h5><p>创建新事务，无论当前存不存在事务，都创建新事务。</p><h5 id="propagation-not-supported"><a href="#propagation-not-supported" class="headerlink" title="propagation_not_supported"></a>propagation_not_supported</h5><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><h5 id="propagation-never"><a href="#propagation-never" class="headerlink" title="propagation_never"></a>propagation_never</h5><p>以非事务方式执行，如果当前存在事务，则抛出异常。</p><h5 id="propagation-nested"><a href="#propagation-nested" class="headerlink" title="propagation_nested"></a>propagation_nested</h5><p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2020/03/11/spring%20boot/springboot/"/>
      <url>/2020/03/11/spring%20boot/springboot/</url>
      
        <content type="html"><![CDATA[<p>springboot</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Boot不是一门新技术，从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。<br>它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。<br>使用Spring Boot很容易创建一个独立运行（运行jar,内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。</p><h3 id="四个核心"><a href="#四个核心" class="headerlink" title="四个核心"></a>四个核心</h3><ul><li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置</li><li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li><li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li><li>Actuator：让你能够深入运行中的Spring Boot应用程序，一探究竟。</li></ul><h3 id="初始化Spring-Boot项目"><a href="#初始化Spring-Boot项目" class="headerlink" title="初始化Spring Boot项目"></a>初始化Spring Boot项目</h3><ol><li>访问：<a href="http://start.spring.io/">Spring Initializer</a></li><li>通过IDEA  New &gt; Project</li></ol><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.test&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;chapter1&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;chapter1&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot父级依赖"><a href="#Spring-Boot父级依赖" class="headerlink" title="Spring Boot父级依赖"></a>Spring Boot父级依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>这块配置就是Spring Boot父级依赖，有了这个，当前的项目就是Spring Boot项目了，spring-boot-starter-parent是一个特殊的starter,它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签。<br>查看 D:\apache-maven-3.6.3\repository\org\springframework\boot\spring-boot-dependencies\2.2.0.RELEASE\spring-boot-dependencies-2.2.0.RELEASE.pom</p><p><a href="http://cdn.lianjinquan.com/spring-boot-dependencies-2.2.0.RELEASE.pom">spring-boot-dependencies-2.2.0.RELEASE.pom</a></p><p>如果你不想使用某个依赖默认的版本，您还可以通过覆盖自己的项目中的属性来覆盖各个依赖项，例如，要升级到另一个Spring Data版本系列，您可以将以下内容添加到pom.xml中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;&#x2F;spring-data-releasetrain.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>并不是每个人都喜欢继承自spring-boot-starter-parent POM。您可能有您需要使用的自己的公司标准parent，或者您可能更喜欢显式声明所有的Maven配置。如果你不想使用spring-boot-starter-parent，您仍然可以通过使用scope = import依赖关系来保持依赖关系管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">     &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;!-- Import dependency management from Spring Boot --&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>该设置不允许您使用如上所述的属性(properties)覆盖各个依赖项，要实现相同的结果，您需要在spring-boot-dependencies项之前的项目的dependencyManagement中添加一个配置，例如，要升级到另一个Spring Data版本系列，您可以将以下内容添加到pom.xml中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-releasetrain&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;Fowler-SR2&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><h3 id="起步依赖-spring-boot-starter-xx"><a href="#起步依赖-spring-boot-starter-xx" class="headerlink" title="起步依赖 spring-boot-starter-xx"></a>起步依赖 spring-boot-starter-xx</h3><p>Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。</p><h3 id="Spring-Boot-Maven插件"><a href="#Spring-Boot-Maven插件" class="headerlink" title="Spring Boot Maven插件"></a>Spring Boot Maven插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><ul><li>把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。</li><li>搜索public static void main()方法来标记为可运行类。</li></ul><h3 id="应用入口类"><a href="#应用入口类" class="headerlink" title="应用入口类"></a>应用入口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Chapter1Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Chapter1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置</li><li>main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口。</li></ul><h3 id="三种方式启动项目"><a href="#三种方式启动项目" class="headerlink" title="三种方式启动项目"></a>三种方式启动项目</h3><ol><li>Chapter1Application的main方法</li><li>使用命令 mvn spring-boot:run”在命令行启动该应用</li><li>运行“mvn package”进行打包时，会打包成一个可以直接运行的 JAR 文件，使用“java -jar”命令就可以直接运行。</li></ol><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件目录 src/main/java/resources/application.properties</p><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>在配置文件application.properties中自定义属性的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.quan.name&#x3D;&quot;今天&quot;</span><br><span class="line">com.quan.want&#x3D;&quot;天气不错&quot;</span><br></pre></td></tr></table></figure><p>然后直接在要使用的地方通过注解@Value(value=”${config.name}”)就可以绑定到你想要的属性上面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;com.quan.name&#125;&quot;)</span><br><span class="line">    private  String name;</span><br><span class="line">    @Value(&quot;$&#123;com.quan.want&#125;&quot;)</span><br><span class="line">    private  String want;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String hexo()&#123;</span><br><span class="line">        return name+&quot;,&quot;+want;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候属性太多了，一个个绑定到属性字段上太累，官方提倡绑定一个对象的bean，这里我们建一个ConfigBean.java类，顶部需要使用注解@ConfigurationProperties(prefix = “com.quan”)来指明使用哪个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;com.quan&quot;)</span><br><span class="line">public class ConfigBean &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String want;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置完还需要在spring Boot入口类加上@EnableConfigurationProperties并指明要加载哪个bean，如果不写ConfigBean.class，在bean类那边添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)</span><br><span class="line">public class Chapter2Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Chapter2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在Controller中引入ConfigBean使用即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigBean configBean;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String hexo()&#123;</span><br><span class="line">        return configBean.getName()+configBean.getWant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数间引用"><a href="#参数间引用" class="headerlink" title="参数间引用"></a>参数间引用</h3><p>在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置，这样我们就可以只是用yearhope这个属性就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.quan.name&#x3D;&quot;今天&quot;</span><br><span class="line">com.quan.want&#x3D;&quot;天气不错&quot;</span><br><span class="line">com.quan.yearhope&#x3D;$&#123;com.quan.name&#125;的$&#123;com.quan.want&#125;</span><br></pre></td></tr></table></figure><h3 id="使用自定义配置文件"><a href="#使用自定义配置文件" class="headerlink" title="使用自定义配置文件"></a>使用自定义配置文件</h3><p>有时候我们不希望把所有配置都放在application.properties里面，这时候我们可以另外定义一个，这里取名为test.properties,路径跟也放在src/main/resources下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.md.name&#x3D;&quot;哟西~&quot;</span><br><span class="line">com.md.want&#x3D;&quot;祝大家鸡年,大吉吧&quot;</span><br></pre></td></tr></table></figure><p>我们新建一个bean类,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;com.md&quot;) </span><br><span class="line">@PropertySource(&quot;classpath:test.properties&quot;)</span><br><span class="line">public class ConfigTestBean &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String want;</span><br><span class="line">    &#x2F;&#x2F; 省略getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意哦，有一个问题，如果你使用的是1.5以前的版本，那么可以通过locations指定properties文件的位置，这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;config2&quot;,locations&#x3D;&quot;classpath:test.properties&quot;)</span><br></pre></td></tr></table></figure><p>但是1.5版本后就没有这个属性了，要添加@Configuration和@PropertySource(“classpath:test.properties”)后才可以读取。</p><h3 id="随机值配置"><a href="#随机值配置" class="headerlink" title="随机值配置"></a>随机值配置</h3><p>配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">com.test.secret&#x3D;$&#123;random.value&#125;</span><br><span class="line">com.test.number&#x3D;$&#123;random.int&#125;</span><br><span class="line">com.test.bignumber&#x3D;$&#123;random.long&#125;</span><br><span class="line">com.test.uuid&#x3D;$&#123;random.uuid&#125;</span><br><span class="line">com.test.number.less.than.ten&#x3D;$&#123;random.int(10)&#125;</span><br><span class="line">com.test.number.in.range&#x3D;$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><h3 id="外部配置-命令行参数配置"><a href="#外部配置-命令行参数配置" class="headerlink" title="外部配置-命令行参数配置"></a>外部配置-命令行参数配置</h3><p>Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行：</p><p><code>java -jar xx.jar</code></p><p>可以以下命令修改tomcat端口号：</p><p><code>java -jar xx.jar --server.port=9090</code></p><p>可以看出，命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。<br>所以java -jar xx.jar –server.port=9090等价于在application.properties中添加属性server.port=9090。<br>如果你怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。</p><p>实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种：</p><ul><li>根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。</li><li>测试中的@TestPropertySource注解。</li><li>测试中的@SpringBootTest#properties注解特性。</li><li>命令行参数</li><li>SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。</li><li>ServletConfig初始化参数。</li><li>ServletContext初始化参数。</li><li>java:comp/env里的JNDI属性</li><li>JVM系统属性</li><li>操作系统环境变量</li><li>随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}）</li><li>应用程序以外的application.properties或者appliaction.yml文件</li><li>打包在应用程序内的application.properties或者appliaction.yml文件</li><li>通过@PropertySource标注的属性源</li><li>默认属性(通过SpringApplication.setDefaultProperties指定).</li><li>这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，列如我们上面提到的命令行属性就覆盖了application.properties的属性。</li></ul><h3 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h3><p>application.properties和application.yml文件可以放在以下四个位置：</p><ol><li>外置，在相对于应用程序运行目录的/congfig子目录里。</li><li>外置，在应用程序运行的目录里</li><li>内置，在config包内</li><li>内置，在Classpath根目录</li></ol><p>同样，这个列表按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图：<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="集合分类"></p><p>此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.properties里的属性就会覆盖application.yml。</p><h3 id="Profile-多环境配置"><a href="#Profile-多环境配置" class="headerlink" title="Profile-多环境配置"></a>Profile-多环境配置</h3><p>当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。<br>如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。</p><p>这里我们来模拟一下，只是简单的修改端口来测试<br>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如：</p><ul><li>application-dev.properties：开发环境</li><li>application-test.properties：测试环境</li><li>application-prod.properties：生产环境<br>想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod、test这3个。<br>当然你也可以用命令行启动的时候带上参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active&#x3D;dev</span><br></pre></td></tr></table></figure>我给不同的环境添加不同的端口属性server.port，然后根据指定不同的spring.profiles.active来切换使用。</li></ul><p>除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，我们还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public  interface DBConnector &#123; public  void  configure(); &#125;</span><br></pre></td></tr></table></figure><p>分别定义俩个实现类来实现它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 测试数据库</span><br><span class="line">  *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Profile(&quot;testdb&quot;)</span><br><span class="line">public class TestDBConnector implements DBConnector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure() &#123;</span><br><span class="line">        System.out.println(&quot;testdb&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 生产数据库</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Profile(&quot;devdb&quot;)</span><br><span class="line">public class DevDBConnector implements DBConnector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure() &#123;</span><br><span class="line">        System.out.println(&quot;devdb&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在配置文件激活具体使用哪个实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active&#x3D;testdb</span><br></pre></td></tr></table></figure><p>然后就可以这么用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;task&quot;)</span><br><span class="line">public class TaskController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired </span><br><span class="line">    DBConnector connector ;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &#123;&quot;&#x2F;&quot;,&quot;&quot;&#125;)</span><br><span class="line">    public String hellTask()&#123;</span><br><span class="line"></span><br><span class="line">        connector.configure(); &#x2F;&#x2F;最终打印testdb     </span><br><span class="line">        return &quot;hello task !! myage is &quot; + myage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active: testdb  </span><br><span class="line">spring.profiles.include: proddb,prodmq</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2020/03/11/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/03/11/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>线程池</p><a id="more"></a><h3 id="线程池（thread-pool）"><a href="#线程池（thread-pool）" class="headerlink" title="线程池（thread pool）"></a>线程池（thread pool）</h3><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="RDB 持久化"></p><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>最顶层接口Executor，只能提交Runnable形式的任务，不支持提交Callable带有返回值的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   package java.util.concurrent;</span><br><span class="line">   public interface Executor &#123;</span><br><span class="line">      void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors是一个工厂类，主要用来创建ExecutorService，ScheduledExecutorService等线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Executors &#123;</span><br></pre></td></tr></table></figure><p>调用时例如： <code>Executors.newFixedThreadPool(int nThreads)</code></p><ul><li><strong>corePoolSize</strong>：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li><li><strong>maximunPoolSize</strong>：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建新的线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li><li><strong>keepAliveTime</strong>：非核心线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li><li><strong>unit</strong>：时间单位，和keepAliveTime配合使用。</li><li><strong>workQueue</strong>：缓存队列，用来存放等待被执行的任务。</li><li><strong>threadFactory</strong>：线程工厂，用来创建线程，一般有三种选择策略。</li></ul><ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>SynchronousQueue</li></ol><ul><li><strong>handler</strong>：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种策略为</li></ul><ol><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </li><li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0.png" alt="线程池参数"></li></ol><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>线程池的核心类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br></pre></td></tr></table></figure><p>线程池的核心类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong>：线程池的核心线程数目，当一个请求进来时如果当前线程池中线程数量小于这个值，则直接通过ThreadFactory新建一个线程来处理这个请求，如果已有线程数量大于等于这个值则将请求放入阻塞队列中。</li><li><strong>maximumPoolSize</strong>：线程池的最大线程数目，当线程池数量已经等于corePoolSize并且阻塞队列也已经满了，则看线程数量是否小于maximumPoolSize：如果小于则创建一个线程来处理请求，否则使用“饱和策略”来拒绝这个请求。对于大于corePoolSize部分的线程，称作这部分线程为“idle threads”，这部分线程会有一个最大空闲时间，如果超过这个空闲时间还没有任务进来则将这些空闲线程回收。</li><li><strong>keepAliveTime</strong>和<strong>unit</strong>：这两个参数主要用来控制idle threads的最大空闲时间，超过这个空闲时间空闲线程将被回收。这里有一点需要注意，ThreadPoolExecutor中有一个属性:private volatile boolean allowCoreThreadTimeOut;，这个用来指定是否允许核心线程空闲超时回收，默认为false，即不允许核心线程超时回收，核心线程将一直等待新任务。如果设置这个参数为true，核心线程空闲超时后也可以被回收。</li><li><strong>workQueue</strong>：阻塞队列，超过corePoolSize部分的请求放入这个阻塞队列中等待执行。阻塞队列分为有界阻塞队列和无界阻塞队列。在创建阻塞队列时如果我们指定了这个队列的“capacity”则这个队列就是有界的，否则是无界的。这里有一点需要注意：使用线程池之前请明确是否真的需要无界阻塞队列，如果阻塞队列是无界的，会导致大量的请求堆积，进而造成内存溢出系统崩溃。</li><li><strong>threadFactory</strong>：是一个线程池工厂，主要用来为线程池创建线程，我们可以定制一个ThreadFactory来达到统一命名我们线程池中的线程的目的。<br>handler：饱和策略，用来拒绝多余的请求。饱和策略有：CallerRunsPolicy：请求脱离线程池运行（调用者caller线程来运行这个任务）；AbortPolicy：抛出RejectedExecutionException异常；DiscardPolicy：丢弃这个任务，即什么也不做；DiscardOldestPolicy：将阻塞队列中等待时间最久的任务删除（即队列头部的任务），将新的任务加入队尾。</li></ul><ol><li>创建固定大小的线程池（创建一个定长线程池）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建只有一个线程的线程池（创建一个单线程化的线程池）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（创建一个可缓存线程池）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE   java int 类整数的最大值是 2 的 31 次方 - 1 &#x3D; 2147483648 - 1 &#x3D; 2147483647</span><br><span class="line">@Native public static final int   MAX_VALUE &#x3D; 0x7fffffff;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建一个定长线程池</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F.png" alt="线程池参数"></p><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p><p>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors里面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><ul><li><code>newSingleThreadExecutor</code>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li><code>newFixedThreadPool</code>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li><code>newCachedThreadPool</code>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li><li><code>newScheduledThreadPool</code>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li><li><code>newSingleThreadExecutor</code>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/03/11/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/03/11/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>多线程</p><a id="more"></a><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p><ol><li>新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值</li><li>就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</li><li>运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态</li><li>阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态</li><li>在线程的生命周期当中，线程的各种状态的转换过程</li></ol><p><strong>新建和就绪状态</strong><br>当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</p><p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p><blockquote><p>注意：启动线程使用start()方法，而不是run()方法。永远不要调用线程对象的run()方法。调用start0方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常。</p></blockquote><p>调用线程对象的start()方法之后，该线程立即进入就绪状态——就绪状态相当于”等待执行”，但该线程并未真正进入运行状态。如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。</p><p><strong>运行和阻塞状态</strong></p><ol><li><strong>线程调度</strong></li></ol><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU。那么在任何时刻只有一个线程处于运行状态，当然在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。</p><p>当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）。线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。</p><p>所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。</p><ol start="2"><li><strong>线程阻塞</strong></li></ol><p>当发生如下情况时，线程将会进入阻塞状态</p><p>① 线程调用sleep()方法主动放弃所占用的处理器资源</p><p>② 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</p><p>③ 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。</p><p>④ 线程在等待某个通知（notify）</p><p>⑤ 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法</p><p>当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。</p><ol start="3"><li><strong>解除阻塞</strong></li></ol><p>针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：</p><p>① 调用sleep()方法的线程经过了指定时间。</p><p>② 线程调用的阻塞式IO方法已经返回。</p><p>③ 线程成功地获得了试图取得的同步监视器。</p><p>④ 线程正在等待某个通知时，其他线程发出了个通知。</p><p>⑤ 处于挂起状态的线程被调甩了resdme()恢复方法。</p><p>线程状态转换图<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p><p>线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。</p><p><strong>线程死亡</strong><br><strong>死亡状态</strong><br>线程会以如下3种方式结束，结束后就处于死亡状态：</p><p>① run()或call()方法执行完成，线程正常结束。</p><p>② 线程抛出一个未捕获的Exception或Error。</p><p>③ 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。</p><p><strong>程序设计</strong><br>当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。为了测试某个线程是否已经死亡，可以调用线程对象的isAlive()方法，当线程处于就绪、运行、阻塞状态时，该方法将返回true；当线程处于新建、死亡状态时，该方法将返回false。</p><p>不要试图对一个已经死亡的线程调用start()方法使它重新启动，死亡就是死亡，该线程将不可再次作为线程执行。</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static native void sleep(long millis) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    public static void sleep(long millis, int nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                                &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &gt;&#x3D; 500000 || (nanos !&#x3D; 0 &amp;&amp; millis &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Object &#123;</span><br><span class="line"></span><br><span class="line">    public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">            if (timeout &lt; 0) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                                    &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            if (nanos &gt; 0) &#123;</span><br><span class="line">                timeout++;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            wait(timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    public final void wait() throws InterruptedException &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sleep()方法（休眠）是线程类（Thread）的静态方法,调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，线程不会释放对象锁，因此休眠时间结束后会自动恢复</li><li>,wait()是Object类的成员方法,调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li><li>sleep方法需要抛异常,wait方法不需要</li><li>sleep方法可以在任何地方使用,wait方法只能在同步方法和同步代码块中使用</li><li>wait()使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；<br>注意sleep方法是单线程的,没有释放锁,这个锁指的是线程锁,不是对象锁,而wait方法释放锁,这个锁是对象锁,所以sleep时间到和wait等到notify之后享受的待遇一样,都是回到就绪状态,等待系统分配cpu。</li></ol><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；</li><li>线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。</li><li>线程的划分尺度小于进程，这使得多线程程序的并发性高；</li><li>进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。</li><li>使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。</li></ul><h3 id="sleep-和yield-区别？"><a href="#sleep-和yield-区别？" class="headerlink" title="sleep()和yield()区别？"></a>sleep()和yield()区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static native void yield();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</li><li>yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li><li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li></ul><h3 id="当一个线程进入一个对象的synchronized方法A之后，其它线程则不能进入此对象的synchronized方法B"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程则不能进入此对象的synchronized方法B" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程则不能进入此对象的synchronized方法B"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程则不能进入此对象的synchronized方法B</h3><p>其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><h3 id="notify-notityAll"><a href="#notify-notityAll" class="headerlink" title="notify(),notityAll()"></a>notify(),notityAll()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Object &#123;</span><br><span class="line"></span><br><span class="line">     public final native void notify();</span><br><span class="line"></span><br><span class="line">     public final native void notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</li></ul><h3 id="实现多线程的方式"><a href="#实现多线程的方式" class="headerlink" title="实现多线程的方式"></a>实现多线程的方式</h3><ol><li>继承Thread类，重写run方法（Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了），无返回值，返回void。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo01 extends Thread&#123;</span><br><span class="line">    public ThreadDemo01()&#123;</span><br><span class="line">        &#x2F;&#x2F;编写子类的构造方法，可缺省</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        &#x2F;&#x2F;编写自己的线程代码</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123; </span><br><span class="line">        ThreadDemo01 threadDemo01 &#x3D; new ThreadDemo01(); </span><br><span class="line">        threadDemo01.setName(&quot;我是自定义的线程1&quot;);</span><br><span class="line">        threadDemo01.start();       </span><br><span class="line">        System.out.println(Thread.currentThread().toString());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现Runnable接口，重写run方法，更为灵活，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，无返回值，返回void。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo02 &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        Thread t1 &#x3D; new Thread(new MyThread());</span><br><span class="line">        t1.start(); &#x2F;&#x2F;启动线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;--&gt;我是通过实现接口的线程实现方式！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过Callable和FutureTask创建线程，重写call方法，有返回值，返回值是Object。</li></ol><p>a:创建Callable接口的实现类 ，并实现Call方法 <br>b:创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值 <br>c:使用FutureTask对象作为Thread对象的target创建并启动线程 <br>d:调用FutureTask对象的get()来获取子线程执行结束的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo03 &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">        Callable&lt;Object&gt; oneCallable &#x3D; new Tickets&lt;Object&gt;();</span><br><span class="line">        FutureTask&lt;Object&gt; oneTask &#x3D; new FutureTask&lt;Object&gt;(oneCallable);</span><br><span class="line"> </span><br><span class="line">        Thread t &#x3D; new Thread(oneTask);</span><br><span class="line"> </span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"> </span><br><span class="line">        t.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Tickets&lt;Object&gt; implements Callable&lt;Object&gt;&#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;重写call方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;--&gt;我是通过实现Callable接口通过FutureTask包装器来实现的线程&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过线程池创建线程</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo05&#123;</span><br><span class="line"> </span><br><span class="line">    private static int POOL_NUM &#x3D; 10;     &#x2F;&#x2F;线程池数量</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws InterruptedException </span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(5);  </span><br><span class="line">        for(int i &#x3D; 0; i&lt;POOL_NUM; i++)&#123;  </span><br><span class="line">            RunnableThread thread &#x3D; new RunnableThread();</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;Thread.sleep(1000);</span><br><span class="line">            executorService.execute(thread);  </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;关闭线程池</span><br><span class="line">        executorService.shutdown(); </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class RunnableThread implements Runnable&#123;     </span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;  </span><br><span class="line">        System.out.println(&quot;通过线程池方式创建的线程：&quot; + Thread.currentThread().getName() + &quot; &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized关键字的用法？"><a href="#synchronized关键字的用法？" class="headerlink" title="synchronized关键字的用法？"></a>synchronized关键字的用法？</h3><p>synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用<code>synchronized(对象) &#123; … &#125;</code>定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p><h3 id="启动一个线程是调用start-方法"><a href="#启动一个线程是调用start-方法" class="headerlink" title="启动一个线程是调用start()方法"></a>启动一个线程是调用start()方法</h3><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p><h3 id="synchronized-和java-util-concurrent-locks-Lock的异同"><a href="#synchronized-和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized 和java.util.concurrent.locks.Lock的异同"></a>synchronized 和java.util.concurrent.locks.Lock的异同</h3><ul><li>Lock 能完成synchronized所实现的所有功能；Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。</li><li>synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/2020/03/11/%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/03/11/%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>并发</p><a id="more"></a><h3 id="并行是什么意思？与并发的区别是什么？"><a href="#并行是什么意思？与并发的区别是什么？" class="headerlink" title="并行是什么意思？与并发的区别是什么？"></a>并行是什么意思？与并发的区别是什么？</h3><p>并行：指两个或两个以上事件或活动在同一时刻发生。如多个任务在多个 CPU 或 CPU 的多个核上同时执行，不存在 CPU 资源的竞争、等待行为。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E5%B9%B6%E8%A1%8C.png" alt="并行"></p><p><strong>并行与并发的区别</strong></p><ul><li>并行指多个事件在同一个时刻发生；并发指在某时刻只有一个事件在发生，某个时间段内由于 CPU 交替执行，可以发生多个事件。</li><li>并行没有对 CPU 资源的抢占；并发执行的线程需要对 CPU 资源进行抢占。</li><li>并行执行的线程之间不存在切换；并发操作系统会根据任务调度系统给线程分配线程的 CPU 执行时间，线程的执行会进行切换。</li></ul><p><strong>Java 中的多线程</strong></p><ul><li>通过 JDK 中的 java.lang.Thread 可以实现多线程。</li><li>Java 中多线程运行的程序可能是并发也可能是并行，取决于操作系统对线程的调度和计算机硬件资源（ CPU 的个数和 CPU 的核数）。</li><li>CPU 资源比较充足时，多线程被分配到不同的 CPU 资源上，即并行；CPU 资源比较紧缺时，多线程可能被分配到同个 CPU 的某个核上去执行，即并发。</li><li>不管多线程是并行还是并发，都是为了提高程序的性能。</li></ul><h3 id="什么是线程？什么是进程？为什么要有线程？有什么关系与区别？"><a href="#什么是线程？什么是进程？为什么要有线程？有什么关系与区别？" class="headerlink" title="什么是线程？什么是进程？为什么要有线程？有什么关系与区别？"></a>什么是线程？什么是进程？为什么要有线程？有什么关系与区别？</h3><p><strong>进程：</strong></p><ul><li>程序执行时的一个实例</li><li>每个进程都有独立的内存地址空间</li><li>系统进行资源分配和调度的基本单位</li><li>进程里的堆，是一个进程中最大的一块内存，被进程中的所有线程共享的，进程创建时分配，主要存放 new 创建的对象实例</li><li>进程里的方法区，是用来存放进程中的代码片段的，是线程共享的</li><li>在多线程 OS 中，进程不是一个可执行的实体，即一个进程至少创建一个线程去执行代码</li></ul><p><strong>为什么要有线程？</strong></p><p>每个进程都有自己的地址空间，即进程空间。一个服务器通常需要接收大量并发请求，为每一个请求都创建一个进程系统开销大、请求响应效率低，因此操作系统引进线程。      </p><p><strong>线程：</strong></p><ul><li>进程中的一个实体</li><li>进程的一个执行路径</li><li>CPU 调度和分派的基本单位</li><li>线程本身是不会独立存在</li><li>当前线程 CPU 时间片用完后，会让出 CPU 等下次轮到自己时候在执行</li><li>系统不会为线程分配内存，线程组之间只能共享所属进程的资源</li><li>线程只拥有在运行中必不可少的资源(如程序计数器、栈)</li><li>线程里的程序计数器就是为了记录该线程让出 CPU 时候的执行地址，待再次分配到时间片时候就可以从自己私有的计数器指定地址继续执行</li><li>每个线程有自己的栈资源，用于存储该线程的局部变量和调用栈帧，其它线程无权访问</li></ul><p><strong>关系：</strong></p><ul><li>一个程序至少一个进程，一个进程至少一个线程，进程中的多个线程是共享进程的资源</li><li>Java 中当我们启动 main 函数时候就启动了一个 JVM 的进程，而 main 函数所在线程就是这个进程中的一个线程，也叫做主线程</li><li>一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器，栈区域<br>如下图<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E8%BF%9B%E7%A8%8B.png" alt="进程"></li></ul><p><strong>区别：</strong></p><ul><li>本质：进程是操作系统资源分配的基本单位；线程是任务调度和执行的基本单位</li><li>内存分配：系统在运行的时候会为每个进程分配不同的内存空间，建立数据表来维护代码段、堆栈段和数据段；除了 CPU 外，系统不会为线程分配内存，线程所使用的资源来自其所属进程的资源</li><li>资源拥有：进程之间的资源是独立的，无法共享；同一进程的所有线程共享本进程的资源，如内存，CPU，IO 等</li><li>开销：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行程序计数器和栈，线程之间切换的开销小</li><li>通信：进程间 以IPC（管道，信号量，共享内存，消息队列，文件，套接字等）方式通信 ；同一个进程下，线程间可以共享全局变量、静态变量等数据进行通信，做到同步和互斥，以保证数据的一致性</li><li>调度和切换：线程上下文切换比进程上下文切换快，代价小</li><li>执行过程：每个进程都有一个程序执行的入口，顺序执行序列；线程不能够独立执行，必须依存在应用程序中，由程序的多线程控制机制控制</li><li>健壮性：每个进程之间的资源是独立的，当一个进程崩溃时，不会影响其他进程；同一进程的线程共享此线程的资源，当一个线程发生崩溃时，此进程也会发生崩溃，稳定性差，容易出现共享与资源竞争产生的各种问题，如死锁等</li><li>可维护性：线程的可维护性，代码也较难调试，bug 难排查</li></ul><p><strong>进程与线程的选择：</strong></p><ul><li>需要频繁创建销毁的优先使用线程。因为进程创建、销毁一个进程代价很大，需要不停的分配资源；线程频繁的调用只改变 CPU 的执行</li><li>线程的切换速度快，需要大量计算，切换频繁时，用线程</li><li>耗时的操作使用线程可提高应用程序的响应</li><li>线程对 CPU 的使用效率更优，多机器分布的用进程，多核分布用线程</li><li>需要跨机器移植，优先考虑用进程</li><li>需要更稳定、安全时，优先考虑用进程</li><li>需要速度时，优先考虑用线程</li><li>并行性要求很高时，优先考虑用线程</li></ul><p>Java 编程语言中线程是通过 java.lang.Thread 类实现的。</p><p>Thread 类中包含 tid（线程id）、name（线程名称）、group（线程组）、daemon（是否守护线程）、priority（优先级） 等重要属性。</p><h3 id="什么是守护线程？"><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h3><p><strong>Java线程分为用户线程和守护线程。</strong></p><ul><li>守护线程是程序运行的时候在后台提供一种通用服务的线程。所有用户线程停止，进程会停掉所有守护线程，退出程序。</li><li>Java中把线程设置为守护线程的方法：在 start 线程之前调用线程的 setDaemon(true) 方法。</li></ul><p><strong>注意：</strong></p><ul><li>setDaemon(true) 必须在 start() 之前设置，否则会抛出IllegalThreadStateException异常，该线程仍默认为用户线程，继续执行</li><li>守护线程创建的线程也是守护线程</li><li>守护线程不应该访问、写入持久化资源，如文件、数据库，因为它会在任何时间被停止，导致资源未释放、数据写入中断等问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a008;</span><br><span class="line"></span><br><span class="line">public class TestDaemonThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testDaemonThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    public static void testDaemonThread() &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;创建线程，校验守护线程内创建线程是否为守护线程</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;t2 : &quot; + (Thread.currentThread().isDaemon() ? &quot;守护线程&quot; : &quot;非守护线程&quot;));</span><br><span class="line">            &#125;);</span><br><span class="line">            t2.start();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;当所有用户线程执行完，守护线程会被直接杀掉，程序停止运行</span><br><span class="line">            int i &#x3D; 1;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;t : &quot; + (Thread.currentThread().isDaemon() ? &quot;守护线程&quot; : &quot;非守护线程&quot;) + &quot; , 执行次数 : &quot; + i);</span><br><span class="line">                if (i++ &gt;&#x3D; 10) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;setDaemon(true) 必须在 start() 之前设置，否则会抛出IllegalThreadStateException异常，该线程仍默认为用户线程，继续执行</span><br><span class="line">        t.setDaemon(true);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;主线程结束</span><br><span class="line">        System.out.println(&quot;主线程结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t2 : 守护线程</span><br><span class="line">t : 守护线程 , 执行次数 : 1</span><br><span class="line">主线程结束</span><br><span class="line">t : 守护线程 , 执行次数 : 2</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>上述代码线程t，未打印到 t : daemon thread , time : 10，说明所有用户线程停止，进程会停掉所有守护线程，退出程序</li><li>当 t.start(); 放到 t.setDaemon(true);  之前，程序抛出IllegalThreadStateException，t 仍然是用户线程，打印如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; t2 : 非守护线程</span><br><span class="line">java.lang.IllegalThreadStateException</span><br><span class="line">    at java.lang.Thread.setDaemon(Thread.java:1359)</span><br><span class="line">    at constxiong.concurrency.a008.TestDaemonThread.testDaemonThread(TestDaemonThread.java:39)</span><br><span class="line">    at constxiong.concurrency.a008.TestDaemonThread.main(TestDaemonThread.java:11)</span><br><span class="line">t : 非守护线程 , 执行次数 : 1</span><br><span class="line">t : 非守护线程 , 执行次数 : 2</span><br><span class="line">t : 非守护线程 , 执行次数 : 3</span><br><span class="line">t : 非守护线程 , 执行次数 : 4</span><br><span class="line">t : 非守护线程 , 执行次数 : 5</span><br><span class="line">t : 非守护线程 , 执行次数 : 6</span><br><span class="line">t : 非守护线程 , 执行次数 : 7</span><br><span class="line">t : 非守护线程 , 执行次数 : 8</span><br><span class="line">t : 非守护线程 , 执行次数 : 9</span><br><span class="line">t : 非守护线程 , 执行次数 : 10</span><br></pre></td></tr></table></figure><h3 id="如何创建、启动-Java-线程？"><a href="#如何创建、启动-Java-线程？" class="headerlink" title="如何创建、启动 Java 线程？"></a>如何创建、启动 Java 线程？</h3><p>Java 中有 4 种常见的创建线程的方式。</p><ol><li><strong>重写 Thread 类的 run() 方法。</strong></li></ol><p>表现形式有两种：<br><strong>1）new Thread 对象匿名重写 run() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a006;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * new Thread 对象匿名重写 run() 方法，启动线程</span><br><span class="line">  *&#x2F;</span><br><span class="line">public class TestNewThread &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建线程 t, 重写 run() 方法</span><br><span class="line">        new Thread(&quot;t&quot;) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt;3; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;thread t &gt; &quot; + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t &gt; 0</span><br><span class="line">thread t &gt; 1</span><br><span class="line">thread t &gt; 2</span><br></pre></td></tr></table></figure><p><strong>2）继承 Thread 对象，重写 run() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a006;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 继承 Thread 类，重写 run() 方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestExtendsThread &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ThreadExt().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ThreadExt 继承 Thread，重写 run() 方法</span><br><span class="line">class ThreadExt extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;3; i++) &#123;</span><br><span class="line">            System.out.println(&quot;thread t &gt; &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t &gt; 0</span><br><span class="line">thread t &gt; 1</span><br><span class="line">thread t &gt; 2</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>实现 Runnable 接口，重写 run() 方法。</strong></li></ol><p>表现形式有两种：<br><strong>1）new Runnable 对象，匿名重写 run() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a006;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * new Runnalbe 对象匿名重写 run() 方法，启动线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestNewRunnable &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        newRunnable();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void newRunnable() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建线程 t1, 重写 run() 方法</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt;3; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;thread t1 &gt; &quot; + i);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000L);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line">                </span><br><span class="line">        &#x2F;&#x2F;创建线程 t2, lambda 表达式设置线程的执行代码</span><br><span class="line">        &#x2F;&#x2F;JDK 1.8 开始支持 lambda 表达式</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt;3; i++) &#123;</span><br><span class="line">                System.out.println(&quot;thread t2 &gt; &quot; + i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread t1 &gt; 0</span><br><span class="line">thread t2 &gt; 0</span><br><span class="line">thread t1 &gt; 1</span><br><span class="line">thread t2 &gt; 1</span><br><span class="line">thread t1 &gt; 2</span><br><span class="line">thread t2 &gt; 2</span><br></pre></td></tr></table></figure><p><strong>2）实现 Runnable 接口，重写 run() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a006;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实现 Runnable 接口，重写 run() 方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestImplRunnable &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new RunnableImpl()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;RunnableImpl 实现 Runnalbe 接口，重写 run() 方法</span><br><span class="line">class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;3; i++) &#123;</span><br><span class="line">            System.out.println(&quot;thread t &gt; &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t &gt; 0</span><br><span class="line">thread t &gt; 1</span><br><span class="line">thread t &gt; 2</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>实现 Callable 接口，使用 FutureTask 类创建线程</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a006;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实现 Callable 接口，使用 FutureTask 类创建线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestCreateThreadByFutureTask &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;通过构造 FutureTask(Callable callable) 构造函数，创建 FutureTask，匿名实现接口 Callable 接口</span><br><span class="line">        FutureTask&lt;String&gt; ft &#x3D; new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                return &quot;ConstXiong&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Lambda 方式实现</span><br><span class="line">&#x2F;&#x2F;        FutureTask&lt;String&gt; ft &#x3D; new FutureTask&lt;String&gt;(() -&gt;  &quot;ConstXiong&quot;);</span><br><span class="line">        </span><br><span class="line">        new Thread(ft).start();</span><br><span class="line">        System.out.println(&quot;执行结果：&quot; + ft.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行结果：ConstXiong</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用线程池创建、启动线程</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a006;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 线程池的方式启动线程</span><br><span class="line"> * @author ConstXiong</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestCreateThreadByThreadPool &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用工具类 Executors 创建单线程线程池</span><br><span class="line">        ExecutorService singleThreadExecutor &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        &#x2F;&#x2F;提交执行任务</span><br><span class="line">        singleThreadExecutor.submit(() -&gt; &#123;System.out.println(&quot;单线程线程池执行任务&quot;);&#125;);</span><br><span class="line">        &#x2F;&#x2F;关闭线程池</span><br><span class="line">        singleThreadExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单线程线程池执行任务</span><br></pre></td></tr></table></figure><h3 id="什么是并发编程？"><a href="#什么是并发编程？" class="headerlink" title="什么是并发编程？"></a>什么是并发编程？</h3><p><strong>并发：</strong></p><ul><li>在程序设计的角度，希望通过某些机制让计算机可以在一个时间段内，执行多个任务。</li><li>一个或多个物理 CPU 在多个程序之间多路复用，提高对计算机资源的利用率。</li><li>任务数多余 CPU 的核数，通过操作系统的任务调度算法，实现多个任务一起执行。</li><li>有多个线程在执行，计算机只有一个 CPU，不可能真正同时运行多个线程，操作系统只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。</li></ul><p><strong>并发编程：</strong></p><ul><li>用编程语言编写让计算机可以在一个时间段内执行多个任务的程序。</li></ul><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.jpg" alt="并发编程"></p><h3 id="为什么要用并发编程？"><a href="#为什么要用并发编程？" class="headerlink" title="为什么要用并发编程？"></a>为什么要用并发编程？</h3><ul><li>“摩尔定律” 失效，硬件的单元计算能力提升受限；硬件上提高了 CPU 的核数和个数。并发编程可以提升 CPU 的计算能力的利用率。</li><li>提升程序的性能，如：响应时间、吞吐量、计算机资源使用率等。</li><li>并发程序可以更好地处理复杂业务，对复杂业务进行多任务拆分，简化任务调度，同步执行任务。</li></ul><h3 id="并发编程的缺点？"><a href="#并发编程的缺点？" class="headerlink" title="并发编程的缺点？"></a>并发编程的缺点？</h3><ul><li>Java 中的线程对应是操作系统级别的线程，线程数量控制不好，频繁的创建、销毁线程和线程间的切换，比较消耗内存和时间。</li><li>容易带来线程安全问题。如线程的可见性、有序性、原子性问题，会导致程序出现的结果与预期结果不一致。</li><li>多线程容易造成死锁、活锁、线程饥饿等问题。此类问题往往只能通过手动停止线程、甚至是进程才能解决，影响严重。</li><li>对编程人员的技术要求较高，编写出正确的并发程序并不容易。</li><li>并发程序易出问题，且难调试和排查；问题常常诡异地出现，又诡异地消失。</li></ul><h3 id="导致并发程序出问题的根本原因是什么？"><a href="#导致并发程序出问题的根本原因是什么？" class="headerlink" title="导致并发程序出问题的根本原因是什么？"></a>导致并发程序出问题的根本原因是什么？</h3><p>CPU、内存、IO 设备的读写速度差异巨大，表现为 CPU 的速度 &gt; 内存的速度 &gt; IO 设备的速度。</p><p>程序的性能瓶颈在于速度最慢的 IO 设备的读写，也就是说当涉及到 IO 设备的读写，再怎么提升 CPU 和内存的速度也是起不到提升性能的作用。</p><p>为了更好地利用 CPU 的高性能</p><ul><li>计算机体系结构，给 CPU 增加了缓存，均衡 CPU 和内存的速度差异</li><li>操作系统，增加了进程与线程，分时复用 CPU，均衡 CPU 和 IO 设备的速度差异</li><li>编译器，增加了指令执行重排序，更好地利用缓存，提高程序的执行速度</li></ul><p>基于以上优化，给并发编程带来了三大问题。</p><ol><li><strong>CPU 缓存，在多核 CPU 的情况下，带来了可见性问题</strong></li></ol><p>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到修改后的值</p><p>看下面代码，启动两个线程，一个线程当 stop 变量为 true 时，停止循环，一个线程启动就设置 stop 变量为 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a014;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试可见性问题</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestVisibility &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否停止 变量</span><br><span class="line">    private static boolean stop &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;启动线程 1，当 stop 为 true，结束循环</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;线程 1 正在运行...&quot;);</span><br><span class="line">            while (!stop) ;</span><br><span class="line">            System.out.println(&quot;线程 1 终止&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;休眠 10 毫秒</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;启动线程 2， 设置 stop &#x3D; true</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;线程 2 正在运行...&quot;);</span><br><span class="line">            stop &#x3D; true;</span><br><span class="line">            System.out.println(&quot;设置 stop 变量为 true.&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是因为 CPU 缓存导致的可见性导致的问题。线程 2 设置 stop 变量为 true，线程 1 在 CPU 1上执行，读取的 CPU 1 缓存中的 stop 变量仍然为 false，线程 1 一直在循环执行。</p><p>示意如图：<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98.png" alt="可见性问题"></p><p>可以通过 volatile、synchronized、Lock接口、Atomic 类型保障可见性。</p><ol start="2"><li><strong>操作系统对当前执行线程的切换，带来了原子性问题</strong></li></ol><p>原子性：一个或多个指令在 CPU 执行的过程中不被中断的特性</p><p>看下面的一段代码，线程 1 和线程 2 分别对变量 count 增加 10000，但是结果 count 的输出却不是 20000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a014;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试原子性问题</span><br><span class="line"> * @author ConstXiong</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestAtomic &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;计数变量</span><br><span class="line">    static volatile int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;线程 1 给 count 加 10000</span><br><span class="line">        Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;10000; j++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;thread t1 count 加 10000 结束&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;线程 2 给 count 加 10000</span><br><span class="line">        Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;10000; j++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;thread t2 count 加 10000 结束&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;启动线程 1</span><br><span class="line">        t1.start();</span><br><span class="line">        &#x2F;&#x2F;启动线程 2</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;等待线程 1 执行完成</span><br><span class="line">        t1.join();</span><br><span class="line">        &#x2F;&#x2F;等待线程 2 执行完成</span><br><span class="line">        t2.join();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;打印 count 变量</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t2 count 加 10000 结束</span><br><span class="line">thread t1 count 加 10000 结束</span><br><span class="line">11377</span><br></pre></td></tr></table></figure><p>这个就是因为线程切换导致的原子性问题。</p><p>Java 代码中 的 count++ ，至少需要三条 CPU 指令：</p><ul><li>指令 1：把变量 count 从内存加载到 CPU 的寄存器</li><li>指令 2：在寄存器中执行 count + 1 操作</li><li>指令 3：+1 后的结果写入 CPU 缓存 或 内存</li></ul><p>即使是单核的 CPU，当线程 1 执行到指令 1 时发生线程切换，线程 2 从内存中读取 count 变量，此时线程 1 和线程 2 中的 count 变量值是相等，都执行完指令 2 和指令 3，写入的 count 的值是相同的。从结果上看，两个线程都进行了 count++，但是 count 的值只增加了 1。</p><p>指令执行与线程切换<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2.png" alt="线程切换"></p><ol start="3"><li><strong>编译器指令重排优化，带来了有序性问题</strong></li></ol><p>有序性：程序按照代码执行的先后顺序</p><p>看下面这段代码，复现指令重排带来的有序性问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.concurrency.a014;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试有序性问题</span><br><span class="line"> * @author ConstXiong</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestOrderliness &#123;</span><br><span class="line">    </span><br><span class="line">    static int x;&#x2F;&#x2F;静态变量 x</span><br><span class="line">    static int y;&#x2F;&#x2F;静态变量 y</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Set&lt;String&gt; valueSet &#x3D; new HashSet&lt;String&gt;();&#x2F;&#x2F;记录出现的结果的情况</span><br><span class="line">        Map&lt;String, Integer&gt; valueMap &#x3D; new HashMap&lt;String, Integer&gt;();&#x2F;&#x2F;存储结果的键值对</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;循环 1000 万次，记录可能出现的 v1 和 v2 的情况</span><br><span class="line">        for (int i &#x3D; 0; i &lt;10000000; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;给 x y 赋值为 0</span><br><span class="line">            x &#x3D; 0; </span><br><span class="line">            y &#x3D; 0; </span><br><span class="line">            valueMap.clear();&#x2F;&#x2F;清除之前记录的键值对</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                int v1 &#x3D; y;&#x2F;&#x2F;将 y 赋值给 v1 ----&gt; Step1</span><br><span class="line">                x &#x3D; 1;&#x2F;&#x2F;设置 x 为 1  ----&gt; Step2</span><br><span class="line">                valueMap.put(&quot;v1&quot;, v1);&#x2F;&#x2F;v1 值存入 valueMap 中  ----&gt; Step3</span><br><span class="line">            &#125;) ;</span><br><span class="line">            </span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                int v2 &#x3D; x;&#x2F;&#x2F;将 x 赋值给 v2  ----&gt; Step4</span><br><span class="line">                y &#x3D; 1;&#x2F;&#x2F;设置 y 为 1  ----&gt; Step5</span><br><span class="line">                valueMap.put(&quot;v2&quot;, v2);&#x2F;&#x2F;v2 值存入 valueMap 中  ----&gt; Step6</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;启动线程 t1 t2</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            &#x2F;&#x2F;等待线程 t1 t2 执行完成</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;利用 Set 记录并打印 v1 和 v2 可能出现的不同结果</span><br><span class="line">            valueSet.add(&quot;(v1&#x3D;&quot; + valueMap.get(&quot;v1&quot;) + &quot;,v2&#x3D;&quot; + valueMap.get(&quot;v2&quot;) + &quot;)&quot;);</span><br><span class="line">            System.out.println(valueSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果出现四种情况：</p><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E6%89%93%E5%8D%B04%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="打印4种情况"></p><p>v1=0,v2=0 的执行顺序是 Step1 和 Step 4 先执行<br>v1=1,v2=0 的执行顺序是 Step5 先于 Step1 执行<br>v1=0,v2=1 的执行顺序是 Step2 先于 Step4 执行<br>v1=1,v2=1 出现的概率极低，就是因为 CPU 指令重排序造成的。Step2 被优化到 Step1 前，Step5 被优化到 Step4 前，至少需要成立一个。<br>指令重排，可能会发生在两个没有相互依赖关系之间的指令。</p><h3 id="如何优雅地停止一个线程？"><a href="#如何优雅地停止一个线程？" class="headerlink" title="如何优雅地停止一个线程？"></a>如何优雅地停止一个线程？</h3><p>线程终止有两种情况：</p><ol><li>线程的任务执行完成</li><li>线程在执行任务过程中发生异常</li></ol><p>这两者属于线程自行终止，如何让线程 A 把线程 B 终止呢？</p><p>Java 中 Thread 类有一个 stop() 方法，可以终止线程，不过这个方法会让线程直接终止，在执行的任务立即终止，未执行的任务无法反馈，所以 stop() 方法已经不建议使用。</p><p>既然 stop() 方法如此粗暴，不建议使用，我们如何优雅地结束线程呢？</p><p>线程只有从 runnable 状态（可运行/运行状态） 才能进入terminated 状态（终止状态），如果线程处于 blocked、waiting、timed_waiting 状态（休眠状态），就需要通过 Thread 类的 interrupt()  方法，让线程从休眠状态进入 runnable 状态，从而结束线程。</p><p>当线程进入 runnable 状态之后，通过设置一个标识位，线程在合适的时机，检查该标识位，发现符合终止条件，自动退出 run () 方法，线程终止。</p><h3 id="线程包括哪些状态？状态之间是如何变化的？"><a href="#线程包括哪些状态？状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态？状态之间是如何变化的？"></a>线程包括哪些状态？状态之间是如何变化的？</h3><p><strong>线程的生命周期</strong><br>线程包括哪些状态的问题说专业一点就是线程的生命周期。<br>不同的编程语言对线程的生命周期封装是不同的。</p><p>Java 中线程的生命周期</p><p><strong>Java 语言中线程共有六种状态。</strong></p><ol><li>NEW（初始化状态）</li><li>RUNNABLE（可运行 / 运行状态）</li><li>BLOCKED（阻塞状态）</li><li>WAITING（无限时等待）</li><li>TIMED_WAITING（有限时等待）</li><li>TERMINATED（终止状态） 在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态（休眠状态）。即只要 Java 线程处于这三种状态之一，就永远没有 CPU 的使用权。</li></ol><p><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="线程生命周期"></p><p><strong>Java 中线程的状态的转变</strong></p><ol><li>NEW 到 RUNNABLE 状态</li></ol><p>Java 刚创建出来的 Thread 对象就是 NEW 状态，不会被操作系统调度执行。从 NEW 状态转变到 RUNNABLE 状态调用线程对象的 start() 方法就可以了。</p><ol start="2"><li>RUNNABLE 与 BLOCKED 的状态转变</li></ol><ul><li>synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，等待的线程会从 RUNNABLE 转变到 BLOCKED 状态。</li><li>当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转变到 RUNNABLE 状态。</li><li>在操作系统层面，线程是会转变到休眠状态的，但是在 JVM 层面，Java 线程的状态不会发生变化，即 Java 线程的状态会保持 RUNNABLE 状态。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面处于可执行状态）与等待 I/O（操作系统层面处于休眠状态）没有区别，都是在等待某个资源，都归入了 RUNNABLE 状态。</li><li>Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。</li></ul><ol start="3"><li>RUNNABLE 与 WAITING 的状态转变</li></ol><ul><li>获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法，状态会从 RUNNABLE 转变到 WAITING；调用 Object.notify()、Object.notifyAll() 方法，线程可能从 WAITING 转变到 RUNNABLE 状态。</li><li>调用无参数的 Thread.join() 方法。join() 是一种线程同步方法，如有一线程对象 Thread t，当调用 t.join() 的时候，执行代码的线程的状态会从 RUNNABLE 转变到 WAITING，等待 thread t 执行完。当线程 t 执行完，等待它的线程会从 WAITING 状态转变到 RUNNABLE 状态。</li><li>调用 LockSupport.park() 方法，线程的状态会从 RUNNABLE 转变到 WAITING；调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 转变为 RUNNABLE 状态。</li></ul><ol start="4"><li>RUNNABLE 与 TIMED_WAITING 的状态转变</li></ol><ul><li>Thread.sleep(long millis)</li><li>Object.wait(long timeout)</li><li>Thread.join(long millis)</li><li>LockSupport.parkNanos(Object blocker, long deadline)</li><li>LockSupport.parkUntil(long deadline)</li><li>TIMED_WAITING 和 WAITING 状态的区别，仅仅是调用的是超时参数的方法。</li></ul><ol start="5"><li>RUNNABLE 到 TERMINATED 状态</li></ol><ul><li>线程执行完 run() 方法后，会自动转变到 TERMINATED 状态</li><li>执行 run() 方法时异常抛出，也会导致线程终止</li><li><del>Thread类的 stop() 方法已经不建议使用</del></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2020/03/09/redis/redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/09/redis/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>redis基础整理</p><a id="more"></a><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><ul><li>Remote Dictionary Server(Redis) 是一个key-value存储系统。</li><li>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</li><li>它通常被称为数据结构服务器，因为值(value)可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</li><li>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</li></ul><p><strong>Redis 与其他 key - value 缓存产品有以下三个特点：</strong></p><ol><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><p><strong>优势</strong></p><ol><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ol><p>默认端口 6379</p><p><strong>数据类型</strong><br>五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><hr><h3 id="键key"><a href="#键key" class="headerlink" title="键key"></a>键key</h3><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>del key </code></td><td>删除已存在的键。不存在的 key 会被忽略。返回被删除 key 的数量。</td></tr><tr><td><code>dump key</code></td><td>序列化给定 key ，并返回被序列化的值。如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</td></tr><tr><td><code>exists key</code></td><td>检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。</td></tr><tr><td><code>expire key time</code></td><td>设置 key 的过期时间。单位秒。设置成功返回 1。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td></tr><tr><td><code>expireat key time</code></td><td>以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td></tr><tr><td><code>pexpire key milliseconds</code></td><td>设置 key 的过期时间。单位毫秒，设置成功，返回 1。key 不存在或设置失败，返回 0。</td></tr><tr><td><code>pexpireat key time</code></td><td>设置 key 的过期时间，以毫秒计。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td></tr><tr><td><code>keys pattern</code></td><td>查找所有符合给定模式 pattern 的 key。返回符合给定模式的 key 列表 (Array)。</td></tr><tr><td><code>move key db</code></td><td>将当前数据库的 key 移动到给定的数据库 db 当中。移动成功返回 1 ，失败则返回 0 。</td></tr><tr><td><code>persist key</code></td><td>移除给定 key 的过期时间，使得 key 永不过期。当过期时间移除成功时，返回 1 。 如果 key 不存在或 key 没有设置过期时间，返回 0 。</td></tr><tr><td><code>pttl key</code></td><td>返回 key 的剩余过期时间。单位毫秒。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以毫秒为单位，返回 key 的剩余生存时间。</td></tr><tr><td><code>ttl key </code></td><td>返回 key 的剩余过期时间。单位秒。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</td></tr><tr><td><code>randomkey</code></td><td>从当前数据库中随机返回一个 key 。当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil （windows 系统返回 null）。</td></tr><tr><td><code>rename oldkey newkey</code></td><td>修改 key 的名称。改名成功时提示 OK ，失败时候返回一个错误。</td></tr><tr><td><code>renamenx oldkey newkey</code></td><td>在新的 key 不存在时修改 key 的名称。修改成功，返回 1 。 如果 newkey 已经存在，返回 0 。</td></tr><tr><td><code>type key </code></td><td>返回 key 所储存的值的类型。数据类型有 none (key不存在)  string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表)</td></tr><tr><td><code>select 0</code></td><td>指定数据库0</td></tr></tbody></table><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><ol><li>String 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</li><li>String 类型是二进制安全的。意思是 redis 的 String 可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>String 类型的值最大能存储 512MB。</li></ol><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>set key value</code></td><td>设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。总是返回 OK 。</td></tr><tr><td><code>get key </code></td><td>获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误。</td></tr><tr><td><code>getrange key start end</code></td><td>获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。返回截取得到的子字符串。</td></tr><tr><td><code>getset key value</code></td><td>设置指定 key 的值，并返回 key 的旧值。当 key 没有旧值时，即 key 不存在时，返回 nil 。当 key 存在但不是字符串类型时，返回一个错误。</td></tr><tr><td><code>getbit key offset</code></td><td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当偏移量 offset比字符串值的长度大，或者 key 不存在时，返回 0 。</td></tr><tr><td><code>mget key1 key2 ... </code></td><td>返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。一个包含所有给定 key 的值的列表。</td></tr><tr><td><code>setbit key offset </code></td><td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。返回指定偏移量原来储存的位。</td></tr><tr><td><code>setex key time value </code></td><td>为指定的 key 设置值及其过期时间。如果 key 已经存在，setex命令将会替换旧的值。</td></tr><tr><td><code>setnx key value</code></td><td>在指定的 key 不存在时，为 key 设置指定的值。设置成功，返回 1 。 设置失败，返回 0。</td></tr><tr><td><code>setrange key offset value </code></td><td>用指定的字符串value覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。返回被修改后的字符串长度。</td></tr><tr><td><code>strlen key</code></td><td>获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。当 key 不存在时，返回 0。</td></tr><tr><td><code>mset key1 value1 key2 value2 ...</code></td><td>同时设置一个或多个 key-value 对。总是返回 OK 。</td></tr><tr><td><code>msetnx key1 value1 key2 value2 ...</code></td><td>所有给定 key 都不存在时，同时设置一个或多个key-value对。当所有 key 都成功设置，返回1。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。</td></tr><tr><td><code>psetex key time value</code></td><td>设置 key 的生存时间。单位毫秒。设置成功时返回 OK 。</td></tr><tr><td><code>incr key</code></td><td>将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td></tr><tr><td><code>incrby key amount</code></td><td>将 key 中储存的数字加上指定的增量值。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td></tr><tr><td><code>incrbyfloat key amount</code></td><td>为 key 中所储存的值加上指定的浮点数增量值。如果 key 不存在，那么 incrbyfloat会先将 key 的值设为 0 ，再执行加法操作。</td></tr><tr><td><code>decr key</code></td><td>将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td></tr><tr><td><code>decrby key amount</code></td><td>将 key 所储存的值减去指定的减量值。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</td></tr><tr><td><code>append key value</code></td><td>为指定的 key 追加值。如果 key 已经存在并且是一个字符串， append命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， append就简单地将给定 key 设为 value ，就像执行 set key value 一样。返回追加指定值之后， key 中字符串的长度。</td></tr></tbody></table><h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><ol><li>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</li><li>Redis 中每个 hash 可以存储40多亿键值对。</li></ol><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>hdel key field1 field2 ... </code></td><td>删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。返回被成功删除字段的数量，不包括被忽略的字段。</td></tr><tr><td><code>hexists key field</code></td><td>查看哈希表的指定字段是否存在。如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。</td></tr><tr><td><code>hget key flied </code></td><td>返回哈希表中指定字段的值。如果给定的字段或 key 不存在时，返回 nil 。</td></tr><tr><td><code>hgetall key </code></td><td>返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。 若 key 不存在，返回空列表。</td></tr><tr><td><code>hincrby key filed number</code></td><td>为哈希表中的字段值加上指定增量值。增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 key 不存在，一个新的哈希表被创建并执行 hincrby 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行 hincrby 命令将造成一个错误。</td></tr><tr><td><code>hincrbyfloat key field incrment </code></td><td>为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。返回哈希表中字段的值。</td></tr><tr><td><code>hkeys key </code></td><td>获取哈希表中的所有域（field）。返回包含哈希表中所有域（field）列表。 当 key 不存在时，返回一个空列表。</td></tr><tr><td><code>hlen key</code></td><td>获取哈希表中字段的数量。 当 key 不存在时，返回 0 。</td></tr><tr><td><code>hmget key filed1 filed2 ... </code></td><td>返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。表值的排列顺序和指定字段的请求顺序一样。</td></tr><tr><td><code>hmset key filed1 value1 field2 value2 ...</code></td><td>同时将多个 field-value (字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作。如果命令执行成功，返回 OK 。</td></tr><tr><td><code>hset key field value</code></td><td>为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。</td></tr><tr><td><code>hsetnx key field value </code></td><td>为哈希表中不存在的的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。</td></tr><tr><td><code>hvals key field value </code></td><td>返回哈希表所有域(field)的值。返回一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表。</td></tr></tbody></table><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><p><strong>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。一个列表最多可以包含 4294967295个元素 (每个列表超过40亿个元素)。</strong></p><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>blpop list1 list2 ...timeout </code></td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。单位秒。</td></tr><tr><td><code>brpop list1 list2 ... timeout</code></td><td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</td></tr><tr><td><code>brpoplpush</code></td><td>从列表中取出最后一个元素，并插入到另外一个列表的头部； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</td></tr><tr><td><code>lindex key index_position</code></td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。返回列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回 nil 。</td></tr><tr><td><code>llen key</code></td><td>返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。</td></tr><tr><td><code>lpop key</code></td><td>移除并返回列表的第一个元素。 当列表 key 不存在时，返回 nil 。</td></tr><tr><td><code>lpush key value1 value2 ... </code></td><td>将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 lpush 操作。 当 key 存在但不是列表类型时，返回一个错误。执行成功返回列表的长度。</td></tr><tr><td><code>lpushx key value1 value2 ...</code></td><td>将一个值插入到已存在的列表头部，列表不存在时操作无效。返回命令执行之后，列表的长度。</td></tr><tr><td><code>lrange key start end</code></td><td>返回列表中指定区间内的元素，区间以偏移量 start 和 end 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td></tr><tr><td><code>lrem key count value </code></td><td>根据参数 count 的值，移除列表中与参数 value 相等的元素。返回被移除元素的数量。 列表不存在时返回 0 。</td></tr><tr><td><code>lset key index value</code></td><td>通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行 lset 时，返回一个错误。操作成功返回 ok ，否则返回错误信息。</td></tr><tr><td><code>ltrim key start stop</code></td><td>对一个列表进行修剪(trim)，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 0 表示列表的第一个元素，下标 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td></tr><tr><td><code>rpop key</code></td><td>移除列表的最后一个元素，返回值为移除的元素。当列表不存在时，返回 nil 。</td></tr><tr><td><code>rpush key value1 value2</code></td><td>将一个或多个值插入到列表的尾部(最右边)。如果列表不存在，一个空列表会被创建并执行 rpush 操作。 当列表存在但不是列表类型时，返回一个错误。返回执行 rpush 操作后，列表的长度。</td></tr><tr><td><code>rpoplpush source_key destination_key</code></td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回。返回被弹出的元素。</td></tr></tbody></table><p> <code>linsert key before[after] pivot value </code><br> 在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。<br><code>rpushx key value1 value2 ...</code><br>将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。返回执行 rpushx 操作后，列表的长度。count 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。 count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。count = 0 : 移除表中所有与 value 相等的值。</p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><ol><li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li><li>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li><li>集合中最大的成员数为4294967295, 每个集合可存储40多亿个成员。</li></ol><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>sadd key value1 value2...</code></td><td>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。当集合 key 不是集合类型时，返回一个错误。返回被添加到集合中的新元素的数量，不包括被忽略的元素。</td></tr><tr><td><code>scard key</code></td><td>返回集合中元素的数量。 当集合 key 不存在时，返回 0 。</td></tr><tr><td><code>sdiffstore destionation_key key1 key2 ...</code></td><td>将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖。返回结果集中的元素数量。</td></tr><tr><td><code>sinter key key1 key2 ...</code></td><td>返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</td></tr><tr><td><code>sinterstore destionation_key key key1 key2 ...</code></td><td>给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。返回存储交集的集合的元素数量</td></tr><tr><td><code>sismember key value</code></td><td>判断成员元素是否是集合的成员。如果成员元素是集合的成员，返回 1 。 如果成员元素不是集合的成员，或 key 不存在，返回 0 。</td></tr><tr><td><code>smembers key</code></td><td>返回集合中的所有的成员。 不存在的集合 key 被视为空集合。</td></tr><tr><td><code>smove source destination member</code></td><td>将指定成员 member 元素从 source 集合移动到 destination 集合。smove 是原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 smove 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。当 destination 集合已经包含 member 元素时， smove 命令只是简单地将 source 集合中的 member 元素删除。当 source 或 destination 不是集合类型时，返回一个错误。如果成员元素被成功移除，返回 1 。 如果成员元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</td></tr><tr><td><code>spop key [count]</code></td><td>移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素。该命令类似 srandmember 命令，但 spop 将随机元素从集合中移除并返回，而 srandmember 则仅仅返回随机元素，而不对集合进行任何改动。返回被移除的随机元素。 当集合不存在或是空集时，返回 nil 。</td></tr><tr><td><code>srem key member1 member2 ...</code></td><td>移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。当 key 不是集合类型，返回一个错误。返回被成功移除的元素的数量，不包括被忽略的元素。</td></tr><tr><td><code>sunion key key1 key2 ...</code></td><td>返回给定集合的并集。不存在的集合 key 被视为空集。返回并集成员的列表。</td></tr><tr><td><code>sunionstore destination key key1 key2 ...</code></td><td>将给定集合的并集存储在指定的集合 destination 中。如果 destination 已经存在，则将其覆盖。返回结果集中的元素数量。</td></tr><tr><td><code>sscan key cursor [match pattern] [count count]</code></td><td>迭代集合中键的元素。返回数组列表</td></tr><tr><td><code>srandmember key [count]</code></td><td>返回集合中的一个随机元素。从 Redis 2.6 版本开始， srandmember 命令接受可选的 count 参数：如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。该操作和 spop 相似，但 spop 将随机元素从集合中移除并返回，而 srandmember 则仅仅返回随机元素，而不对集合进行任何改动。</td></tr><tr><td><code>sdiff first_key other_key1 other_key2 ...</code></td><td>返回给定集合之间的差集。不存在的集合 key 将视为空集。返回包含差集成员的列表。差集的结果来自前面的 first_key ,而不是后面的 other_key1，也不是整个 first_key other_key1..other_keyn 的差集。实例:key1 = {a,b,c,d}；key2 = {c}；key3 = {a,c,e}；sdiff key1 key2 key3 = {b,d}</td></tr></tbody></table><ul><li></li></ul><h3 id="Sorted-Set-有序集合"><a href="#Sorted-Set-有序集合" class="headerlink" title="Sorted Set(有序集合)"></a>Sorted Set(有序集合)</h3><ol><li>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</li><li>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li><li>有序集合的成员是唯一的,但分数(score)却可以重复。</li><li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</li></ol><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>zadd key score1 value1 score2 value2 ...</code></td><td>将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 key 不存在，则创建一个空的有序集并执行 zadd 操作。当 key 存在但不是有序集类型时，返回一个错误。返回被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</td></tr><tr><td><code>zcard key</code></td><td>计算集合中元素的数量。当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</td></tr><tr><td><code>zcount key min max</code></td><td>计算有序集合中指定分数区间的成员数量。返回分数值在 min 和 max 之间的成员的数量。</td></tr><tr><td><code>zincrby key increment member</code></td><td>对有序集合中指定成员的分数加上增量 increment。可以通过传递一个负数值 increment ，让分数减去相应的值，比如 zincrby key -5 member ，就是让 member 的 score 值减去 5 。当 key 不存在，或分数不是 key 的成员时， zincrby key increment member 等同于 zadd key increment member 。当 key 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。返回member 成员的新分数值，以字符串形式表示。</td></tr><tr><td><code>zlexcount key min max</code></td><td>计算有序集合中指定字典区间内成员数量。</td></tr><tr><td><code>zrange key start stop [withscores]</code></td><td>返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用zrevrange命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。返回指定区间内，带有分数值(可选)的有序集成员的列表。</td></tr><tr><td><code>zrangebylex key min max [limit offset count]</code></td><td>通过字典区间返回有序集合的成员。返回指定区间内的元素列表。</td></tr><tr><td><code>zrank key member</code></td><td>返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。如果成员是有序集 key 的成员，返回 member 的排名。 如果成员不是有序集 key 的成员，返回 nil 。</td></tr><tr><td><code>zrem key member [member ...]</code></td><td>移除有序集中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。返回被成功移除的成员的数量，不包括被忽略的成员。</td></tr><tr><td><code>zremrangebylex key min max</code></td><td>移除有序集合中给定的字典区间的所有成员。返回被成功移除的成员的数量，不包括被忽略的成员。</td></tr><tr><td><code>zremrangebyrank key start stop</code></td><td>移除有序集中，指定排名(rank)区间内的所有成员。返回被移除成员的数量。</td></tr><tr><td><code>zrevrange key start stop [withscores]</code></td><td>返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按分数值递减的次序排列这一点外， zrevrange 命令的其他方面和 zrange命令一样。返回指定区间内，带有分数值(可选)的有序集成员的列表。</td></tr><tr><td><code>zrevrank key member</code></td><td>返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。排名以 0 为底，也就是说， 分数值最大的成员排名为 0 。使用 zrank 命令可以获得成员按分数值递增(从小到大)排列的排名。如果成员是有序集 key 的成员，返回成员的排名。 如果成员不是有序集 key 的成员，返回 nil 。</td></tr><tr><td><code>zscore key member</code></td><td>返回有序集中，成员的分数值，以字符串形式表示。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</td></tr></tbody></table><ul><li><code>zscan key cursor [match pattern] [count count]</code><br>用于迭代有序集合中的元素（包括元素成员和元素分值）。返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</li><li><code>zinterstore  destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><br>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。返回保存到目标结果集的的成员数量。</li><li><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><br>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。返回保存到 destination 的结果集的成员数量。</li><li><code>zrevrangebyscore key max min [withscores] [limit offset count]</code><br>返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。除了成员按分数值递减的次序排列这一点外， zrevrangebyscore 命令的其他方面和 zrangebyscore 命令一样。返回指定区间内，带有分数值(可选)的有序集成员的列表。</li><li><code>zrangebyscore key min max [withscores] [limit offset count]</code><br>返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。举个例子：zrangebyscore zset (1 5   返回所有符合条件 1 &lt; score &lt;= 5 的成员，而 zrangebyscore  zset (5 (10  则返回所有符合条件 5 &lt; score &lt; 10 的成员。返回指定区间内，带有分数值(可选)的有序集成员的列表。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2020/03/07/java/%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/03/07/java/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>java异常处理</p><a id="more"></a><h3 id="Error和Exception有什么区别？"><a href="#Error和Exception有什么区别？" class="headerlink" title="Error和Exception有什么区别？"></a>Error和Exception有什么区别？</h3><p>Error类和Exception类的父类都是throwable类。<br><strong>Error</strong> 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</p><p><strong>Exception</strong>类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。Exception类分为运行时异常（Runtime Exception）和受检查的异常(Checked Exception )。  </p><p><strong>运行时异常</strong>：编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。当出现这样的异常时，总是由虚拟机接管。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常。<br><strong>受检查的异常</strong>  要么用try catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。</p><h3 id="列举一些列举常见的运行时异常"><a href="#列举一些列举常见的运行时异常" class="headerlink" title="列举一些列举常见的运行时异常"></a>列举一些列举常见的运行时异常</h3><p>运行时异常都是 RuntimeException 子类异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException - 空指针异常</span><br><span class="line">ClassCastException - 类转换异常</span><br><span class="line">IndexOutOfBoundsException - 下标越界异常</span><br><span class="line">ArithmeticException - 算术异常</span><br><span class="line">IllegalArgumentException - 非法参数异常</span><br><span class="line">NumberFormatException - 数字格式异常</span><br><span class="line">UnsupportedOperationException 操作不支持异常</span><br><span class="line">ArrayStoreException - 数据存储异常，操作数组时类型不一致</span><br><span class="line">BufferOverflowException - IO 操作时出现的缓冲区上溢异常</span><br><span class="line">NoSuchElementException - 元素不存在异常</span><br><span class="line">InputMismatchException - 输入类型不匹配异常</span><br><span class="line">SecurityException -安全异常</span><br></pre></td></tr></table></figure><h3 id="OutOfMemoryError的原因有哪些？怎么解决？"><a href="#OutOfMemoryError的原因有哪些？怎么解决？" class="headerlink" title="OutOfMemoryError的原因有哪些？怎么解决？"></a>OutOfMemoryError的原因有哪些？怎么解决？</h3><p>OutOfMemoryError 分为多种不同的错误：</p><ul><li>Java heap space<br>原因：JVM 中 heap 的最大值不满足需要<br>解决：<br>调高 heap 的最大值，-Xmx 的值调大<br>如果程序存在内存泄漏，增加 heap 空间也只是推迟该错误出现的时间而已，要检查程序是否存在内存泄漏</li></ul><ul><li>GC overhead limit exceeded<br>原因：JVM 在 GC 时，对象过多，导致内存溢出<br>解决：调整 GC 的策略，在一定比例下开始GC而不使用默认的策略，或将新代和老代设置合适的大小，可以微调存活率。如在老代 80% 时就是开始GC，并且将 -XX:SurvivorRatio（-XX:SurvivorRatio=8）和-XX:NewRatio（-XX:NewRatio=4）设置的更合理</li></ul><ul><li>Java perm space<br>原因：JVM 中 perm 的最大值不满足需要，perm 一般是在 JVM 启动时加载类进来<br>解决：调高 heap 的最大值，即 -XX:MaxPermSize 的值调大解决。如果 JVM 运行较长一段时间而不是刚启动后溢出的话，很有可能是由于运行时有类被动态加载，此时可以用 CMS 策略中的类卸载配置解决如：-XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled</li></ul><ul><li>unable to create new native thread<br>原因：当 JVM 向系统请求创建一个新线程时，系统内存不足无法创建新的 native 线程<br>解决：JVM 内存调的过大或者可利用率小于 20%，可以将 heap 及 perm 的最大值下调，并将线程栈内存 -Xss 调小，如：-Xss128k</li></ul><ul><li>Requested array size exceeds VM limit<br>原因：应用程序试图分配一个大于堆大小的数组<br>解决：<br>检查 heap 的 -Xmx 是不是设置的过小<br>heap 的 -Xmx 已经足够大，检查应用程序是不是存在 bug 计算数组的大小时存在错误，导致数组的 length 很大，从而导致申请巨大的数组</li></ul><ul><li>request XXX bytes for XXX. Out of swap space<br>原因：从 native 堆中分配内存失败，并且堆内存可能接近耗尽，操作系统配置了较小的交换区，其他进程消耗所有的内存<br>解决：检查操作系统的 swap 是不是没有设置或者设置的过小；检查是否有其他进程在消耗大量的内存，导致 JVM 内存不够分配</li></ul><h3 id="Unsupported-major-minor-version-52是什么造成的，如何解决？"><a href="#Unsupported-major-minor-version-52是什么造成的，如何解决？" class="headerlink" title="Unsupported major.minor version 52是什么造成的，如何解决？"></a>Unsupported major.minor version 52是什么造成的，如何解决？</h3><p>造成的原因是工程中存在 jar 包编译时所用的 JDK 版本高于工程 build path 中 JDK 的版本。<br>这里的 version 52 对应 JDK 版本是 1.8，将项目的 build path 中 JDK 的版本调整为高于或等于 1.8 即可。</p><h3 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后？"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后？" class="headerlink" title="try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后？"></a>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后？</h3><p>会执行，在方法返回调用者前执行。<br>注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。</p><h3 id="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><p>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：<code>try、catch、throw、throws和finally</code>。</p><ul><li>一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；</li><li>try 可能会发生异常的代码块，如果发生异常，由catch块捕获。</li><li>catch 子句紧跟在try块后面，用来指定你想要捕获的异常的类型；</li><li>throw 语句用来明确地抛出一个异常；throw 用在方法体内，表示手动抛出一个异常对象。<code>throw 异常对象;</code>  <code>throw new Exception(&quot;自定义异常&quot;);</code></li><li>throws 用在方法声明后面，声明这个方法可能会抛出类型的异常，表示出现异常的一种可能性，并不一定会发生这些异常，调用者要捕获这个异常。</li><li>finally 不论是否有异常都会执行的语句。</li><li>catch 异常捕获块，当try块发生异常时，异常对象会被catch块捕获，try块后可以紧跟一个或多个catch块。</li><li>try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</li></ul><ul><li>把各种不同的异常进行分类</li><li>每个异常都是一个对象，是 Throwable 或其子类的实例</li><li>一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用对象的方法可以捕获到这个异常并进行处理</li><li>Java 中的异常处理通过 5 个关键词实现：throw、throws、try、catch 和 finally</li><li>定义方法时，可以使用 throws 关键字抛出异常</li><li>方法体内使用 throw 抛出异常</li><li>使用 try 执行一段代码，当出现异常后，停止后续代码的执行，跳至 catch 语句块</li><li>使用 catch 来捕获指定的异常，并进行处理</li><li>finally 语句块表示的语义是在 try、catch 语句块执行结束后，最后一定会被执行</li></ul><h3 id="运行时异常与受检异常有何异同？"><a href="#运行时异常与受检异常有何异同？" class="headerlink" title="运行时异常与受检异常有何异同？"></a>运行时异常与受检异常有何异同？</h3><ul><li>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。</li><li>运行时异常，表示程序代码在运行时发生的异常，程序代码设计的合理，这类异常不会发生</li><li>受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发</li><li>Java编译器要求方法必须声明抛出可能发生未被捕获的受检异常，不要求必须声明抛出运行时异常</li></ul><h3 id="异常的设计原则有哪些？"><a href="#异常的设计原则有哪些？" class="headerlink" title="异常的设计原则有哪些？"></a>异常的设计原则有哪些？</h3><ul><li>不要将异常处理用于正常的控制流</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/2020/02/29/mysql/%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/02/29/mysql/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>索引</p><a id="more"></a><h3 id="什么是索引？什么场景使用？"><a href="#什么是索引？什么场景使用？" class="headerlink" title="什么是索引？什么场景使用？"></a>什么是索引？什么场景使用？</h3><ul><li>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</li><li>使用索引目的是加快检索表中数据</li></ul><p>使用场景：</p><ol><li>中到大数据量表适合使用索引</li><li>小数据量表，大部分情况全表扫描效率更高</li><li>特大数据量表，建立和使用索引的代价会随之增大，适合使用分区或分库</li></ol><h3 id="索引的种类有哪些？"><a href="#索引的种类有哪些？" class="headerlink" title="索引的种类有哪些？"></a>索引的种类有哪些？</h3><ul><li>普通索引：最基本的索引，没有任何约束限制。</li><li>唯一索引：和普通索引类似，但是具有唯一性约束，可以有 null</li><li>主键索引：特殊的唯一索引，不允许有 null，一张表最多一个主键索引</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li><li>全文索引：对文本的内容进行分词、搜索</li><li>覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</li></ul><h3 id="索引如何创建与删除？"><a href="#索引如何创建与删除？" class="headerlink" title="索引如何创建与删除？"></a>索引如何创建与删除？</h3><ul><li>创建单个字段索引的语法：<code>CREATE INDEX 索引名 on 表名(字段名)</code></li><li>创建联合索引的语法：<code>CREATE INDEX 索引名 on 表名(字段名1，字段名2)</code></li><li>索引命名格式一般可以这样：<code>idx_表名_字段名</code>。注意有长度限制</li><li>删除索引：<code>DROP INDEX 索引名 ON 表名</code></li></ul><p> 如：</p><ul><li>给 id 创建索引：<code>CREATE INDEX idx_t1_id on t1(id);</code></li></ul><ul><li>给 username 和 password 创建联合索引：<code>CREATE index idx_t1_username_password ON t1(username,password)</code></li></ul><p> index 替换成 unique 或 primary key，分别代表唯一索引和主键索引</p><h3 id="索引对性能有哪些影响？"><a href="#索引对性能有哪些影响？" class="headerlink" title="索引对性能有哪些影响？"></a>索引对性能有哪些影响？</h3><p> <strong>优点</strong></p><ul><li>减少数据库服务器需要扫描的数据量</li><li>帮助数据库服务器避免排序和临时表</li><li>将随机 I/O 变顺序I/O</li><li>提高查询速度</li><li>唯一索引，能保证数据的唯一性</li></ul><p> <strong>缺点</strong></p><ul><li>索引的创建和维护耗时随着数据量的增加而增加</li><li>对表中数据进行增删改时，索引也要动态维护，降低了数据的维护速度</li><li>增大磁盘占用</li></ul><h3 id="MySQL创建和使用索引的注意事项？"><a href="#MySQL创建和使用索引的注意事项？" class="headerlink" title="MySQL创建和使用索引的注意事项？"></a>MySQL创建和使用索引的注意事项？</h3><ul><li>适合创建索引的列是出现在 WHERE 或 ON 子句中的列，而不是出现在 SELECT 关键字后的列</li><li>索引列的基数越大，数据区分度越高，索引的效果越好</li><li>对字符串列进行索引，可制定一个前缀长度，节省索引空间</li><li>避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率</li><li>主键尽可能选择较短的数据类型，可减少索引的磁盘占用，提高查询效率</li><li>联合索引遵循前缀原则</li><li>LIKE 查询，%在前不到索引，可考虑使用 ElasticSearch、Lucene 等搜索引擎</li><li>MySQL 在数据量较小的情况可能会不使用索引，因为全表扫描比使用索引速度更快</li><li>关键词 or 前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到</li><li>列类型是字符串，查询时一定要给值加引号，否则索引失效</li><li>联合索引要遵从最左前缀原则，否则不会用到索引</li></ul><h3 id="Mysql索引失效的情况？"><a href="#Mysql索引失效的情况？" class="headerlink" title="Mysql索引失效的情况？"></a>Mysql索引失效的情况？</h3><ol><li>条件中有or，即使其中有条件带索引也不会使用，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。</li><li>组合索引，不是使用第一列索引，索引失效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果select * from key1 &#x3D; 1 and key2 &#x3D; 2;建立组合索引（key1，key2）;</span><br><span class="line"> select * from key1 &#x3D; 1;组合索引有效；</span><br><span class="line"> select * from key1 &#x3D; 1 and key2&#x3D; 2;组合索引有效；</span><br><span class="line"> select * from key2 &#x3D; 2;组合索引失效；不符合最左前缀原则</span><br></pre></td></tr></table></figure><ol start="3"><li>like模糊查询 “%_” 百分号在前 （后缀有%时，索引有效）。</li><li>列类型是字符串，where时一定用引号括起来，否则索引失效。</li><li>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</li><li>where条件中使用 <code>in , not in , &lt;&gt;（不等于！=）, 函数 , is null , is not null</code>。不要在索引上做任何操作（计算、函数、自动/手动类型转换）<br><code>not in可以not exists代替</code>，<code>id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替</code>。</li><li>mysql查询只使用一个索引，如果where条件中已经使用了索引，那么order by中的列不会使用索引。</li><li>索引不会包含有null值的列。</li></ol><h3 id="创建MySQL联合索引应该注意什么？"><a href="#创建MySQL联合索引应该注意什么？" class="headerlink" title="创建MySQL联合索引应该注意什么？"></a>创建MySQL联合索引应该注意什么？</h3><ul><li>联合索引要遵从最左前缀原则，否则不会用到索引</li><li>Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>如索引是 index (a,b,c)，可以支持 a 或 a,b 或 a,b,c 3种组合进行查找，但不支持 b,c 进行查找</li></ul><h3 id="列值为NULL时，查询是否会用到索引？"><a href="#列值为NULL时，查询是否会用到索引？" class="headerlink" title="列值为NULL时，查询是否会用到索引？"></a>列值为NULL时，查询是否会用到索引？</h3><p>MySQL 中存在 NULL 值的列也是走索引的</p><p>计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度</p><h3 id="以下语句是否会使用索引？"><a href="#以下语句是否会使用索引？" class="headerlink" title="以下语句是否会使用索引？"></a>以下语句是否会使用索引？</h3><p><strong>SELECT FROM user WHERE YEAR(cdate) &lt; 2007;</strong></p><p>不会，因为列涉及到运算，不会使用索引</p><h3 id="以下三条sql-如何只建一条索引？"><a href="#以下三条sql-如何只建一条索引？" class="headerlink" title="以下三条sql 如何只建一条索引？"></a>以下三条sql 如何只建一条索引？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE a&#x3D;1 AND b&#x3D;1</span><br><span class="line">WHERE b&#x3D;1</span><br><span class="line">WHERE b&#x3D;1 ORDER BY time DESC</span><br></pre></td></tr></table></figure><p>以顺序 b，a，time 建立联合索引，CREATE INDEX idx_b_a_time ON table(b,a,time)。</p><p>新 MySQL 版本会优化 WHERE 子句后面的列顺序，以匹配联合索引顺序</p>]]></content>
      
      
      <categories>
          
          <category> 索引 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2020/02/29/mysql/mysql/"/>
      <url>/2020/02/29/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<p>mysql基础整理</p><a id="more"></a><h3 id="如何创建和删除数据库？"><a href="#如何创建和删除数据库？" class="headerlink" title="如何创建和删除数据库？"></a>如何创建和删除数据库？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建数据库</span><br><span class="line">CREATE DATABASE 数据库名;</span><br><span class="line"></span><br><span class="line">删除数据库</span><br><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p><strong>第一范式（1NF）</strong><br>强调的是列的原子性，即列不能够再分成其他几列。<br>【联系人】（姓名，性别，电话） –&gt; 【联系人】（姓名，性别，家庭电话，公司电话）<br>  在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。<br><strong>第二范式（2NF）</strong><br>首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。<br><strong>第三范式（3NF）</strong><br>在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。<br>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。<br>首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ol><li>视图是一张虚拟表,本身并不包含数据,视图数据来自原表中查询的数据，原表数据的select</li><li>不需要关心表结构和筛选条件，对用户来说只是一个结果集</li><li>安全，限制到表的某行某列，数据独立，为了保障数据安全性，提高查询效率</li><li>创建视图 <code>create view &lt;视图名称&gt;[(column_list)] as select语句 with check option;</code><br>视图将我们不需要的数据过滤掉，将相关的列名用我们自定义的列名替换。视图作为一个访问接口，不管基表的表结构和表名有多复杂。如果创建视图时不明确指定视图的列名，那么列名就和定义视图的select子句中的列名完全相同；如果显式的指定视图的列名就按照指定的列名。</li><li>查看视图 <code>show create view</code> 视图一旦创建完毕，就可以像一个普通表那样使用，视图主要用来查询</li><li>视图的更改 <code>create or replace view view_name as select语句</code>;</li><li>drop删除视图 只能删除视图的定义，不影响原表。</li></ol><h3 id="MyISAM与InnoDB的区别？"><a href="#MyISAM与InnoDB的区别？" class="headerlink" title="MyISAM与InnoDB的区别？"></a>MyISAM与InnoDB的区别？</h3><ul><li>InnoDB 支持事务；MyISAM 不支持事务</li><li>InnoDB 支持行级锁；MyISAM 支持表级锁</li><li>InnoDB 支持 MVCC(多版本并发控制)；MyISAM 不支持</li><li>InnoDB 支持外键，MyISAM 不支持</li><li>InnoDB 不支持全文索引；MyISAM 支持</li><li>InnoDB 不保存表的总行数，执行 select count(*) from table 时需要全表扫描；MyISAM 用一个变量保存表的总行数，查总行数速度很快</li><li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。辅助索引需要两次查询，先查询到主键，再通过主键查询到数据。主键太大，其他索引也会很大；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的</li></ul><h3 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h3><ul><li>char(n) 定长的类型 char(10)，输入的是”abc”这三个字符时，它们占的空间一样是10个字节，包括7个空字节。当输入的字符长度超过指定的数时，char会截取超出的字符。<br>当存储char值时，MySQL是自动删除输入字符串末尾的空格。char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</li><li>varchar(n)类型用于存储可变长的，长度为n个字节的可变长度且非Unicode的字符数据。n必须是介于1和8000之间的数值，存储大小为输入数据的字节的实际长度+1/2. 比如varchar(10), 然后输入abc三个字符，那么实际存储大小为3个字节。</li></ul><h3 id="建表语句中varchar-50-中50的指是什么？"><a href="#建表语句中varchar-50-中50的指是什么？" class="headerlink" title="建表语句中varchar(50)中50的指是什么？"></a>建表语句中varchar(50)中50的指是什么？</h3><p>字段最多存放 50 个字符</p><p>如 varchar(50) 和 varchar(200) 存储 “ConstXiong” 字符串所占空间是一样的，后者在排序时会消耗更多内存</p><h3 id="int-10-中10指什么？"><a href="#int-10-中10指什么？" class="headerlink" title="int(10)中10指什么？"></a>int(10)中10指什么？</h3><p><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code>   M 默认为11</p><p>10 就是上述语句里的 M，指最大显示宽度，最大值为 255,最大显示宽度意思是，如果是 int(10)，字段存的值是 10，则，显示会自动在之前补 8 个 0，显示为 0000000010</p><p>int 类型在数据库里面存储占 4 个字节的长度</p><p>有符号的整型范围是 -2147483648 ~ 2147483647<br>无符号的整型范围是 0 ~ 4294967295</p><h3 id="drop、truncate和delete的区别是什么？"><a href="#drop、truncate和delete的区别是什么？" class="headerlink" title="drop、truncate和delete的区别是什么？"></a>drop、truncate和delete的区别是什么？</h3><ul><li>drop 整张表删除，包括数据和结构，不可回滚。</li><li>truncate table  清空表数据，不可以回滚。 truncate 只能对table；delete可以是table和view。</li><li>delete 加where条件删除一行或多行，不加where条件删除全部数据，有事务，操作可回滚。</li><li>delete 命令从一个表中删除某一行或多行数据;truncate 命令永久地从表中删除每一行数据;</li><li>drop &gt; truncate &gt; delete</li></ul><h3 id="MySQL如何获取当前日期？"><a href="#MySQL如何获取当前日期？" class="headerlink" title="MySQL如何获取当前日期？"></a>MySQL如何获取当前日期？</h3><p>select current_date();</p><h3 id="如何获取MySQL的版本？"><a href="#如何获取MySQL的版本？" class="headerlink" title="如何获取MySQL的版本？"></a>如何获取MySQL的版本？</h3><p>select version();</p><h3 id="什么是触发器，MySQL都有哪些触发器？"><a href="#什么是触发器，MySQL都有哪些触发器？" class="headerlink" title="什么是触发器，MySQL都有哪些触发器？"></a>什么是触发器，MySQL都有哪些触发器？</h3><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码</p><p>MySQL 数据库中有六种触发器：</p><ol><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ol><p>使用场景：</p><ul><li>可以通过数据库中的相关表实现级联更改</li><li>实时监控表中字段的更改做出相应处理</li></ul><p>注意：滥用会造成数据库及应用程序的维护困难</p><h3 id="MySQL显示表前-50-行"><a href="#MySQL显示表前-50-行" class="headerlink" title="MySQL显示表前 50 行"></a>MySQL显示表前 50 行</h3><p>select * from tablename limit 0,50;</p><h3 id="如何连接MySQL服务端、关闭连接？"><a href="#如何连接MySQL服务端、关闭连接？" class="headerlink" title="如何连接MySQL服务端、关闭连接？"></a>如何连接MySQL服务端、关闭连接？</h3><p>连接：使用指令<code>mysql -u -p -h -P (-u:指定用户名 -p:指定密码 -h:主机 -P:端口) </code>连接 MySQL 服务端<br>关闭：使用指令<code> exit 或 quit</code></p><h3 id="int-10-、char-16-、varchar-16-、datetime、text的意义？"><a href="#int-10-、char-16-、varchar-16-、datetime、text的意义？" class="headerlink" title="int(10)、char(16)、varchar(16)、datetime、text的意义？"></a>int(10)、char(16)、varchar(16)、datetime、text的意义？</h3><ul><li>int(10) 表示字段是 int 类型，显示长度是 10</li><li>char(16)表示字段是固定长度字符串，长度为 16</li><li>varchar(16) 表示字段是可变长度字符串，长度为 16</li><li>datetime 表示字段是时间类型</li><li>text 表示字段是字符串类型，能存储大字符串，最多存储 65535 字节数据</li></ul><h3 id="说说你知道的MySQL存储引擎"><a href="#说说你知道的MySQL存储引擎" class="headerlink" title="说说你知道的MySQL存储引擎"></a>说说你知道的MySQL存储引擎</h3><p><strong>InnoDB</strong></p><ul><li>默认事务型引擎，被广泛使用的存储引擎</li><li>数据存储在共享表空间，即多个表和索引都存储在一个表空间中，可通过配置文件修改</li><li>主键查询的性能高于其他类型的存储引擎</li><li>内部做了很多优化，如：从磁盘读取数据时会自动构建hash索引，插入数据时自动构建插入缓冲区</li><li>通过一些机制和工具支持真正的热备份</li><li>支持崩溃后的安全恢复</li><li>支持行级锁</li><li>支持外键</li></ul><p><strong>MyISAM</strong></p><ul><li>拥有全文索引、压缩、空间函数</li><li>不支持事务和行级锁、不支持崩溃后的安全恢复</li><li>表存储在两个文件：MYD 和 MYI</li><li>设计简单，某些场景下性能很好，例如获取整个表有多少条数据，性能很高</li></ul><p>其他表引擎：Archive、Blackhole、CSV、Memory</p><h3 id="Innodb引擎有什么特性？"><a href="#Innodb引擎有什么特性？" class="headerlink" title="Innodb引擎有什么特性？"></a>Innodb引擎有什么特性？</h3><ul><li>插入缓冲(insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead) </li></ul><h3 id="说一说MySQL中的锁机制"><a href="#说一说MySQL中的锁机制" class="headerlink" title="说一说MySQL中的锁机制?"></a>说一说MySQL中的锁机制?</h3><p>数据库中数据是供多用户共享访问，锁是保证数据并发访问的一致性、有效性的一种机制</p><p>锁的分类</p><p><strong>按粒度分</strong></p><ul><li>表级锁：粒度最大的一种锁，表示对当前操作的整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</li><li>行级锁：粒度最小的一种锁，表示只针对当前操作的行进行加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高</li><li>页级锁：粒度介于行级锁和表级锁中间的一种锁。开销、加锁时间和并发度界于表锁和行锁之间；会出现死锁</li></ul><p><strong>按操作分</strong></p><ul><li>读锁(共享锁)：针对同一份数据，多个读取操作可以同时进行，不互相影响</li><li>写锁(排它锁)：当前写操作没有完成前，会阻断其他写锁和读锁</li></ul><p><strong>MySQL 不同的存储引擎支持不同的锁机制</strong></p><ul><li>InnoDB 存储引擎既支持行级锁(row-level locking)，也支持表级锁，但默认情况下是采用行级锁</li><li>MyISAM 和 MEMORY 存储引擎采用的是表级锁(table-level locking)</li><li>BDB 存储引擎采用的是页面锁(page-level locking)，也支持表级锁</li></ul><h3 id="DDL和DML的区别"><a href="#DDL和DML的区别" class="headerlink" title="DDL和DML的区别"></a>DDL和DML的区别</h3><ul><li>DDL(Data Definition Language)数据定义语言,操作的单位是表 <code>create语句，drop语句，alert语句</code></li><li>DML(Data Manipulation Language)数据操纵语言，操作的单位是数据 <code>Insert 语句，delete语句，update语句</code></li><li>DML操作是可以手动控制事务的开启、提交和回滚的。DDL操作不能rollback！</li></ul><h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><ol><li>在表的列上建立索引。</li><li>用 <code>not null</code>代替<code>null</code>,设置默认值比如<code>0代替null</code>。</li><li>避免使用 <code>!= 或 &lt;&gt; </code></li><li>避免使用 <code>or，in，not in</code></li><li>用 <code>between and</code>代替 <code>in</code> ,用 <code>exists</code> 代替 <code>in </code></li><li>避免like模糊查询<code>&quot;%_&quot;</code> 百分号在前 ,避免在 where 条件中进行表达式操作。</li><li>避免函数操作。</li><li>update 语句，如果只更改1、2个字段，不要update全部字段。</li><li>索引并不是越多越好。</li><li>用具体字段代替<code> *</code></li></ol><h3 id="float，double，decimal区别"><a href="#float，double，decimal区别" class="headerlink" title="float，double，decimal区别?"></a>float，double，decimal区别?</h3><ul><li>float浮点型，含字节数为4，32bit，数值范围为<code>-3.4E38~3.4E38</code>（7个有效位） 近似值</li><li>double 双精度实型，含字节数为8，64bit数值范围<code>-1.7E308~1.7E308</code>（15个有效位）</li><li>decimal 数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）</li><li>FLOAT 类型数据可以存储至多 8 位十进制数，占 4 字节</li><li>DOUBLE 类型数据可以存储至多 18 位十进制数，占 8字节</li></ul><h3 id="说一说MySQL中的事务"><a href="#说一说MySQL中的事务" class="headerlink" title="说一说MySQL中的事务?"></a>说一说MySQL中的事务?</h3><p>事务具有四大特性（ACID）：</p><ul><li>**原子性(Atomic)**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样</li><li>**一致性(Consistency)**：在事务开始之前和事务结束以后， 数据库的完整性没有被破坏</li><li>**隔离性(Isolation)**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</li><li>**持久性(Durability)**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</li></ul><p><strong>事务控制：</strong></p><ul><li>begin 或 start transaction 显式地开启一个事务</li><li>commit 会提交事务，使已对数据库进行的所有修改成为永久性的</li><li>rollback 回滚，会结束用户的事务，并撤销正在进行的所有未提交的修改</li><li>savepoint identifier，savepoint 允许在事务中创建一个保存点，一个事务中可以有多个 savepoint</li><li>release savepoint identifier 删除一个事务的保存点，没有指定的保存点执行该语句会抛出一个异常</li><li>rollback to identifier 把事务回滚到标记点</li><li>set transaction 用来设置事务的隔离级别</li></ul><p><strong>MYSQL 事务处理的方法：</strong></p><ol><li>用 begin, rollback, commit来实现</li></ol><ul><li>begin 开始事务</li><li>rollback 事务回滚</li><li>commit 事务确认</li></ul><ol start="2"><li>直接用 set 来改变提交模式:</li></ol><p>set autocommit=0 禁止自动提交<br>set autocommit=1 开启自动提交</p><p>注意：</p><p>MySQL 的事务控制是表引擎上处理，有些引擎是不支持事务的<br>不支持事务的表上执行事务操作，MySQL不会发出提醒，也不会报错</p><h3 id="MySQL中TEXT数据类型的最大长度"><a href="#MySQL中TEXT数据类型的最大长度" class="headerlink" title="MySQL中TEXT数据类型的最大长度"></a>MySQL中TEXT数据类型的最大长度</h3><ul><li>tinytext：256 bytes</li><li>text：65,535 bytes(64kb)</li><li>mediumtext：16,777,215 bytes(16MB)</li><li>longtext：4,294,967,295 bytes(4GB)</li></ul><h3 id="MySQL中有哪些时间字段？"><a href="#MySQL中有哪些时间字段？" class="headerlink" title="MySQL中有哪些时间字段？"></a>MySQL中有哪些时间字段？</h3><p><strong>占用空间</strong></p><ul><li>datetime：8 bytes</li><li>timestamp：4 bytes</li><li>date：4 bytes</li><li>time：3 bytes</li><li>year：1 byte </li></ul><p><strong>日期格式</strong></p><ul><li>datetime：YYYY-MM-DD HH:MM:SS</li><li>timestamp：YYYY-MM-DD HH:MM:SS</li><li>date：YYYY-MM-DD         </li><li>time：HH:MM:SS            </li><li>year：YYYY     </li></ul><p><strong>最小值</strong></p><ul><li>DATETIME：1000-01-01 00:00:00    </li><li>TIMESTAMP：1970-01-01 00:00:01 UTC</li><li>DATE：1000-01-01             </li><li>TIME：-838:59:59             </li><li>YEAR：1901    </li></ul><p><strong>最大值</strong></p><ul><li>DATETIME：9999-12-31 23:59:59    </li><li>TIMESTAMP：2038-01-19 03:14:07 UTC</li><li>DATE：9999-12-31             </li><li>TIME：838:59:59              </li><li>YEAR：2125 </li></ul><p><strong>零值</strong></p><ul><li>DATETIME：0000-00-00 00:00:00</li><li>TIMESTAMP：1970-01-01 00:00:01 UTC</li><li>DATE：0000-00-00</li><li>TIME：00:00:00</li><li>YEAR：0000</li></ul><h3 id="MySQL中DATETIME和TIMESTAMP的区别"><a href="#MySQL中DATETIME和TIMESTAMP的区别" class="headerlink" title="MySQL中DATETIME和TIMESTAMP的区别"></a>MySQL中DATETIME和TIMESTAMP的区别</h3><p>存储精度都为秒</p><p>区别：</p><ul><li>DATETIME 的日期范围是 1001——9999 年；TIMESTAMP 的时间范围是 1970——2038 年</li><li>DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</li><li>DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节</li><li>DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</li></ul><h3 id="MySQL的数据类型有哪些？"><a href="#MySQL的数据类型有哪些？" class="headerlink" title="MySQL的数据类型有哪些？"></a>MySQL的数据类型有哪些？</h3><ol><li><strong>整数类型： TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</strong></li></ol><p>分别占用 1 字节、2 字节、3 字节、4 字节、8 字节；任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整数；整数类型可以被指定长度，即为显示长度，不影响存储占用空间</p><ol start="2"><li><strong>实数类型： FLOAT、DOUBLE、DECIMAL</strong></li></ol><p>DECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数；FLOAT 和 DOUBLE 有取值范围，支持使用标准的浮点进行近似计算</p><ol start="3"><li><strong>字符串类型： CHAR、VARCHAR、TEXT、BLOB</strong></li></ol><p>CHAR 是定长的，根据定义的字符串长度分配足够的空间；VARCHAR 用于存储可变长字符串；TEXT 存大文本；BLOB 存二进制数据</p><ol start="4"><li><strong>枚举类型：ENUM</strong></li></ol><p>把不重复的数据存储为一个预定义的集合，可以替代常用的字符串类型</p><ol start="5"><li><strong>日期和时间类型：YEAR、TIME、DATE、TIMESTAMP、DATETIME</strong></li></ol><p>分别占用 1 byte、3 bytes、4 bytes、4 bytes、8 bytes</p><h3 id="Mysql的SQL语句是否区分大小写？"><a href="#Mysql的SQL语句是否区分大小写？" class="headerlink" title="Mysql的SQL语句是否区分大小写？"></a>Mysql的SQL语句是否区分大小写？</h3><p>不区分，下面 sql 都是可以的，如：</p><ul><li>SELECT VERSION();</li><li>select vErSION();</li></ul><h3 id="Mysql驱动程序是什么？"><a href="#Mysql驱动程序是什么？" class="headerlink" title="Mysql驱动程序是什么？"></a>Mysql驱动程序是什么？</h3><ul><li>Mysql 提供给 Java 编程语言的驱动程序就是这样 mysql-connector-java-5.1.18.jar 包</li><li>针对不同的数据库版本，驱动程序包版本也不同</li><li>不同的编程语言，驱动程序的包形式也是不一样的</li><li>驱动程序主要帮助编程语言与 MySQL 服务端进行通信，如果连接、关闭、传输指令与数据等</li></ul><h3 id="使用过MySQL的存储过程吗？介绍一下"><a href="#使用过MySQL的存储过程吗？介绍一下" class="headerlink" title="使用过MySQL的存储过程吗？介绍一下"></a>使用过MySQL的存储过程吗？介绍一下</h3><ul><li>存储过程(Stored Procedure)是数据库中一种存储复杂程序，供外部程序调用的一种数据库对象</li><li>是一段 SQL 语句集，被编译保存在数据库中</li><li>可命名并传入参数来调用执行</li><li>可在存储过程中加入业务逻辑和流程</li><li>可在存储过程中创建表，更新数据，删除数据等</li><li>可通过把 SQL 语句封装在容易使用的单元中，简化复杂的操作</li></ul><h3 id="LIKE-后的％和-代表什么？"><a href="#LIKE-后的％和-代表什么？" class="headerlink" title="LIKE 后的％和_代表什么？"></a>LIKE 后的％和_代表什么？</h3><p>％ 代表 0 或更多字符<br>_ 代表 1 个字符</p><h3 id="与Oracle相比，Mysql有什么优势？"><a href="#与Oracle相比，Mysql有什么优势？" class="headerlink" title="与Oracle相比，Mysql有什么优势？"></a>与Oracle相比，Mysql有什么优势？</h3><ul><li>Mysql 是开源软件、无需付费</li><li>操作简单、部署方便，用户可以根据应用的需求去定制数据库</li><li>Mysql 的引擎是插件式</li></ul><h3 id="MySQL有哪些常用函数？"><a href="#MySQL有哪些常用函数？" class="headerlink" title="MySQL有哪些常用函数？"></a>MySQL有哪些常用函数？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">数值型函数</span><br><span class="line"></span><br><span class="line">ABS：计算绝对值</span><br><span class="line">SQRT：计算二次方根</span><br><span class="line">MOD：计算余数</span><br><span class="line">CEIL、CEILING：返回不小于参数的最小整数，即向上取整</span><br><span class="line">FLOOR：向下取整，返回值转化为一个 BIGINT</span><br><span class="line">RAND：生成一个 0~1 之间的随机数</span><br><span class="line">ROUND：四舍五入</span><br><span class="line">SIGN：返回参数的符号</span><br><span class="line">POW、POWER：参数次方的值</span><br><span class="line">SIN：计算正弦值</span><br><span class="line">ASIN：计算反正弦值</span><br><span class="line">COS：计算余弦值</span><br><span class="line">ACOS：计算反余弦值</span><br><span class="line">TAN：计算正切值</span><br><span class="line">ATAN：计算反正切值</span><br><span class="line">COT：计算余切值</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">字符串函数</span><br><span class="line"></span><br><span class="line">LENGTH：返回字符串的字节长度</span><br><span class="line">CONCAT：合并字符串，返回结果为连接参数产生的字符串，参数可以使一个或多个</span><br><span class="line">INSERT：替换字符串</span><br><span class="line">LOWER：将字符串中的字母转换为小写</span><br><span class="line">UPPER：将字符串中的字母转换为大写</span><br><span class="line">LEFT：从左侧字截取符串，返回字符串左边的若干个字符</span><br><span class="line">RIGHT：从右侧字截取符串，返回字符串右边的若干个字符</span><br><span class="line">TRIM：删除字符串左右两侧的空格</span><br><span class="line">REPLACE：字符串替换，返回替换后的新字符串</span><br><span class="line">SUBSTRING：截取字符串，返回从指定位置开始的指定长度的字符换</span><br><span class="line">REVERSE：字符串反转，返回与原始字符串顺序相反的字符串</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">日期和时间函数</span><br><span class="line"></span><br><span class="line">CURDATE、CURRENT_DATE：返回当前系统的日期值</span><br><span class="line">CURTIME、CURRENT_TIME：返回当前系统的时间值</span><br><span class="line">NOW、SYSDATE：返回当前系统的日期和时间值</span><br><span class="line">UNIX_TIMESTAMP：获取 UNIX 时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数</span><br><span class="line">FROM_UNIXTIME：将 UNIX 时间戳转换为时间格式</span><br><span class="line">MONTH：获取指定日期中的月份</span><br><span class="line">MONTHNAME：获取指定日期中的月份英文名称</span><br><span class="line">DAYNAME：获取指定曰期对应的星期几的英文名称</span><br><span class="line">DAYOFWEEK：获取指定日期对应的一周的索引位置值</span><br><span class="line">WEEK：获取指定日期是一年中的第几周</span><br><span class="line">DAYOFYEAR：获取指定曰期是一年中的第几天，返回值 1~366</span><br><span class="line">DAYOFMONTH：获取指定日期是一个月中是第几天，返回值 1~31</span><br><span class="line">YEAR：获取年份</span><br><span class="line">TIME_TO_SEC：将时间参数转换为秒数</span><br><span class="line">SEC_TO_TIME：将秒数转换为时间</span><br><span class="line">DATE_ADD、ADDDATE：向日期添加指定的时间间隔</span><br><span class="line">DATE_SUB、SUBDATE：向日期减去指定的时间间隔</span><br><span class="line">ADDTIME：时间加法运算，在原始时间上添加指定的时间</span><br><span class="line">SUBTIME：时间减法运算，在原始时间上减去指定的时间</span><br><span class="line">DATEDIFF：获取两个日期之间间隔，返回参数 1 减去参数 2 的值</span><br><span class="line">DATE_FORMAT：格式化指定的日期，根据参数返回指定格式的值</span><br><span class="line">WEEKDAY：获取指定日期在一周内的对应的工作日索引</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">聚合函数</span><br><span class="line"></span><br><span class="line">MAX：查询指定列的最大值</span><br><span class="line">MIN：查询指定列的最小值</span><br><span class="line">COUNT：统计查询结果的行数</span><br><span class="line">SUM：求和，返回指定列的总和</span><br><span class="line">AVG：求平均值，返回指定列数据的平均值</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">流程控制函数</span><br><span class="line"></span><br><span class="line">IF：判断是否为 true</span><br><span class="line">IFNULL：判断是否为空</span><br><span class="line">CASE：分支判断</span><br></pre></td></tr></table></figure><h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul><li>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引</li><li>InnoDB 的主键索引的叶子节点存储着行数据，主键索引非常高效</li><li>MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据</li><li>InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效</li></ul><h3 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h3><ul><li>union 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</li><li>union all 对两个结果集进行并集操作，包括重复行，不进行排序；</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2020/02/29/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2020/02/29/java/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>分布式</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2020/02/29/redis/redis/"/>
      <url>/2020/02/29/redis/redis/</url>
      
        <content type="html"><![CDATA[<p>redis整理</p><a id="more"></a><h3 id="什么是Redis？简述它的优缺点？"><a href="#什么是Redis？简述它的优缺点？" class="headerlink" title="什么是Redis？简述它的优缺点？"></a>什么是Redis？简述它的优缺点？</h3><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<br>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。<br>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。<br>另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="Redis相比memcached有哪些优势？"><a href="#Redis相比memcached有哪些优势？" class="headerlink" title="Redis相比memcached有哪些优势？"></a>Redis相比memcached有哪些优势？</h3><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ol><h3 id="Redis支持哪几种数据类型？"><a href="#Redis支持哪几种数据类型？" class="headerlink" title="Redis支持哪几种数据类型？"></a>Redis支持哪几种数据类型？</h3><p>String、List、Set、Sorted Set、hashes</p><h3 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h3><p>内存。</p><h3 id="Redis的全称是什么？"><a href="#Redis的全称是什么？" class="headerlink" title="Redis的全称是什么？"></a>Redis的全称是什么？</h3><p>Remote Dictionary Server。</p><h3 id="Redis有哪几种数据淘汰策略？"><a href="#Redis有哪几种数据淘汰策略？" class="headerlink" title="Redis有哪几种数据淘汰策略？"></a>Redis有哪几种数据淘汰策略？</h3><p><code>noeviction</code>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）<br><code>allkeys-lru</code>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br><code>volatile-lru</code>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br><code>allkeys-random</code>: 回收随机的键使得新添加的数据有空间存放。<br><code>volatile-random</code>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br><code>volatile-ttl</code>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p><h3 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h3><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p><h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p><h3 id="为什么Redis需要把所有数据放到内存中？"><a href="#为什么Redis需要把所有数据放到内存中？" class="headerlink" title="为什么Redis需要把所有数据放到内存中？"></a>为什么Redis需要把所有数据放到内存中？</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。<br>所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。<br>在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h3 id="Redis集群方案应该怎么做？都有哪些方案？"><a href="#Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis集群方案应该怎么做？都有哪些方案？"></a>Redis集群方案应该怎么做？都有哪些方案？</h3><ol><li>codis。<br>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。  </li><li>redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。  </li><li>在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</li></ol><h3 id="Redis集群方案什么情况下会导致整个集群不可用？"><a href="#Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis集群方案什么情况下会导致整个集群不可用？"></a>Redis集群方案什么情况下会导致整个集群不可用？</h3><p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p><h3 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><h3 id="Redis有哪些适合的场景？"><a href="#Redis有哪些适合的场景？" class="headerlink" title="Redis有哪些适合的场景？"></a>Redis有哪些适合的场景？</h3><h5 id="（1）会话缓存（Session-Cache）"><a href="#（1）会话缓存（Session-Cache）" class="headerlink" title="（1）会话缓存（Session Cache）"></a>（1）会话缓存（Session Cache）</h5><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？<br>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><h5 id="（2）全页缓存（FPC）"><a href="#（2）全页缓存（FPC）" class="headerlink" title="（2）全页缓存（FPC）"></a>（2）全页缓存（FPC）</h5><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。<br>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。<br>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><h5 id="（3）队列"><a href="#（3）队列" class="headerlink" title="（3）队列"></a>（3）队列</h5><p>Redis在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。<br>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><h5 id="（4）排行榜-计数器"><a href="#（4）排行榜-计数器" class="headerlink" title="（4）排行榜/计数器"></a>（4）排行榜/计数器</h5><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。<br>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：<br>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE user_scores 0 10 WITHSCORES</span><br></pre></td></tr></table></figure><h5 id="（5）发布-订阅"><a href="#（5）发布-订阅" class="headerlink" title="（5）发布/订阅"></a>（5）发布/订阅</h5><p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</p><h3 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h3 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p><h3 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；<br>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h3 id="Redis如何设置密码及验证密码？"><a href="#Redis如何设置密码及验证密码？" class="headerlink" title="Redis如何设置密码及验证密码？"></a>Redis如何设置密码及验证密码？</h3><p>设置密码：<code>config set requirepass 123456</code><br>授权密码：<code>auth 123456</code></p><h3 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h3><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><h3 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p><h3 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h3><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><h3 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h3><p>异步复制</p><h3 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h3><p>16384个。</p><h3 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h3><p>Redis集群目前无法做数据库选择，默认在0数据库。</p><h3 id="怎么测试Redis的连通性？"><a href="#怎么测试Redis的连通性？" class="headerlink" title="怎么测试Redis的连通性？"></a>怎么测试Redis的连通性？</h3><p>ping</p><h3 id="Redis中的管道有什么用？"><a href="#Redis中的管道有什么用？" class="headerlink" title="Redis中的管道有什么用？"></a>Redis中的管道有什么用？</h3><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。<br>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><h3 id="怎么理解Redis事务？"><a href="#怎么理解Redis事务？" class="headerlink" title="怎么理解Redis事务？"></a>怎么理解Redis事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h3 id="Redis事务相关的命令有哪几个？"><a href="#Redis事务相关的命令有哪几个？" class="headerlink" title="Redis事务相关的命令有哪几个？"></a>Redis事务相关的命令有哪几个？</h3><p>MULTI、EXEC、DISCARD、WATCH</p><h3 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h3><p>EXPIRE和PERSIST命令。</p><h3 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h3><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。<br>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p><h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><p>一个客户端运行了新的命令，添加了新的数据。<br>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。<br>一个新的命令被执行，等等。<br>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。<br>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h3 id="Redis-支持的数据类型"><a href="#Redis-支持的数据类型" class="headerlink" title="Redis 支持的数据类型"></a>Redis 支持的数据类型</h3><p><strong>String（字符串）</strong><br><strong>list（列表</strong>）：list 是字符串列表，按照插入顺序排序。元素可以在列表的头部（左边）或者尾部（右边）进行添加。<br><strong>hash（哈希）</strong>：Redis hash 是一个键值对（key-value）集合。Redis hash 是一个 String 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。<br><strong>set（集合）</strong>：Redis 的 set 是 String 类型的无序集合。<br><strong>zset（sorted set：有序集合</strong>）：Redis zset和 set 一样也是 String 类型元素的集合，且不允许重复的成员。不同的 zset是每个元素都会关联一个 double 类型的分数。zset 通过这个分数来为集合中所有元素进行从小到大的排序。zset的成员是唯一的，但分数（score）却可以重复。</p><h3 id="Redis有哪些常见应用场景-？"><a href="#Redis有哪些常见应用场景-？" class="headerlink" title="Redis有哪些常见应用场景 ？"></a>Redis有哪些常见应用场景 ？</h3><p><strong>热点数据缓存</strong>：由于 Redis 访问速度块、支持的数据类型比较丰富，所以 Redis 很适合用来存储热点数据<br><strong>限时业务实现</strong>：expire 命令设置 key 的生存时间，到时间后自动删除 key。收集验证码、优惠活动等业务场景。<br><strong>计数器实现</strong>：incrby 命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成。比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。<br><strong>排行榜实现</strong>：借助 SortedSet 进行热点数据的排序。例如：下单量最多的用户排行榜，最热门的帖子（回复最多）等。<br><strong>分布式锁实现</strong>：利用 Redis 的 setnx 命令进行。<br><strong>队列机制实现</strong>：Redis 有 list push 和 list pop 这样的命令，所以能够很方便的执行队列操作。</p><h3 id="缓存三大问题：缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存三大问题：缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存三大问题：缓存雪崩、缓存击穿、缓存穿透"></a>缓存三大问题：缓存雪崩、缓存击穿、缓存穿透</h3><h3 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h3><p>如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/02.jpg" alt="什么是缓存雪崩"></p><p>我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。</p><p>如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。</p><p>这就是缓存雪崩：<code>Redis挂掉了，请求全部走数据库</code>。</p><p>缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！</p><h5 id="如何解决缓存雪崩？"><a href="#如何解决缓存雪崩？" class="headerlink" title="如何解决缓存雪崩？"></a>如何解决缓存雪崩？</h5><p>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。首先强调的是缓存雪崩对底层系统的冲击非常可怕。</p><h5 id="场景解决方案"><a href="#场景解决方案" class="headerlink" title="场景解决方案"></a>场景解决方案</h5><ul><li>大多数设计者考虑“加锁”或者“队列”方式保证缓存的单线程（进程）写，从而避免大量并发请求落到底层存储系统上。比如某个Key只允许一个线程查询和写缓存，其他线程等待。</li><li>有一个简单处理方案，就是将缓存失效时间分散开，比如我们在原有失效时间上增加一个随机值，如1~5分钟随机，尽量让缓存不要同时失效，从而尽量避免缓存雪崩。</li><li>实现高可用架构，尽量避免Redis挂掉的情况。</li><li>Redis挂掉后采用本地缓存和限流策略，避免DB直接被干掉。</li><li>Redis持久化，Redis挂掉后，重启后可以自动从磁盘中加载数据，能快速回复数据。</li></ul><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>对于一些设置了过期时间的Key，当这些Key在被某些时间点大量高并发访问时，这个时候就需要考虑缓存被“击穿”的问题，这个问题和雪崩区别在于只针对某个Key的缓存，而缓存雪崩是针对多个Key的缓存。简单来说，就是当某个时间点某个Key被高并发访问，此时恰好缓存过期，那么所有请求都落到DB上了，这是瞬时的大并发就有可能导致将DB压垮，这种现象就叫缓存击穿。</p><h5 id="如何解决缓存击穿？"><a href="#如何解决缓存击穿？" class="headerlink" title="如何解决缓存击穿？"></a>如何解决缓存击穿？</h5><h5 id="方案一：后台刷新"><a href="#方案一：后台刷新" class="headerlink" title="方案一：后台刷新"></a>方案一：后台刷新</h5><p>后台定义一个job(定时任务)专门主动更新缓存数据.比如,一个缓存中的数据过期时间是30分钟,那么job每隔29分钟定时刷新数据(将从数据库中查到的数据更新到缓存中).</p><p>这种方案比较容易理解，但会增加系统复杂度。比较适合那些 key 相对固定,cache 粒度较大的业务，key 比较分散的则不太适合，实现起来也比较复杂。</p><h5 id="方案二：检查更新"><a href="#方案二：检查更新" class="headerlink" title="方案二：检查更新"></a>方案二：检查更新</h5><p>将缓存key的过期时间(绝对时间)一起保存到缓存中(可以拼接,可以添加新字段,可以采用单独的key保存..不管用什么方式,只要两者建立好关联关系就行).在每次执行get操作后,都将get出来的缓存过期时间与当前系统时间做一个对比,如果缓存过期时间-当前系统时间&lt;=1分钟(自定义的一个值),则主动更新缓存.这样就能保证缓存中的数据始终是最新的(和方案一一样,让数据不过期.)</p><p>这种方案在特殊情况下也会有问题。假设缓存过期时间是12:00，而 11:59到 12:00这 1 分钟时间里恰好没有 get 请求过来，又恰好请求都在 11:30 分的时候高并发过来，那就悲剧了。这种情况比较极端，但并不是没有可能。因为“高并发”也可能是阶段性在某个时间点爆发。</p><h5 id="方案三：分级缓存"><a href="#方案三：分级缓存" class="headerlink" title="方案三：分级缓存"></a>方案三：分级缓存</h5><p>采用 L1 (一级缓存)和 L2(二级缓存) 缓存方式，L1 缓存失效时间短，L2 缓存失效时间长。请求优先从 L1 缓存获取数据，如果 L1缓存未命中则加锁，只有 1 个线程获取到锁,这个线程再从数据库中读取数据并将数据再更新到到 L1 缓存和 L2 缓存中，而其他线程依旧从 L2 缓存获取数据并返回。</p><p>这种方式，主要是通过避免缓存同时失效并结合锁机制实现。所以，当数据更新时，只能淘汰 L1 缓存，不能同时将 L1 和 L2 中的缓存同时淘汰。L2 缓存中可能会存在脏数据，需要业务能够容忍这种短时间的不一致。而且，这种方案可能会造成额外的缓存空间浪费。</p><h5 id="方案四：加互斥锁"><a href="#方案四：加互斥锁" class="headerlink" title="方案四：加互斥锁"></a>方案四：加互斥锁</h5><p>这种方案是通过异步方式 去获取缓存过程中，其他key 处于等待现象，必须等待第一个构建完缓存之后，释放锁，其他人才能通过该key才能访问数据;</p><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</p><p><code>请求的数据在缓存大量不命中，导致请求走数据库</code>。</p><p>缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！</p><h5 id="如何解决缓存穿透？"><a href="#如何解决缓存穿透？" class="headerlink" title="如何解决缓存穿透？"></a>如何解决缓存穿透？</h5><p>解决缓存穿透也有两种方案：</p><p>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！</p><p>当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。</p><p>这种情况我们一般会将空对象设置一个较短的过期时间。</p><h3 id="Redis的2种持久化方式？"><a href="#Redis的2种持久化方式？" class="headerlink" title="Redis的2种持久化方式？"></a>Redis的2种持久化方式？</h3><p>Redis的数据是保存在内存中, 如果没有配置持久化，redis重启后数据就全丢失了，持久化是将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。<br>Redis 提供了两种不同级别的持久化方式：RDB和AOF,可以通过修改redis.conf来进行配置<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/redis%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="redis持久化"><br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/redis%E6%8C%81%E4%B9%85%E5%8C%962.png" alt="redis持久化"></p><h5 id="RDB持久化方式"><a href="#RDB持久化方式" class="headerlink" title="RDB持久化方式"></a>RDB持久化方式</h5><p>将内存中的数据dump到磁盘上进行持久化。在指定的时间间隔能对你的数据进行快照存储。<br>在RDB方式下，有两种选择，一种是手动执行持久化数据命令来让redis进行一次数据快照，另一种则是根据你所配置的配置文件的策略，达到策略的某些条件时来自动持久化数据。而手动执行持久化命令，有两种选择，save命令和bgsave命令。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/dump.png" alt="redis持久化"><br>save操作在Redis主线程中工作，因此会阻塞其他请求操作，应该避免使用。<br>（默认下，持久化到dump.rdb文件，并且在redis重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB的快照文件，同步到内存中的 时间是20-30秒）<br>bgsave则是调用fork,产生子进程，父进程继续处理请求。子进程将数据写入临时文件，并在写完后，替换原有的.rdb文件。fork发生时，父子进程内存共享，所以为了不影响子进程做数据快照，在这期间修改的数据，将会被复制一份，而不进共享内存。所以说，RDB所持久化的数据，是Fork发生时的数据。在这样的条件下进行持久化数据，如果因为某些情况宕机，则会丢失一段时间的数据。如果你的实际情况对数据丢失没那么敏感，丢失的也可以从传统数据库中获取或者说丢失部分也无所谓，那么你可以选择RDB持久化方式。<br>再谈一下配置文件的策略，实际上它和bgsave命令持久化原理是相同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">dave 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>这是配置文件默认的策略，他们之间的关系是或，每隔900秒，在这期间变化了至少一个键值，做快照。或者每三百秒，变化了十个键值做快照。或者每六十秒，变化了至少一万个键值，做快照。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/rdb%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="redis持久化"></p><h5 id="AOF持久化方式"><a href="#AOF持久化方式" class="headerlink" title="AOF持久化方式"></a>AOF持久化方式</h5><p>append only file 操作日志以追加的方式写入文件。记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p><p>配置文件中的appendonly修改为yes。开启AOF持久化后，你所执行的每一条指令，都会被记录到appendonly.aof文件中。但事实上，并不会立即将命令写入到硬盘文件中，而是写入到硬盘缓存，在接下来的策略中，配置多久来从硬盘缓存写入到硬盘文件。所以在一定程度一定条件下，还是会有数据丢失，不过你可以大大减少数据损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># appendfsync always</span><br><span class="line"> appendfsync everysec</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure><p>这里是配置AOF持久化的策略。redis默认使用everysec，就是说每秒持久化一次，而always则是每次操作都会立即写入aof文件中。而no则是不主动进行同步操作，是默认30s一次。当然always一定是效率最低的，个人认为everysec就够用了，数据安全性能又高。<br>Redis也允许我们同时使用两种方式，再重启redis后会从aof中恢复数据，因为aof比rdb数据损失小嘛。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/aof%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="RDB 持久化"></p><h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。<br>RDB每次进行快照方式会重新记录整个数据集的所有信息。RDB在恢复数据时更快，可以最大化redis性能，子进程对父进程无任何性能影响。</p><p>AOF有序的记录了redis的命令操作。意外情况下数据丢失甚少。他不断地对aof文件添加操作日志记录，你可能会说，这样的文件得多么庞大呀。是的，的确会变得庞大，但redis会有优化的策略，比如你对一个key1键的操作，set key1 001 ,  set key1 002, set key1 003。那优化的结果就是将前两条去掉咯，那具体优化的配置在配置文件中对应的是 前者是指超过上一次aof重写aof文件大小的百分之多少，会再次优化，如果没有重写过，则以启动时为主。后者是限制了允许重写的最小aof文件大小。bgrewriteaof命令是手动重写命令，会fork子进程，在临时文件中重建数据库状态，对原aof无任何影响，当重建旧的状态后，也会把fork发生后的一段时间内的数据一并追加到临时文件，最后替换原有aof文件，新的命令继续向新的aof文件中追加。<br>默认为RDB方式持久化。<br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/03.png" alt="RDB 持久化"><br><img src= "https://cdn.lianjinquan.com/img/img/loading.gif" data-lazy-src="/images/04.jpg" alt="AOF 持久化"></p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>RDB 优点</strong><br>RDB 是紧凑的二进制文件，比较适合备份，全量复制等场景。<br>RDB 恢复数据远快于 AOF。<br><strong>RDB 缺点</strong><br>RDB 无法实现实时或者秒级持久化；<br>新老版本无法兼容RDB 格式。</p><p><strong>AOF 优点</strong><br>可以更好地保护数据不丢失；<br>appen-only 模式写入性能比较高；<br>适合做灾难性的误删除紧急恢复。<br><strong>AOF 缺点</strong><br>对于同一份文件，AOF 文件要比 RDB 快照大；<br>AOF 开启后，会对写的 QPS 有所影响，相对于 RDB 来说 写 QPS 要下降；<br>数据库恢复比较慢， 不合适做冷备。<br>其实基本上都不会是单独使用每一种类解决持久化的。因为都存在问题。</p><h3 id="Redis-淘汰策略有哪些？-内存满了怎么办"><a href="#Redis-淘汰策略有哪些？-内存满了怎么办" class="headerlink" title="Redis 淘汰策略有哪些？(内存满了怎么办)"></a>Redis 淘汰策略有哪些？(内存满了怎么办)</h3><p>Redis 可以看作是一个内存数据库，通过 Maxmemory 指令配置 Redis 的数据集使用指定量的内存。设置 Maxmemory 为 0，则表示无限制。<br>当内存使用达到 Maxmemory 极限时，需要使用某种淘汰算法来决定清理掉哪些数据，以保证新数据的存入。<br>Redis 的缓存淘汰策略有：</p><ol><li>noeviction：当内存使用达到上限，所有需要申请内存的命令都会异常报错。</li><li>allkeys-lru：先试图移除一部分最近未使用的 key。</li><li>volatile-lru：淘汰一部分最近使用较少的（LRC），但只限于过期设置键。</li><li>allkeys-random：随机淘汰某一个键。</li><li>volatile-random：淘汰任意键，但只限于有过期设置的驱逐键。</li><li>volatile-ttl：优先移除具有更早失效时间的 key。</li></ol><h5 id="Redis内存满了，一般采用三种方式"><a href="#Redis内存满了，一般采用三种方式" class="headerlink" title="Redis内存满了，一般采用三种方式"></a>Redis内存满了，一般采用三种方式</h5><ol><li>增加内存（治根不治本，土豪另说）。</li><li>使用内存淘汰策略</li><li>Redis集群</li></ol><h3 id="Redis-为什么设计成单线程的？"><a href="#Redis-为什么设计成单线程的？" class="headerlink" title="Redis 为什么设计成单线程的？"></a>Redis 为什么设计成单线程的？</h3><p>单线程，这里的单线程指的是 Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><h5 id="Redis-为什么设计成单线程的？-1"><a href="#Redis-为什么设计成单线程的？-1" class="headerlink" title="Redis 为什么设计成单线程的？"></a>Redis 为什么设计成单线程的？</h5><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程，避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO，内部采用 epoll，epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，避免 IO 代价。<br>为何单线程的 Redis 却能支撑高并发？</li></ol><h3 id="Redis-集群架构模式有哪几种？"><a href="#Redis-集群架构模式有哪几种？" class="headerlink" title="Redis 集群架构模式有哪几种？"></a>Redis 集群架构模式有哪几种？</h3><ul><li>Redis 单节点单机器部署</li><li>Redis 主从节点部署</li><li>Redis Sentinel（哨兵）模式部署</li><li>Redis 集群模式</li></ul><h3 id="使用Redis-怎么实现分布式锁？"><a href="#使用Redis-怎么实现分布式锁？" class="headerlink" title="使用Redis 怎么实现分布式锁？"></a>使用Redis 怎么实现分布式锁？</h3><h5 id="简单方案："><a href="#简单方案：" class="headerlink" title="简单方案："></a>简单方案：</h5><p>最简单的方法是使用 setnx 命令，set not exist 设置不存在key。释放锁的最简单方式是执行 del 指令。</p><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>锁超时：如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住（死锁），别的线程再也别想进来。</p><h5 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h5><p>setnx 没办法设置超时时间，如果利用 expire来设置超时时间，那么这两步操作不是原子性操作。设置过期时间是避免锁一直不释放或者释放失败的问题。</p><p>利用 set 指令增加了可选参数方式来替代 setnx。set 指令可以设置超时时间。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范</title>
      <link href="/2020/01/14/java/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2020/01/14/java/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>代码规范</p><a id="more"></a><p><a href="http://cdn.lianjinquan.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E6%A8%A1%E6%9D%BF.pdf">IDEA自定义快捷模板</a><br><a href="http://cdn.lianjinquan.com/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-%E5%8D%8E%E5%B1%B1%E7%89%88.pdf">阿里巴巴Java开发手册-华山版</a><br><a href="http://cdn.lianjinquan.com/%E6%B5%A6%E5%8F%91.pdf">浦发银行考题汇编</a><br>类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 运费维护</span><br><span class="line">* @ClassName CostTypeController</span><br><span class="line">* @Author gujt</span><br><span class="line">* @Date 2019&#x2F;12&#x2F;24 10:08</span><br><span class="line">* @Version 1.0</span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @program: AppOrderController</span><br><span class="line"> * @description: 委托单</span><br><span class="line"> * @author: gujianting</span><br><span class="line"> * @create: 2019&#x2F;6&#x2F;11 13:29</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Api(value &#x3D; &quot;APP接口:委托单&quot;, tags &#x3D; &quot;APP接口:委托单&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@Controller(&quot;appOrderController&quot;)</span><br><span class="line">@RequestMapping(&quot;&#x2F;order&#x2F;api&#x2F;app&#x2F;om&#x2F;order&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">@CrossOrigin(&quot;*&quot;)</span><br><span class="line">public class AppOrderController extends BasController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value &#x3D; &quot;货主委托单列表&quot;)</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;list&quot;)</span><br><span class="line">    public Message listOrders(@ModelAttribute @RequestBody OrderListParam orderParam) &#123;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value &#x3D; &quot;货主&#x2F;承运商委托单详情&quot;, position &#x3D; 6)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;orderId&quot;, value &#x3D; &quot;委托单Id&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;, paramType &#x3D; &quot;query&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiResponses(&#123;</span><br><span class="line">            @ApiResponse(code &#x3D; 200, message &#x3D;&quot;成功&quot;,response &#x3D; OrderVO.class)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;orderDetailInfo&quot;)</span><br><span class="line">    public Message orderDetailInfo(Long orderId) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;Admin登录&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;loginName&quot;,value&#x3D;&quot;登录账号&quot;,required&#x3D;true,dataType&#x3D;&quot;String&quot;,paramType&#x3D;&quot;query&quot;),</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;password&quot;,value&#x3D;&quot;密码&quot;,required&#x3D;false,dataType&#x3D;&quot;String&quot;,paramType&#x3D;&quot;query&quot;),</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;smsCode&quot;,value&#x3D;&quot;短信验证码&quot;,required&#x3D;false,dataType&#x3D;&quot;String&quot;,paramType&#x3D;&quot;query&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiResponses(&#123;</span><br><span class="line">            @ApiResponse(code&#x3D;200,message&#x3D;&quot;ReponseResult-&gt;&#123;code: \&quot;状态码\&quot;,data: \&quot;登录成功后tocken值\&quot;&#125;&quot;),</span><br><span class="line">            @ApiResponse(code&#x3D;4001,message&#x3D;&quot;登录账号不能为空&#x2F;请输入短信验证码或密码&quot;),</span><br><span class="line">            @ApiResponse(code&#x3D;4003,message&#x3D;&quot;账号不存在，请注册&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(value &#x3D; &quot;login&quot;)</span><br><span class="line">    public Message login(String loginName, String password,String smsCode,HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 费用类型 Service接口</span><br><span class="line">* @author lianjinquan</span><br><span class="line">* @date 2019-12-24 11:43:30</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface CostTypeService extends IService&lt;CostType&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 费用类型参数</span><br><span class="line">* @author lainjinquan</span><br><span class="line">* @date 2019-12-24 11:43:30</span><br><span class="line">*&#x2F;</span><br><span class="line">@Data</span><br><span class="line">@ApiModel(value &#x3D; &quot;费用类型参数类&quot;)</span><br><span class="line">public class CostTypeParam extends BaseParam &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import com.gillion.order.api.entity.om.Order;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @description 用类型VO类</span><br><span class="line">*</span><br><span class="line">* @author lainjinquan</span><br><span class="line">* @email lianjinquan@tankbang.com</span><br><span class="line">* @date 2019-12-24 11:43:30</span><br><span class="line">*&#x2F;</span><br><span class="line">@ApiModel(value &#x3D; &quot;费用类型VO类&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class CostTypeVO implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;主键&quot;)</span><br><span class="line">    private Long orderId;</span><br><span class="line">    @JsonFormat(timezone &#x3D; &quot;GMT+8&quot;, pattern &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd HH:mm:ss&quot;)</span><br><span class="line">    @ApiModelProperty(&quot;下单时间&quot;)</span><br><span class="line">    private Date createTime;</span><br><span class="line">    @JsonFormat(timezone &#x3D; &quot;GMT+8&quot;,pattern &#x3D; &quot;MM&#x2F;dd&quot;)</span><br><span class="line">    @ApiModelProperty(&quot;期望（提&#x2F;卸）货开始日期&quot;)</span><br><span class="line">    private Date startTime;</span><br><span class="line">    @ApiModelProperty(&quot;委托单数量&quot;)</span><br><span class="line">    private BigDecimal totalWeight;</span><br><span class="line">    @ApiModelProperty(&quot;货主委托单状态 0.未下单 1.待运输 2.运输中  3. 已完成 4. 已退回&quot;)</span><br><span class="line">    private Integer orderStatus;</span><br><span class="line">    @ApiModelProperty(&quot;运单列表&quot;)</span><br><span class="line">    private List&lt;WaybillListVO&gt; waybillListVOList;</span><br><span class="line">    @ApiModelProperty(&quot;委托单合同&quot;)</span><br><span class="line">    private OrderContractVO orderContract;</span><br><span class="line"></span><br><span class="line">    public static Order convertToOrder(CarrierOrderVO orderVO) &#123;</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        BeanUtils.copyProperties(orderVO, order);</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static CarrierOrderVO convertFor(Order order) &#123;</span><br><span class="line">        CarrierOrderVO orderVO &#x3D; new CarrierOrderVO();</span><br><span class="line">        BeanUtils.copyProperties(order, orderVO);</span><br><span class="line">        orderVO.setCreateTimePC(order.getCreateTime());</span><br><span class="line">        return orderVO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.baomidou.mybatisplus.core.metadata.IPage;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import org.apache.ibatis.annotations.Param;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 费用类型 Mapper接口</span><br><span class="line">* @author lainjinquan</span><br><span class="line">* @date 2019-12-24 11:43:30</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface CostTypeMapper extends BaseMapper&lt;CostType&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param param</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    IPage selectPageBindVehicle(Page page, @Param(&quot;param&quot;) VehicleDriverPageDaoParam param);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除</span><br><span class="line">     * @param orderId</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void deleteOrderFileOss(@Param(&quot;orderId&quot;) Long orderId);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *查询列表</span><br><span class="line">     * @param userId</span><br><span class="line">     * @param platform</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;WidgetVO&gt; widgetList(@Param(&quot;userId&quot;) String userId, @Param(&quot;platform&quot;) String platform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle</title>
      <link href="/2020/01/14/oracle/oracle/"/>
      <url>/2020/01/14/oracle/oracle/</url>
      
        <content type="html"><![CDATA[<p>Oracle</p><a id="more"></a><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><h5 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create sequence HPAY.SEQ_SUPPORT_EMAIL_CONFIG  </span><br><span class="line">minvalue 1  </span><br><span class="line">maxvalue 999999999999999999999999999  </span><br><span class="line">start with 1  </span><br><span class="line">increment by 1  </span><br><span class="line">cache 20  </span><br><span class="line">cycle  </span><br><span class="line">order;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minvalue  最小值</span><br><span class="line">maxvalue 999  最大值</span><br><span class="line">start with 1  从1开始计数，数值可变</span><br><span class="line">increment by 1  每次加1，数值可变</span><br><span class="line">nocycle  一直累加，不循环；</span><br><span class="line">cycle 达到最大值后，将从头开始累加</span><br><span class="line">nocache 不建缓冲区。   如果建立cache那么系统将自动读取cache值个seq，这样会加快运行速度；如果在单机中使用cache，或者oracle死了，那么下次读取的seq值将不连贯，所以不建议使用cache。</span><br></pre></td></tr></table></figure><h5 id="修改序列"><a href="#修改序列" class="headerlink" title="修改序列"></a>修改序列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alter sequence student_id   </span><br><span class="line">minvalue 1     </span><br><span class="line">maxvalue 99999999    </span><br><span class="line">start with 10     </span><br><span class="line">increment by 1    </span><br><span class="line">cycle     </span><br><span class="line">nocache</span><br></pre></td></tr></table></figure><h5 id="删除序列"><a href="#删除序列" class="headerlink" title="删除序列"></a>删除序列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop sequence xxxx</span><br></pre></td></tr></table></figure><h5 id="Nextval"><a href="#Nextval" class="headerlink" title="Nextval"></a>Nextval</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SEQ_ACTIVITY_TERMINAL_INFO_ID.Nextval from dual;</span><br></pre></td></tr></table></figure><h5 id="Currval"><a href="#Currval" class="headerlink" title="Currval"></a>Currval</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SEQ_ACTIVITY_TERMINAL_INFO_ID.Currval from dual;</span><br></pre></td></tr></table></figure><h5 id="rowid和rownum"><a href="#rowid和rownum" class="headerlink" title="rowid和rownum"></a>rowid和rownum</h5><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h5 id="to-date"><a href="#to-date" class="headerlink" title="to_date()"></a>to_date()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--2019&#x2F;8&#x2F;17 21:15:37  </span><br><span class="line">select to_date(&#39;2019-08-17 21:15:37&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;) from dual;</span><br><span class="line"></span><br><span class="line">-- yyyy 四位年份  2019  </span><br><span class="line">-- HH 小时，按12小时计   </span><br><span class="line">-- HH24 小时，按24小时计  </span><br><span class="line">-- mi 分   </span><br><span class="line">-- ss 秒  </span><br><span class="line">-- mm 月</span><br></pre></td></tr></table></figure><h5 id="to-char"><a href="#to-char" class="headerlink" title="to_char()"></a>to_char()</h5><ol><li>用作日期转换：to_char(date,’格式’);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--2019-08-09 09:26:41  </span><br><span class="line">select to_char(sysdate,&#39;yyyy-MM-dd HH24:mi:ss&#39;) from dual;  </span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--2019&#x2F;8&#x2F;9 9:27:31  </span><br><span class="line">select sysdate from dual;</span><br></pre></td></tr></table></figure><ol start="2"><li>处理数字：</li><li>to_char(salary,’$99,99’);</li><li>用于进制转换：将10进制转换为16进制；</li></ol><h5 id="decode"><a href="#decode" class="headerlink" title="decode()"></a>decode()</h5><h5 id="nvl"><a href="#nvl" class="headerlink" title="nvl()"></a>nvl()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVL(expr1,expr2)  </span><br><span class="line">如果expr1为空，则显示expr2，否则显示expr1</span><br></pre></td></tr></table></figure><h5 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h5><p>字符串截取函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　格式1： substr(string string, int a, int b);  </span><br><span class="line">　　格式2： substr(string string, int a) ;  </span><br><span class="line">解释：  </span><br><span class="line">    格式1：  </span><br><span class="line">        1、string 需要截取的字符串   </span><br><span class="line">        2、a 截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）  </span><br><span class="line">        3、b 要截取的字符串的长度  </span><br><span class="line">    格式2：  </span><br><span class="line">        1、string 需要截取的字符串  </span><br><span class="line">        2、a 可以理解为从第a个字符开始截取后面所有的字符串。</span><br></pre></td></tr></table></figure><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><h5 id="is-null"><a href="#is-null" class="headerlink" title="is null"></a>is null</h5><h5 id="is-not-null"><a href="#is-not-null" class="headerlink" title="is not null"></a>is not null</h5><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><h5 id="union-all"><a href="#union-all" class="headerlink" title="union all"></a>union all</h5>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle概述</title>
      <link href="/2020/01/14/oracle/oracle%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/01/14/oracle/oracle%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>Oracle概述</p><a id="more"></a><h3 id="关系型数据库-SQLite、Oracle、mysql"><a href="#关系型数据库-SQLite、Oracle、mysql" class="headerlink" title="关系型数据库 SQLite、Oracle、mysql"></a>关系型数据库 SQLite、Oracle、mysql</h3><p><strong>特性</strong></p><ol><li>关系型数据库，是指采用了关系模型来组织数据的数据库；</li><li>关系型数据库的最大特点就是事务的一致性；</li><li>简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</li></ol><p><strong>优点</strong></p><ol><li>容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</li><li>使用方便：通用的SQL语言使得操作关系型数据库非常方便；</li><li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；</li><li>支持SQL，可用于复杂的查询。</li></ol><p><strong>缺点</strong></p><ol><li>为了维护一致性所付出的巨大代价就是其读写性能比较差；</li><li>固定的表结构；</li><li>高并发读写需求；</li><li>海量数据的高效率读写；</li></ol><h3 id="非关系型数据库MongoDb、redis、HBase"><a href="#非关系型数据库MongoDb、redis、HBase" class="headerlink" title="非关系型数据库MongoDb、redis、HBase"></a>非关系型数据库MongoDb、redis、HBase</h3><p><strong>特性</strong></p><ol><li>使用键值对存储数据；</li><li>分布式；</li><li>一般不支持ACID特性(数据库事务必须具备ACID特性，ACID是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性。)；</li><li>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</li></ol><p><strong>优点</strong></p><ol><li>无需经过sql层的解析，读写性能很高；</li><li>基于键值对，数据没有耦合性，容易扩展；</li><li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，而关系型数据库则只支持基础类型。</li></ol><p><strong>缺点</strong></p><ol><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理，附加功能bi和报表等支持也不好；</li></ol><p>数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库。</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库，是指采用了关系模型来组织数据的数据库。关系模型是在1970年由IBM的研究员E.F.Codd博士首先提出的，在之后的几十年中，关系模型的概念得到了充分的发展并逐渐成为主流数据库结构的主流模型。简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。<br>关系模型中常用的概念：<br>    关系：可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名<br>    元组：可以理解为二维表中的一行，在数据库中经常被称为记录<br>    属性：可以理解为二维表中的一列，在数据库中经常被称为字段<br>    域：属性的取值范围，也就是数据库中某一列的取值限制<br>    关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成<br>    关系模式：指对关系的描述。其格式为：关系名(属性1，属性2， … … ，属性N)，在数据库中成为表结构</p><p>关系型数据库的优点：<br>    容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解<br>    使用方便：通用的SQL语言使得操作关系型数据库非常方便<br>    易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</p><p>关系型数据库瓶颈<br>  1).高并发读写需求<br>    网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈<br>  2).海量数据的高效率读写<br>    网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的<br>  3).高扩展性和可用性<br>    在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移。</p><p>对网站来说，关系型数据库的很多特性不再需要了：<br>  事务一致性: 关系型数据库在对事物一致性的维护中有很大的开销，而现在很多web2.0系统对事物的读写一致性都不高<br>  读写实时性: 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比如发一条消息之后，过几秒乃至十几秒之后才看到这条动态是完全可以接受的<br>  复杂SQL，特别是多表关联查询: 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型的网站（SNS，专指社交网络服务，包括了社交软件和社交网站。），从需求以及产品阶级角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能极大的弱化了</p><p>    在关系型数据库中，导致性能欠佳的最主要原因是多表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询。为了保证数据库的ACID特性，我们必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。每个元组字段的组成都是一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于标语表之间进行链接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。</p><p>二、NoSQL<br>    NoSQL一词首先是Carlo Strozzi在1998年提出来的，指的是他开发的一个没有SQL功能，轻量级的，开源的关系型数据库。这个定义跟我们现在对NoSQL的定义有很大的区别，它确确实实字如其名，指的就是“没有SQL”的数据库。但是NoSQL的发展慢慢偏离了初衷，我们要的不是“no sql”，而是“no relational”，也就是我们现在常说的非关系型数据库了。<br>    2009年初，Johan Oskarsson举办了一场关于开源分布式数据库的讨论，Eric Evans在这次讨论中再次提出了NoSQL一词，用于指代那些非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。Eric Evans使用NoSQL这个词，并不是因为字面上的“没有SQL”的意思，他只是觉得很多经典的关系型数据库名字都叫“**SQL”,所以为了表示跟这些关系型数据库在定位上的截然不同，就是用了“NoSQL“一词。<br>注：数据库事务必须具备ACID特性，ACID是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性。<br>    非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。但非关系型数据库由于很少的约束，他也不能够提供像SQL所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数据库显的更为合适。</p><p>2-1.非关系型数据库分类<br>    由于非关系型数据库本身天然的多样性，以及出现的时间较短，因此，不想关系型数据库，有几种数据库能够一统江山，非关系型数据库非常多，并且大部分都是开源的。<br>    这些数据库中，其实实现大部分都比较简单，除了一些共性外，很大一部分都是针对某些特定的应用需求出现的，因此，对于该类应用，具有极高的性能。依据结构化方法以及应用场合的不同，主要分为以下几类：<br>    1).面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表<br>    2).面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB<br>    3).面向可扩展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化<br>三. 关系型数据库  V.S.  非关系型数据库<br>    关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。<br>    但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，用户A看到的内容和用户B看到同一用户C内容更新不一致是可以容忍的，或者说，两个人看到同一好友的数据更新的时间差那么几秒是可以容忍的，因此，关系型数据库的最大特点在这里已经无用武之地，起码不是那么重要了。<br>    相反地，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极高，关系型数据库已经无法应付(在读方面，传统上为了克服关系型数据库缺陷，提高性能，都是增加一级memcache来静态化网页，而在SNS中，变化太快，memchache已经无能为力了)，因此，必须用新的一种数据结构存储来代替关系数据库。<br>    关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。<br>    于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。<br>    必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库这员老将。</p><hr><p>oracle与mysql的区别<br>一、并发性<br>  并发性是数据库最重要的特性，但并发涉及到资源的获取、共享与锁定。<br>    mysql：mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。<br>    oracle：oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。</p><p>二、一致性<br>    oracle：oracle支持serializable的隔离级别，可以实现最高级别的读一致性。每个session提交后其他session才能看到提交的更改。oracle通过在undo表空间中构造多版本数据块来实现读一致性，每个session查询时，如果对应的数据块发生变化，oracle会在undo表空间中为这个session构造它查询时的旧的数据块。<br>    mysql：mysql没有类似oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时，要加上排它锁，其他session无法访问数据。</p><p>三、事务<br>    oracle很早就完全支持事务。<br>    mysql在innodb存储引擎的行级锁的情况下才支持事务。</p><p>四、数据持久性<br>    oracle：保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。<br>    mysql：默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。</p><p>五、提交方式<br>    oracle默认不自动提交，需要用户手动提交。<br>    mysql默认是自动提交。</p><p>六、逻辑备份<br>    oracle逻辑备份时不锁定数据，且备份的数据是一致的。<br>    mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用。</p><p>七、热备份<br>    oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。<br>    mysql：myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。</p><p>八、sql语句的扩展和灵活性<br>    mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。<br>    oracle在这方面感觉更加稳重传统一些。</p><p>九、复制<br>    oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。<br>    mysql：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p><p>十、性能诊断<br>    oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等<br>    mysql的诊断调优方法较少，主要有慢查询日志。</p><p>十一、权限与安全<br>    mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。<br>    oracle的权限与安全概念比较传统，中规中矩。</p><p>十二、分区表和分区索引<br>    oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。<br>    mysql的分区表还不太成熟稳定。</p><p>十三、管理工具<br>    oracle有多种成熟的命令行、图形界面、web管理工具，还有很多第三方的管理工具，管理极其方便高效。<br>    mysql管理工具较少，在linux下的管理工具的安装有时要安装额外的包（phpmyadmin, etc)，有一定复杂性。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
